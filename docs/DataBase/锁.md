# 锁机制

## 表级锁和行级锁

MySQL 中提供了两种锁粒度：表级锁以及行级锁。

应该尽量**只锁定需要修改的那部分数据**，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。

但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此锁粒度越小，系统开销就越大。

在选择锁粒度时，需要在锁开销和并发程度之间做一个权衡。

- **表级锁**

  * MySQL 中锁定**粒度最大**的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁；

  * 锁定粒度最大，触发锁冲突的概率最高，并发度最低。

- **行级锁**
  * MySQL 中锁定**粒度最小**的一种锁，只针对当前操作的行进行加锁。 
  * 行级锁能大大减少数据库操作的冲突。
  * 行锁加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，甚至会出现死锁。





MySQL 隐式与显示锁定

MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。

InnoDB 也可以使用特定的语句进行显示锁定：

```sql
SELECT ... LOCK In SHARE MODE;
SELECT ... FOR UPDATE;
```

。因为这些锁数据库**隐式**帮我们加了

- 对于`UPDATE、DELETE、INSERT`语句，**InnoDB**会**自动**给涉及数据集加排他锁（X)
- **MyISAM**在执行查询语句`SELECT`前，会**自动**给涉及的所有表加**读锁**，在执行更新操作（`UPDATE、DELETE、INSERT`等）前，会**自动**给涉及的表加**写锁**，这个过程并**不需要用户干预**

只会在某些特定的场景下才需要**手动**加锁，学习数据库锁知识就是为了:

- 能让我们在特定的场景下派得上用场
- 更好**把控自己写的程序**
- 在跟别人聊数据库技术的时候可以搭上几句话
- **构建自己的知识库体系**！在面试的时候不虚





**MyISAM和InnoDB存储引擎使用的锁：**

- MyISAM采用表级锁(table-level locking)。

- InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁

  **表级锁和行级锁对比：**

  - **表级锁：** Mysql中锁定 **粒度最大** 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。
  - **行级锁：** Mysql中锁定 **粒度最小** 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。



# =============================

**InnoDB存储引擎的锁的算法有三种：**

- Record lock：单个行记录上的锁

- Gap lock：间隙锁，锁定一个范围，不包括记录本身

- Next-key lock：record+gap 锁定一个范围，包含记录本身

  **相关知识点：**

  1. innodb对于行的查询使用next-key lock
  2. Next-locking keying为了解决Phantom Problem幻读问题
  3. 当查询的索引含有唯一属性时，将next-key lock降级为record key
  4. Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生
  5. 有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1

# =============================



# 参考资料

- [数据库两大神器【索引和锁】](https://segmentfault.com/a/1190000015738121#articleHeader12)

- [MySql锁机制简单了解一下](https://blog.csdn.net/qq_34337272/article/details/80611486)