<!-- GFM-TOC -->
* [选择优化的数据类型](#选择优化的数据类型)
    * [数据类型的选择原则](#数据类型的选择原则)
    * [整数类型](#整数类型)
    * [实数类型](#实数类型)
    * [字符串类型](#字符串类型)
    * [日期和时间类型](#日期和时间类型)    
*  [Schema设计中的陷阱](#Schema设计中的陷阱)
    * [不好的设计](#不好的设计)
* [范式和反范式](#范式和反范式)
    * [范式的优点和缺点](#范式的优点和缺点)
    * [反范式的优点和缺点](#反范式的优点和缺点)
    * [混用范式化和反范式化](#混用范式化和反范式化)
* [缓存表和汇总表](#缓存表和汇总表)
    * [物化视图](#物化视图)
    * [计数器表](#计数器表)
    * [更快地读，更慢地写](#更快地读，更慢地写)
* [加快修改表结构操作的速度](#加快修改表结构操作的速度)
    * [只修改.frm文件](#只修改.frm文件)
    * [快速创建MyISAM索引](#快速创建MyISAM索引)
<!-- GFM-TOC -->
# 选择优化的数据类型

## 数据类型的选择原则：

* 更小的通常更好

一般情况下，应该尽量使用可以正确存储数据的最小数据类型。在schema的设计的时候，如果无法确定哪个数据类型是最好的，
就选择你认为不会超过范围的最小类型。

* 简单就好

简单数据类型的操作通常需要更少的CPU周期，通常情况，整数比字符操作代价低，因为
字符集和校对规则使得字符比较比整型比较更为复杂。

* 尽量避免NULL

通常情况下最好指定列为NOT NULL，除非真的有需要存储NULL值。对于查询来说，包含了可为NULL的列，更难被优化。
因为可为NULL的列使得索引、索引统计和值比较都更为复杂。

在为列选择数据类型的时候，
1. 第一步需要确定合适的大类型：数字、字符串、时间等；
2. 第二步是选择具体类型，很多的数据类型可以存储相同类型的数据，只是存储的
长度和范围不一样、允许的精度不同，或者需要的物理空间不同。
## 整数类型
MySQL可以为整数类型指定宽度，例如INT(11),对于大多数应用这是没有意义的；这并不会限制值的合法范围，
只是规定了MySQL的一些交互工具(例如MySQL的命令行)用来显示字符的个数。对于存储和计算来说，是没有差别的。
## 实数类型
应该尽量只在对小数进行精确计算时才使用DECIMAL，使用int类型通过程序控制单位效果更好

## 字符串类型
### VARCHAR
VARCHAR类型用于存储可变长字符串，是最常见的字符串数据类型。它比定长更节省空间，因为它仅使用必要的空间。
其中它需要使用1或2个额外字节记录字符串的长度。 
VARCHAR节省了存储空间，所以对于性能是有帮助的。但是，由于行是变长的，在UPDATE时可能使得行变得比原来更长
，这就导致需要做额外的工作。  

使用VARCHAR合适的情况：
* 字符串列的最大长度比平均长度大很多；
* 列的更新很少，所以碎片不是问题；
* 使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储。
### CHAR
CHAR类型的定长的，MYSQL中会删除的CHAR类型数据所有的末尾空格，CHAR值会根据需要采用空格进行填充
以方便比较。

使用CHAR合适的情况：
* CHAR适合存储很短的字符串，或者所有值都接近同一个长度；例如，非常适合存储MD5值。
* 不容易产生碎片，在存储空间上更有效率，对于经常变更的数据，CHAR比VARCHAR更好。
## 日期和时间类型 
### DATETIME
能保存大范围的值，从1001年到9999年，精度是秒。它把日期和时间封装到格式为YYYYMMDDHHMMSS的整数，
与时区无关，使用8个字节的存储空间。
### TIMESTAMP
保存从1970年1月1日午夜（格林尼治时间标准时间）以来的秒数，它和UNIX时间戳相同，只使用4个字节的存储空间。
因此，它的表示范围比DATETIME小得多;只能表示从1970年到2038年，其中它的显示值也依赖于时区。

通常应该尽量使用TIMESTAMP，它比DATETIME空间效率更高。

# Schema设计中的陷阱
## 不好的设计：
* 太多的列：

因为MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过**行缓冲格式拷贝数据**，然后再将缓冲的内容解码成每一列。
从行缓冲中将编码过的列转换成行数据结构的代价是非常高的。

* 太多的关联：

一个粗略的经验法则，如果希望查询执行快速且并发性好的话，单个查询语句的关联最好限制在12张表以内。

* 全能的枚举：

注意防止过度使用枚举（ENUM）


* 变相的枚举：

枚举列允许在列中存储一组定义值中的单个值，集合列则允许在列中存储一组定义值中的一个或多个值。

* 非此发明（Not Invent Here）的NULL：

处理NULL确实不容易，但有时候会比它的替代方案更好。

# 范式和反范式
尤其对于写密集的场景，需要对schema进行范式化设计。
## 范式的优点和缺点：
### 优点：
* 范式化的更新操作通常比反范式化要快
* 当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据
* 范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快
* 很少有多余的数据意味着检索列表数据时更少需要DISTINCT或者GROUP BY语句
## 缺点：
范式化设计的缺点是通常需要关联，关联导致代价高，也可能造成一些索引策略无效。
## 反范式的优点和缺点
反范式化的schema使得所有的数据都在一张表中，这样可以避免关联。
如果不需要关联表，则避免了随机I/O，能够使用更有效的索引策略。
## 混用范式化和反范式化
在实际应用中经常需要混用，可能使用部分范式化的schema、缓存表，以及其他技巧。
最常见的反范式化数据的方法是复制或者缓存，在不同的表中存储相同的特定列。

# 缓存表和汇总表
有时提升性能最好的方法是同一张表中保存衍生的冗余数据，
有时也需要创建一张完全独立的汇总表或缓存表。

>缓存表：表示存储那些可以比较简单地从schema其他表获取（但是每次获取的速度比较慢）数据的表。
>汇总表：保存的是使用GROUP BY语句聚合数据的表（例如，数据不是逻辑上冗余的）,也称为累积表(Roll-Up Table)

在使用缓存表和汇总表的时候，必须决定是实时维护数据还是定期重建。当在重建汇总表和缓存表时，
通常需要保证数据在操作时依然可用，这就需要通过使用“影子表”来实现，“影子表”值的是一张在真实表“背后”创建的表。
当完成建表操作后，可用通过一个原子的重命名操作切换影子表和原表。

## 物化视图
物化视图实际上是预先计算并且存储在磁盘上的表，可以通过各种各样的策略刷新和更新。
MySQL并不原生支持，可以使用开源工具Flexviews来实现物化视图。
## 计数器表
如果应用在表中保存计数器，则在更新计数器时可能踫到并发问题，
创建一张独立的表存储计数器，这样可以使得计数器小且快，可以帮助避免查询缓存失效。

为了解决独立表并发问题可以建多行，根据id随机更新，然后统计结果的时候进行聚合查询。
## 更快地读，更慢地写
为了提升查询性能建立的一些额外的索引、冗余行、缓存表和汇总表，这些都会增加写查询的负担，也需要额外的维护任务
，但是这是在设计高性能数据库的时候常见的一些技巧。然而，写操作速度变慢并不是读操作提升付出的唯一代价，还可能
同时增加了读操作和写操作的开发难度。
# 加快修改表结构操作的速度
MySQL的ALTER TABLE操作的性能对于大表来说是个大问题。MySQL执行大部分修改表结构操作的方法是用新结构
创建一个空表，然后再从旧表中查询出所有的数据插入新表中，最后删除旧表，这样操作的代价特别高。

对于常见的场景的两种技巧：
* 一是先在一台不提供服务的机器上执行ALTER TABLE操作，然后和提供服务的主库进行切换
* 二是通过“影子拷贝”，就是创建一张和旧表无关的新表，然后通过重命名和删表操作交换两张表及里面的数据
## 只修改.frm文件
下面这些操作有可能不需要重建表：

- 移除一个列的AUTO_INCREMENT属性；
- 增加、移除，或更改ENUM和SET常量。如果移除的是已经有行数据用到其值的常量，查询将返回一个空字符串。 

修改.frm文件的速度很快，有时候没有必要重建表，基本的技术就是：**为想要的表结构创建一个新的
.frm文件，然后用它替换掉已经存在的那张表的.frm文件。**

## 快速创建MyISAM索引
为了高效地载入数据到MyISAM表中，常见的技巧是：先禁用索引，载入数据，然后重新启用索引。
这个技巧能够发挥作用，是因为构件索引的工作被延迟到数据完全载入以后

在现代版本的InnoDB版本中，有一个类似的技巧，这依赖于InnoDB的快速在线索引创建功能，先删除所有的为
唯一索引，然后增加新的列，最后重新创建删除掉的索引。




