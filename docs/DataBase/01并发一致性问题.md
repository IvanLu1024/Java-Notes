<!-- GFM-TOC -->
* [二、并发一致性问题](#二并发一致性问题)
    * [丢失修改](#丢失修改)
    * [读脏数据](#读脏数据)
    * [不可重复读](#不可重复读)
    * [幻影读](#幻影读)
<!-- GFM-TOC -->

# 二、并发一致性问题

在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。

## 丢失修改

T<sub>1</sub> 和 T<sub>2</sub> 两个事务都对一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。

<div align="center"> <img src="pics//88ff46b3-028a-4dbb-a572-1f062b8b96d3.png" width="350"/> </div><br>

## 读脏数据

T<sub>1</sub> 修改一个数据，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。

<div align="center"> <img src="pics//dd782132-d830-4c55-9884-cfac0a541b8e.png" width="400"/> </div><br>

## 不可重复读

T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

<div align="center"> <img src="pics//c8d18ca9-0b09-441a-9a0c-fb063630d708.png" width="350"/> </div><br>

## 幻影读

T<sub>1</sub> 读取某个**范围**的数据，T<sub>2</sub> 在这个**范围**内插入新的数据，T<sub>1</sub> 再次读取这个**范围**的数据，此时读取的结果和和第一次读取的结果不同。

<div align="center"> <img src="pics//72fe492e-f1cb-4cfc-92f8-412fb3ae6fec.png" width="350"/> </div><br>

----

产生并发不一致性问题主要原因是破坏了事务的**隔离性**，解决方法是通过**并发控制**来保证隔离性。并发控制可以通过封锁（加锁）来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。