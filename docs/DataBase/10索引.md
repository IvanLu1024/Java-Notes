<!-- GFM-TOC -->
* [一、索引](#一索引)
    * [索引的目的](#索引的目的)
    * [索引的原理](#索引的原理)
    * [B+ Tree](#b-tree-原理)
    * [MySQL 索引分类](#mysql-索引)
    * [索引设计优化](#索引设计优化)
    * [索引的优点](#索引的优点)
    * [索引的使用条件](#索引的使用条件)
<!-- GFM-TOC -->
# 一、索引

MySQL 索引的官方定义：

索引（index）是帮助 MySQL 高效获取数据的**数据结构**。

数据库查询是数据库的最主要功能之一。我们希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。常见的查找算法有：

- 顺序查找
- 二分查找
- 二叉树查找

每种查找算法都只能应用于特定的数据结构，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树。显然，数据库中的数据本身的组织结构不可能完全满足各种数据结构，因此，在数据之外，数据库系统维护着**满足特定查找算法的数据结构**，这些数据结构以某种方式“指向”数据，这样可在这些数据结构上实现高级查找算法。上述这种数据结构，就是索引。

**索引的目的在于提高查询效率**。可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到 m 字母，
然后从下往下找到 y 字母，再找到剩下的 sql。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，显然这样的效率很低。

## B+ Tree

### 1、数据结构

- B Tree 是平衡多路查找树（查找路径不止2条）。

  B+ 树是一颗查找树，是遵循左小右大的原则，并且所有叶子节点位于同一层。

- B+ Tree 是 B Tree 的升级版，是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的**平衡性**，并且通过**顺序访问指针**来提高区间查询的性能。

- B+ Tree 的**非叶子节点不保存关键字记录的指针，只进行数据索引，只有叶子节点保存数据**，这样使得 B+ 树每个非叶子节点所能保存的关键字大大增加。

- B+ Tree 中，一个节点中的 key 从左到右**非递减排列**，如果某个指针的左右相邻 key 分别是 key<sub>i</sub> 和 key<sub>i+1</sub>，且不为 null，则该指针指向节点的所有 key 大于等于 key<sub>i</sub> 且小于等于 key<sub>i+1</sub>（闭区间）。

- B+ Tree 的所有叶子节点均有一个链指针指向下一个叶子节点。

<div align="center"><img src="https://gitee.com/duhouan/ImagePro/raw/master/java-notes/database/B_plus_tree.png"/></div>

### 2、操作

查找时，首先在根节点进行**二分查找**，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。

注：B+ 树中依次插入 6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 过程：

<div align="center"><img src="https://gitee.com/duhouan/ImagePro/raw/master/java-notes/database/MySQL_6.gif"/></div>



### 3、B+ 树两种搜索方法

- 一种是按叶节点自己拉起的链表顺序搜索。
- 一种是从根节点开始搜索，和 B Tree 类似，不过如果非叶节点的关键码等于给定值，搜索并不停止，而是继续沿右指针，一直查到叶节点上的关键码。所以无论搜索是否成功，都将走完树的所有层。

### 4、B+ 树作为数据库索引结构

一般来说，索引本身也很大，不可能全部存储在内存中，因此**索引往往以索引文件的形式存储的磁盘上**。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 I/O 操作次数的渐进复杂度。

换句话说，**索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数**。

数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下原因：

- **B+ 树的磁盘读写代价更低**。

  因为非叶子结点只存储索引，其内部存储空间更小，这样一次性读入内存的数据就更多，相对来说磁盘的 I/O次数就减少了。

  举个例子：假设磁盘中的一个盘块容纳 16 字节，而一个 key 占 2 字节，一个 key 具体信息指针占 2 字节。一棵 9 阶 B 树(一个结点最多 8 个关键字)的内部结点需要 2 ( (8*(2+2) / 16 = 2)个盘块。B+ 树内部结点只需要 1 （8 * 2 / 16 = 1）个盘块。当需要把内部结点读入内存中的时候，B 树就比 B+ 树多 1 次盘块查找时间。

- **B+ 树的查询效率更加稳定**。

  由于非叶子结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

- **B+ 树更有利于对数据库的扫描**。

  B+ 树只要遍历叶子结点就可以遍历到所有数据。

###  5、B+ 树的性质

- I/O 次数取决于 B+ 树的高度 h，假设当前数据表的数据为 N，每个磁盘块的数据项的数量是 m，则有h=log<sub>(m+1)</sub>N。

  当数据量 N 一定的情况下，m 越大，h 越小；而 m = 磁盘块的大小 / 数据项的大小，由于磁盘块的大小是固定的，即一个数据页的大小，如果数据项占的空间越小，数据项（m）的数量就越多，树的高度越小。

这就是为什么每个数据项，即索引字段要尽量的小，比如 int 占 4 字节，要比 bigint 8字节少一半。
这也是为什么 B+ 树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增大。

- 当B+树的数据项是复合的数据结构。

比如(name,age,sex)的时候，B+ 树是按照**从左到右**的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，B+ 树会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex，最后得到检索的数据；
但当(20,F)这样的没有 name 的数据来的时候，B+ 树就不知道下一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，B+ 树可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即**索引的最左匹配特性**。

## 索引的物理存储

索引是在**存储引擎层实现**的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。

MySQL主要的存储引擎是 MyISAM 和 InnoDB。

### MyISAM 索引存储机制

MyISAM 引擎使用 B+ 树作索引结构，**叶子节点的 data 域存放的是数据记录的地址**。

<div align="center"><img src="https://gitee.com/duhouan/ImagePro/raw/master/java-notes/database/MySQL_1.png" width="600px"/></div>

上图是一个 MyISAM 表的主索引（Primary key）示意图。

假设该表一共有三列，以 Col1 为主键。MyISAM 的索引文件仅仅保存数据记录的地址。

在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 **key 可以重复**。如果在 Col2 上建立一个辅助索引，则该辅助索引的结构如下：

<div align="center"><img src="https://gitee.com/duhouan/ImagePro/raw/master/java-notes/database/MySQL_2.png" width="600px"/></div>

同样也是一棵 B+ 树，data 域保存数据记录的地址。

MyISAM 中首先按照 B+ 树搜索算法搜索索引，如果指定的 key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。
MyISAM 的索引方式也叫做非聚集索引。

### InnoDB 索引存储机制

InnoDB 也使用 B+ 树作为索引结构。

InnoDB 的数据文件本身就是索引文件。MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在 InnoDB 中，表数据文件本身就是按 B+ 树组织的一个索引结构，这棵树的**叶子节点 data 域保存了完整的数据记录**。这个索引的 key 是数据表的主键，因此 **InnoDB 表数据文件本身就是主索引**。

<div align="center"><img src="https://gitee.com/duhouan/ImagePro/raw/master/java-notes/database/MySQL_3.png" width="600px"/></div>



上图是 InnoDB 主索引（同时也是数据文件）的示意图。可以看到叶子节点包含了完整的数据记录。

这种索引叫做**聚集索引**。因为 InnoDB 的数据文件本身要按主键聚集，所以 InnoDB 要求表必须有主键（ MyISAM 可以没有），如果没有显式指定，则 MySQL 系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为 6 个字节，类型为长整形。

与 MyISAM 索引的不同是 **InnoDB 的辅助索引 data 域存储相应记录主键的值**而不是地址。例如，定义在 Col3 上的一个辅助索引：

<div align="center"><img src="https://gitee.com/duhouan/ImagePro/raw/master/java-notes/database/MySQL_4.png" width="500px"/></div>

聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索 2 遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

注意 InnoDB 索引机制中：

- 不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。

- 不建议用非单调的字段作为主键，因为 InnoDB 数据文件本身是一棵 B+ 树，非单调的主键会造成在插入新记录时数据文件为了维持 B+ 树的特性而频繁的分裂调整，十分低效。

  使用自增字段作为主键则是一个很好的选择。


## B+ 树索引与哈希索引

Mysql 索引中使用的最多的就是 **B+ 树索引**和**哈希索引 **。

### 1、B+ 树索引

是大多数 MySQL 存储引擎的默认索引类型。因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。除了用于查找，还可以用于排序和分组。可以指定多个列作为索引列，多个索引列共同组成键。

适用于全键值、键值范围和键前缀查找，其中**键前缀查找只适用于最左前缀查找**。如果不是按照索引列的顺序进行查找，则无法使用索引。

### 2、哈希索引

哈希索引就是采用一定的**哈希算法**，把键值换算成新的哈希值，检索时不需要类似 B+ 树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可**立刻定位到相应位置，速度非常快**。

哈希索引底层的数据结构是哈希表，能以 O(1) 时间进行查找，但是失去了有序性；因此在绝大多数需求为**单条记录查询**的时候，可以选择哈希索引，查询性能最快。哈希索引的不足：

- 无法用于排序与分组；
- 只支持**精确查找**，无法用于部分查找和范围查找；
- 不能避免表扫描；
- 遇到大量Hash冲突的情况效率会大大降低

**InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”**，当某个索引值被使用的非常频繁时，会在 B+ 树索引之上再创建一个哈希索引，这样就让 B+ 树索引具有哈希索引的一些优点，比如快速的哈希查找。

## MySQL 索引分类

### 1、普通索引

基本的索引，它没有任何限制。

```mysql
ALTER TABLE `table_name` ADD INDEX index_name ( `column` )
```

或者：

```mysql
CREATE INDEX index_name ON table_name (column_list)
```

### 2、唯一索引

与普通索引类似，不同的是：MySQL 数据库索引列的值必须唯一，但允许有空值；如果是组合索引，则列值的组合必须唯一。

```mysql
ALTER TABLE `table_name` ADD UNIQUE ( `column` ) 
```

或者：

```mysql
CREATE UNIQUE INDEX index_name ON table_name (column_list)
```

### 3、主键索引

它是一种**特殊的唯一索引**，不允许有空值。

```mys
ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) 
```

### 4、全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。

全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。

可以从 CHAR、VARCHAR 或 TEXT 列中作为 CREATE TABLE 语句的一部分被创建，或是使用 ALTER TABLE 或CREATE INDEX 。

```mysql
CREATE TABLE `table` (
	`id` int(11) NOT NULL AUTO_INCREMENT ,
	`title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,
	`content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,
	PRIMARY KEY (`id`),
	FULLTEXT (content) # 针对 content 做了全文索引
);
```

注意：

- 如果可能，请尽量先创建表并插入所有数据后再创建全文索引，而不要在创建表时就直接创建全文索引，因为前者比后者的全文索引效率要高。

- 查找条件使用 MATCH AGAINST，而不是普通的 WHERE。

  ```mysql
  SELECT * FROM article WHERE MATCH( content) AGAINST('想查询的字符串')
  ```

- MySQL 自带的全文索引只能对英文进行全文检索，目前无法对中文进行全文检索。

- InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。

### 5、组合索引（多列索引）

组合索引是在多个字段上创建的索引。**组合索引遵守“最左前缀”原则**，**即在查询条件中使用了组合索引的第一个字段，索引才会被使用**。因此，在组合索引中索引列的顺序至关重要。

```mysql
ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )
```

或者

```mysql
CREATE TABLE index_name ON `table_name`( `column1`, `column2`, `column3` )
```

## 索引设计优化

### 1、独立的列

在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

例如下面的查询不能使用 actor_id 列的索引：

```sql
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

### 2、多列索引

在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。

```sql
SELECT film_id, actor_ id FROM sakila.film_actor
WHERE actor_id = 1 AND film_id = 1;
```

### 3、 索引列的顺序

让选择性最强的索引列放在前面。

索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。

例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。

```sql
SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
COUNT(*)
FROM payment;
```

```html
   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049
```

### 4、前缀索引

对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。

对于前缀长度的选取需要根据索引选择性来确定。

### 5、覆盖索引

**索引包含所有需要查询的字段的值。**

具有以下优点：

- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
- 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。
- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。

## 索引的优点

- 大大减少了服务器需要扫描的数据行数。

- 帮助服务器避免进行排序和分组，以及避免创建临时表（B+树索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表）。

- 将随机 I/O 变为顺序 I/O（B+ 树索引是有序的，会将相邻的数据都存储在一起）。

## 索引的使用条件

- 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；
- **对于中到大型的表，索引就非常有效**；
- 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。

# 参考资料

- [干货：mysql索引的数据结构](https://www.jianshu.com/p/1775b4ff123a)
- [MySQL优化系列（三）--索引的使用、原理和设计优化](https://blog.csdn.net/Jack__Frost/article/details/72571540)
- [数据库两大神器【索引和锁】](https://juejin.im/post/5b55b842f265da0f9e589e79#comment)

- [Mysql索引整理总结](https://blog.csdn.net/u010648555/article/details/81102957)