# [第二章 查找问题](#查找问题)

| 章节 | 典型题目 | 相关题目 | 更多扩展练习 | 难题推荐 |
| :---: | :---: | :---: | :---: | :---: |
| [2-1 set的使用 Intersection of Two Arrays](#set的使用) | [349](#349) | [无] | [874](#874) | |
| [2-2 map的使用 Intersection of Two Arrays II](#map的使用) | [350](#350) | [无] | | |
| [2-3 set和map不同底层实现的区别](#set和map不同底层实现的区别) | [349](#349) [350](#350) | [202](#202) [136](#136) [242*](#242)  [290*](#290) [205](#205) [804](#804) | [451*](#451) [705*](#705) [706*](#706)  | |
| [2-4 使用查找表的经典问题 Two Sum](#使用查找表的经典问题) | [1](#1) | [15](#15) [18](#18) [16](#16) | | |
| [2-5 灵活选择键值 4Sum II](#灵活选择键值I) | [454](#454) | [49](#49) | [697](#697)  | |
| [2-6 灵活选择键值 Number of Boomerangs](#灵活选择键值II) | [447](#447) | [149](#149) [719](#719) | | |
| [2-7 查找表和滑动窗口 Contain Duplicate II](#查找表和滑动窗口) | [219](#219) | [217](#217) | | |
| [2-8 二分搜索树底层实现的顺序性 Contain Duplicate III](#二分搜索树底层实现的顺序性) | [220](#220) | [无] |  [729*](#729) [731*](#731) [855*](#855) | |
| [补充1：查找表的更多问题](#查找表的更多问题) | [无] | [无] | [811](#811) [819](#819) [869*](#869) [884](#884) [888](#888) [890](#890) [893](#893) | 128 |

# 查找问题
## set的使用

> 查找有无

元素‘a’是否存在？set

> 查找对应关系（键值对应）

元素‘a’出现了几次？map

### 349
[349 Intersection of Two Arrays](https://leetcode.com/problems/intersection-of-two-arrays/description/)

* 问题描述： 

给定两个数组nums,求两个数组的公共元素。结果中每个元素只能出现一次，
出现的顺序可以是任意的

* 示例：

nums1=[1,2,2,1],nums2=[2,2]

结果为[2]

* 解题：

要求结果只出现一次，马上要想到set(该集合不允许重复元素)，最终求两个数组的交集，
就是求这两个数组相应的set的交集。

```java
public int[] intersection(int[] nums1, int[] nums2) {
    HashSet<Integer> record = new HashSet<>();
    for(int num : nums1){
        record.add(num);
    }

    HashSet<Integer> resultSet = new HashSet<>();
    for(int num : nums2){
        if(record.contains(num)){
            resultSet.add(num);
        }
    }

    int[] res = new int[resultSet.size()];
    int index = 0;
    for(int num : resultSet){
        res[index++] = num;
    }
    return res;
}
```

### 874
[874 Walking Robot Simulation](https://leetcode.com/problems/walking-robot-simulation/description/)
```java
/**
* 问题描述：
机器人在一个无限大小的网格上行走，从点 (0, 0) 处开始出发，面向北方。
该机器人可以接收以下三种类型的命令：

-2：向左转 90 度
-1：向右转 90 度
1 <= x <= 9：向前移动 x 个单位长度
在网格上有一些格子被视为障碍物。

第 i 个障碍物位于网格点  (obstacles[i][0], obstacles[i][1])
如果机器人试图走到障碍物上方，那么它将停留在障碍物的前一个网格方块上，但仍然可以继续该路线的其余部分。
返回从原点到机器人的最大欧式距离的平方。
  

* 示例：

示例 1：
输入: commands = [4,-1,3], obstacles = []
输出: 25
解释: 机器人将会到达 (3, 4)

示例 2：
输入: commands = [4,-1,4,-2,4], obstacles = [[2,4]]
输出: 65
解释: 机器人在左转走到 (1, 8) 之前将被困在 (1, 4) 处

* 提示：

0 <= commands.length <= 10000
0 <= obstacles.length <= 10000
-30000 <= obstacle[i][0] <= 30000
-30000 <= obstacle[i][1] <= 30000
答案保证小于 2 ^ 31
*/
// 思路:
// 1、机器人能向左、向右和向前移动，说明机器人能够向上、下、左、右四个方向移动，那就准备一个二维数组来比表示
// int[][] d={{0,1},{1,0},{0,-1},{-1,0}};
// 2、准备一个set存储障碍物的下标(这里使用字符串表示)，方便判断机器人是否会遇到该障碍物
// 3、如果遇到障碍物，机器人会中断原来的路径，此时执行下一个指令，继续行走
// 4、由于要求得到最大值，机器人最后停下的位置不一定能获取最大值，所以要准备变量记录最大值。
public int robotSim(int[] commands, int[][] obstacles) {
    //set存储障碍物的下标(这里使用字符串表示)，方便判断机器人是否会遇到该障碍物
    HashSet<String> record = new HashSet<>();
    for(int[] obstacle:obstacles){
        record.add(obstacle[0]+","+obstacle[1]);
    }

    //direction表示一开始的时候机器人的方向，direction=0，表示机器人一开始向北(对应 d数组中向上)
    int direction=0;
    //x,y是机器人所在位置的横、纵坐标。初始位置就是原点位置
    int x=0,y=0;

    //由于要求得到最大值，机器人最后停下的位置不一定能获取最大值，所以要准备变量记录最大值。
    int max = 0;

    //遍历命令数组，根据命令机器人会做相应的行走动作
    for(int command : commands){
        if(command == -1){ //右转命令
            direction = (direction+1) % 4;
            //对应d数组中的  {1,0} //向右
        }else if(command == -2){//左转命令
            direction = (direction+3) % 4;
            //对应d数组中的  {-1,0} //向左
        }else{ //表示直接走 command步
            while(command -- >0){
                int newX = x + d[direction][0];
                int newY = y + d[direction][1];
                String newPos = newX+","+newY;
                //判断是否遇到障碍物
                if(record.contains(newPos)){
                    break;
                }
                //每走一步就要更新坐标，但是遇到障碍物，就不能更新，
                //所以要先判断是否遇到障碍物
                x = newX;
                y = newY;
            }
            max = Math.max(max,x*x+y*y);
        }
    }
    return max;
}

private int[][] d = {
        {0,1}, //向上
        {1,0}, //向右
        {0,-1}, //向下
        {-1,0} //向左
};
```

## map的使用
### 350
[350 Intersection of Two Arrays II](https://leetcode.com/problems/intersection-of-two-arrays-ii/description/)

* 问题描述：

给定两个数组nums,求两个数组的交集。

* 示例：

nums1=[1,2,2,1],num2=[2,2]

结果为[2,2]

出现的顺序是任意的

* 解题：
```java
public int[] intersect(int[] nums1, int[] nums2) {
    //record 统计nums1数组中元素次数
    HashMap<Integer,Integer> record = new HashMap<>();
    for(int num : nums1){
        int freq = record.getOrDefault(num,0);
        record.put(num,++freq);
    }

    //记录交集元素
    ArrayList<Integer>  resultList = new ArrayList<>();

    for(int num : nums2){
        //nums2中num在record中出现次数
        int count = record.getOrDefault(num,0);
        if(count > 0){ //count > 0，表示该num是交集中元素
            resultList.add(num);
            //record中相应的公共元素出现次数就减1
            record.put(num,count -1);
        }
    }

    int[] res = new int[resultList.size()];
    for(int i=0;i<res.length;i++){
        res[i] = resultList.get(i);
    }
    return res;
}
```
## set和map不同底层实现的区别

### 202
[202 Happy Number](https://leetcode.com/problems/happy-number/description/)
```java
/**
* 问题描述：
编写一个算法来判断一个数是不是“快乐数”。
一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，
然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。
如果可以变为 1，那么这个数就是快乐数。
  
* 示例: 
输入: 19
输出: true
解释: 
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
*/
//思路：
// 1、计算产生的中间数
// 2、使用 set 记录这些中间数(set中的数据是不重复的)，
// 显然，如果产生的新中间数，在set中以存在该数，则该数不可能是幸运数
public boolean isHappy(int n) {
    //记录产生的中间数
    HashSet<Integer> record = new HashSet<>();
    while(n!=1){
        if(record.contains(n)){
            return false;
        }else{
            n = getNumber(n);
            record.add(n);
        }
    }
    return true;
}

//根据n，产生 n的中间数
private int getNumber(int n){
    int number = 0;
    while(n>0){
        number += (n%10) * (n%10);
        n /= 10;
    }
    return number;
}
```

### 136
[136 Single Number](https://leetcode.com/problems/single-number/description/)

* 解法一：
```java
/**
* 问题描述：

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。
找出那个只出现了一次的元素。
  
说明：
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
  
示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4
*/
//思路一：借助 Map
public int singleNumber(int[] nums) {
    Map<Integer,Integer> map=new HashMap<>();
    for(int i=0;i<nums.length;i++){
        int freq=map.getOrDefault(nums[i],0);
        map.put(nums[i],++freq);
    }
    int ret=0;
    for(Integer key:map.keySet()){
        int value=map.get(key);
        if(value==1){
            ret=key;
            break;
        }
    }
    return ret;
}
```

```java
//思路二：
// 1、既然除了一个整数之外其他的整数都是“成对出现”，那要是有办法把这些“成对出现”的数字直接消去就好了。
// 2、异或（^）运算来进行消除，这样成对的整数会被消成0，最后0和单独的整数异或结果不变
public int singleNumber(int[] nums) {
    int ret=nums[0];
    for(int i=1;i<nums.length;i++){
        ret^=nums[i];
    }
    return ret;
}
```

### 242
[242 Valid Anagram](https://leetcode.com/problems/valid-anagram/description/)

```java
/**
* 问题描述：
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。

* 示例：

示例 1:
输入: s = "anagram", t = "nagaram"
输出: true

示例 2:
输入: s = "rat", t = "car"
输出: false

* 说明:
你可以假设字符串只包含小写字母。
* */
// 思路一：
// 1、字母异位词两个单词的字母即字母出现的次数都相同
// 2、准备一个**Map集合**，统计字符串中字母出现的次数
// 3、如果两个单词是字母异位词的话，则他们的统计结果相同；不相同，就不是字母异位词。
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) {
        return false;
    }

    //统计 s 字符串中字符出现的次数
    HashMap<Character,Integer> record = new HashMap<>();
    for(int i=0;i<s.length();i++){
        char c = s.charAt(i);
        int freq = record.getOrDefault(c,0);
        record.put(c,++freq);
    }

    for(int i=0;i<t.length();i++){
        char c = t.charAt(i);
        int freq = record.getOrDefault(c,0);
        if(freq == 0){
            return false;
        }
        record.put(c,--freq);
    }
    return true;
}
```

```java
//思路二：既然只有26个小写字母，则统计字母出现次数，我们可以使用数组来代替Map集合
public boolean isAnagram(String s, String t) {
    if(s.length() != t.length()){
        return false;
    }

    //统计 s 字符串中字符出现的次数(只有小写26个字母，所以数组长度设置为26)
    int[] record = new int[26];
    for(int i=0;i<s.length();i++){
        char c = s.charAt(i);
        record[c-'a']++;
    }

    for(int i=0;i<t.length();i++){
        char c = t.charAt(i);
        //t 字符串中不存在 c 字符
        if(record[c-'a'] == 0){
            return false;
        }
        record[c-'a']--;
    }
    return true;
}
```

````java
//思路三：对思路二的改进,以空间换时间 
//TODO:推荐使用
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) {
        return false;
    }

    int[] record = new int[26];

    char[] ss = s.toCharArray();
    char[] tt = t.toCharArray();

    for(char c : ss){
        record[c]++;
    }
    for(char c : tt){
        record[c]--;
    }
    //如果 s和t 是字母异位词,则此时record数组中的所有元素都为 0
    for(int i=0;i<record.length;i++){
        if(record[i]>0){
            return false;
        }
    }
    return true;
}
````

### 290
[290 Word Pattern](https://leetcode.com/problems/word-pattern/description/)
```java
/**
* 问题描述：
给定一种 pattern(模式) 和一个字符串 str ，判断 str 是否遵循相同的模式。这里的遵循指完全匹配，
例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应模式。

* 示例：
示例1:
输入: pattern = "abba", str = "dog cat cat dog"
输出: true

示例 2:
输入:pattern = "abba", str = "dog cat cat fish"
输出: false

示例 3:
输入: pattern = "aaaa", str = "dog cat cat dog"
输出: false
*/

//思路：
//1、一个字符对应一个单词，实际上就是一个映射问题，很自然的就想到map，即 <字符，字符串>
//2、将相应字符和单词存储在Map中，遇到同一个字符，则对应的单词应该是一样的，否则就说明模式不匹配
//3、如果遇到不同的字母，但是映射的单词是相同的，也是模式不匹配。比如 a->dog,b->dog,这是不被允许的
public boolean wordPattern(String pattern, String str) {
    String[] words = null;
    //根据 str中的空格分割，获取单词数组
    if(str!=null){
        words = str.split(" ");
    }
    if(pattern.length() != words.length){
        return false;
    }

    HashMap<Character,String> record = new HashMap<>();
    for(int i=0;i<pattern.length();i++){
        char c = pattern.charAt(i);
        String word = words[i];
        if(record.containsKey(c)){
            String oldWord = record.get(c);
            if(! oldWord.equals(word)){
                return false;
            }
        }else{
            //注意这句话：这里的遵循指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应模式。
            //比如 a->dog,则 b->dog是不被允许的,所以不仅要判断 key是否在map中，也要判断 value是否在map中
            if(record.containsValue(word)){
                return false;
            }
            record.put(c,word);
        }
    }
    return true;
}
//时间复杂度：O(n)
//空间复杂度：O(n)
```

### 205
[205 Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings/description/)
```java
/**
* 问题描述：
给定两个字符串 s 和 t，判断它们是否是同构的。
如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。
所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。
两个字符不能映射到同一个字符上，但字符可以映射自己

* 示例：
示例 1:
输入: s = "egg", t = "add"
输出: true

示例 2:
输入: s = "foo", t = "bar"
输出: false

示例 3:
输入: s = "paper", t = "title"
输出: true
*/
//思路：与上一题 290题思路一样
public boolean isIsomorphic(String s, String t) {
    if(s.length() != t.length()){
        return false;
    }

    HashMap<Character,Character> record = new HashMap<>();
    for(int i=0;i<s.length();i++){
        char c1 = s.charAt(i);
        char c2 = t.charAt(i);
        if(record.containsKey(c1)){
            char oldC2 = record.get(c1);
            if(c2 != oldC2){
                return false;
            }
        }else{
            if(record.containsValue(c2)){
                return false;
            }
            record.put(c1,c2);
        }
    }
    return true;
}
```

### 804
[804 Unique Morse Code Words](https://leetcode.com/problems/unique-morse-code-words/description/)
```java
/**
* 问题描述：

国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 
比如: "a" 对应 ".-", "b" 对应 "-...", "c" 对应 "-.-.", 等等。
为了方便，所有26个英文字母对应摩尔斯密码表如下：
  [".-","-...","-.-.","-..",".","..-.","--.","....","..",".---",
  "-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-",
  "...-",".--","-..-","-.--","--.."]
给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。
例如，"cab" 可以写成 "-.-..--..."，(即 "-.-." + "-..." + ".-"字符串的结合)。
我们将这样一个连接过程称作单词翻译。

返回我们可以获得所有词不同单词翻译的数量。

* 示例：
输入: words = ["gin", "zen", "gig", "msg"]
输出: 2
解释: 
各单词翻译如下:
"gin" -> "--...-."
"zen" -> "--...-."
"gig" -> "--...--."
"msg" -> "--...--."

共有 2 种不同翻译, "--...-." 和 "--...--.".
*/
//思路：要求我们获取所有词不同单词翻译的数量，我们使用set进行统计可以去除重复元素。
public int uniqueMorseRepresentations(String[] words) {
    if(words==null || words.length==0){
        return 0;
    }
    //统计翻译好的莫斯密码
    Set<String> record = new HashSet<>();
    for(String word : words){
        StringBuilder builder = new StringBuilder();
        for(int i=0;i<word.length();i++){
            char c = word.charAt(i);
            builder.append(morse[c-'a']);
        }
        record.add(builder.toString());
    }
    return record.size();
}

//莫斯密码数组，小标 0 对应字符 'a'
private String[] morse = {
            ".-","-...","-.-.","-..",".","..-.","--.","....","..",".---",
            "-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-",
            "..-","...-",".--","-..-","-.--","--.."
};
```

### 451
[451 Sort Characters By Frequency](https://leetcode.com/problems/sort-characters-by-frequency/description/)
```java
/**
* 问题描述：
给定一个字符串，请将字符串里的字符按照出现的频率降序排列。

* 示例：
示例 1:
输入:
"tree"
输出:
"eert"

解释:
'e'出现两次，'r'和't'都只出现一次。
因此'e'必须出现在'r'和't'之前。此外，"eetr"也是一个有效的答案。

示例 2:
输入:
"cccaaa"
输出:
"cccaaa"
解释:
'c'和'a'都出现三次。此外，"aaaccc"也是有效的答案。
注意"cacaca"是不正确的，因为相同的字母必须放在一起。

示例 3:
输入:
"Aabb"
输出:
"bbAa"

解释:
此外，"bbaA"也是一个有效的答案，但"Aabb"是不正确的。
注意'A'和'a'被认为是两种不同的字符。
*/
//思路：
 //1、题目要求根据出现的次数，进行降序排列。这里必然要使用 map 用来统计字符出现的次数
 //2、这里我们使用 字符出现的次数作为键值，必然会有出现次数相同的字符，将这些字符作为集合构成键值
 //3、使用TreeMap，按照键值大小进行升序排列，最终得到结果。
 public String frequencySort(String s) {
     if(s.length() <= 2){
         return s;
     }
 
     //统计s中 字符出现的次数,ASCII码表示的字符只有256个，所以数组长度设置成256
     int[] freq = new int[256];
     for(int i=0;i<s.length();i++){
         freq[s.charAt(i)] ++;
     }
 
     //我们这里将元素出现的次数设置为键值，一些出现次数相同的元素则被封装成集合
     //TODO:这里使用 TreeMap 按照键值进行盛升序排列
     Map<Integer,List<Character>> record = new TreeMap<>(new Comparator<Integer>() {
         @Override
         public int compare(Integer o1, Integer o2) {
             int num = o2 - o1; //根据键值进行升序排列
             return num;
         }
     });
 
     for(int i=0;i<256;i++){
         int frequency = freq[i];
         if(frequency == 0){
             continue;
         }
         if(! record.containsKey(frequency)){
             //TODO：map中不包含该frequency，则创建新集合，用来存储元素
             record.put(frequency,new ArrayList<>());
         }
         //将i 所表示的字符加入 map中
         record.get(frequency).add((char)i);
     }
 
     StringBuilder res = new StringBuilder();
     for(Integer count : record.keySet()){
         List<Character> list = record.get(count);
         for(Character c : list){
             for(int i=1;i<=count;i++){
                 res.append(c);
             }
         }
     }
     return res.toString();
 }
```

### 705 
[705 Design HashSet](https://leetcode.com/problems/design-hashset/description/)

```java
//思路一：由于涉及到插入和删除，所有优先想到使用链表
class MyHashSet {
        //所有的值都在 [1, 1000000]的范围内。所以可以取虚拟头节点的值是 -1。
        private ListNode dummyHead;
        //采用头插法向链表中插入数据

        /** Initialize your data structure here. */
        public MyHashSet() {
            dummyHead = new ListNode(-1);
        }

        public void add(int key) {
            if(!contains(key)){
                ListNode node = new ListNode(key);
                node.next = dummyHead.next;
                dummyHead.next = node;
            }
        }

        public void remove(int key) {
            if(contains(key)){
                //prev指向 值为 key的元素的前一个元素
                ListNode prev = dummyHead;
                while(prev!=null){
                    if(prev.next.data == key){
                        break;
                    }
                    prev=prev.next;
                }
                ListNode delNode = prev.next;
                prev.next = delNode.next;
            }
        }

        /** Returns true if this set contains the specified element */
        public boolean contains(int key) {
            ListNode cur = dummyHead.next;
            while(cur!=null){
                if(cur.data == key){
                    return true;
                }
                cur = cur.next;
            }
            return false;
        }

        //定义链表节点
        private class ListNode{
            int data;
            ListNode next;
            public ListNode(int data){
                this.data = data;
                this.next = null;
            }
        }
    }
```

```java
//思路二：动态数组思路
class MyHashSet {
    private int[] data;
    private int capacity=10;
    private int size;

    private void resize(int newCapacity){
        int[] newdata=new int[newCapacity];
        for(int i=0;i<size;i++){
            newdata[i]=data[i];
        }
        data=newdata;
    }

    private int find(int key){
        for(int i=0;i<size;i++){
            if(data[i]==key){
                return i;
            }
        }
        return -1;
    }

    /** Initialize your data structure here. */
    public MyHashSet() {
        data=new int[capacity];
        size=0;
    }

    public void add(int key) {
        if(!contains(key)){
            if(size==data.length){
                resize(data.length*2);
            }
            data[size++]=key;
        }
    }

    public void remove(int key) {
        if(contains(key)){
            if(size==data.length/4 && data.length/2!=0){
                resize(data.length/2);
            }
            int index=find(key);
            for(int i=index;i<size-1;i++){
                data[i]=data[i+1];
            }
            size--;
        }
    }

    /** Returns true if this set contains the specified element */
    public boolean contains(int key) {
        if(find(key)!=-1){
            return true;
        }
        return false;
    }
}
```

```java 
//
```


### 706 
[706 Design HashMap](https://leetcode.com/problems/design-hashmap/description/)
```java
/**
 * 思路：
 * 链表地址法，
 * 维护一个链表数组，数组的每个元素指向一个链表
 */
class MyHashMap {
    //注意键值的范围是[1,1000000] 所以数组长度就是1000001
    private ListNode[] data;


    /** Initialize your data structure here. */
    public MyHashMap() {
        data=new ListNode[10000];
    }

    //根据key获取在数组中位置
    private int getIndex(int key){
        return Integer.hashCode(key) % data.length;
    }

    //data的元素就是一个链表，在链表中查找值为key的前一个元素，方便在链表尾部插入
    private ListNode find(ListNode bucket, int key) {
        ListNode node = bucket, prev = null;
        while (node != null && node.key != key) {
            prev = node;
            node = node.next;
        }
        return prev;
    }

    /** value will always be non-negative. */
    public void put(int key, int value) {
       int index=getIndex(key);
       if(data[index]==null){
           data[index]=new ListNode(-1,-1);
       }
        ListNode prev = find(data[index], key);
        if (prev.next == null){
            //不存在值为key的元素
            prev.next = new ListNode(key, value);
        }else{
            //存在值为key的元素，就直接更新
            prev.next.val = value;
        }
    }

    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */
    public int get(int key) {
        int index=getIndex(key);
        if(data[index]==null){
            return -1;
        }
        ListNode prev=find(data[index],key);
        return prev.next==null?-1:prev.next.val;
    }

    /** Removes the mapping of the specified value key if this map contains a mapping for the key */
    public void remove(int key) {
        int index=getIndex(key);
        if(data[index]==null){
            return;
        }
        ListNode prev=find(data[index],key);
        if(prev.next==null){
            //不存在值为key的元素
            return;
        }
        //直接删除值为key的元素
        prev.next=prev.next.next;
    }

    private class ListNode {
        int key, val;
        ListNode next;

        ListNode(int key, int val) {
            this.key = key;
            this.val = val;
        }
    }
}
```

## 使用查找表的经典问题
### 1
[1 Two Sum](https://leetcode.com/problems/two-sum/description/)

* 问题描述：

给定一个整型数组nums。返回这个数组中的索引值i和j,
使得nums[i]+nums[j]等于一个给定的target值。两个索引不相等。

* 示例：

nums[2,7,11,15],target=9

返回[0,1]

* 解题：

1、确定问题：

**索引是从0开始还是从1开始**？从0开始

**没有解怎么办**？一定有解

**多个解怎么办**？保证有唯一解

2、解题思路：

查找表问题。将所有元素加入查找表，之后对于每一个元素a,查找target-a是否存在。

这里要用到HashMap<Intager,Integer>,键存储的是该元素的值，值存储的是该元素的下标，

有可能存在相同的元素，则键值相同，会发生值覆盖问题。

遍历nums的数组，

下标在[0,i)元素已经在查找表中，判断target-nums[i]，是否在查找表中：

如果存在，返回结果

如果不存在，将nums[i]加入查找表中

```java
public int[] twoSum(int[] nums, int target) {
    if(nums.length<=1){
        return null;
    }
    Map<Integer,Integer> map=new HashMap<>();
    //HashMap<Intager,Integer>,键存储的是该元素的值，值存储的是该元素的下标.
    for(int i=0;i<nums.length;i++){
        int v=target-nums[i];
        //在看查找表中查找是否有 target-nums[i]元素
        if(map.containsKey(v)){
            return new int[]{i,map.get(v)};
        }
        map.put(nums[i],i);
    }
    return null;
}
```
### 15
[15 3Sum](https://leetcode.com/problems/3sum/description/)

* 问题描述：

给定一个整型数组，寻找其中的所有不同的三元组(a,b,c),使得a+b+c=0;

* 示例：

nums=[-1,0,1,2,-1,-4]

结果为[[-1,0,1],[-1,-1,2]]

* 解题：

1、确定问题：

**不同的三元组**？三元组的元素互不相同

**如果有多个解，解的顺序**？顺序是任意的

**如果没有解**？一定有解

2、思路：
```java
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> ret=new ArrayList<>();
    if(nums.length<3){
        return ret;
    }
    Map<Integer,Integer> map=new HashMap<>();
    //HashMap<Intager,Integer>,键存储的是该元素的值，值存储的是该元素出现的次数
    for(int num:nums){
        int freq=map.get(num)==null?0:map.get(num);
        map.put(num,++freq);
    }
    Set<Integer> keySet=map.keySet();
    for(Integer num:keySet){
        //num 表示数组中的元素值
        //numCount为该元素出现的次数
        int numCount=map.get(num);

        //三个相同元素相加的情况
        if(numCount>=3){
             //num元素出现3次以上的，用该元素值相加和为0,只能是0了。
            if(num==0){
                ret.add(Arrays.asList(0,0,0));
            }
        }

        //两个相同元素和另外一个元素相加的情况
        if(numCount>=2){
            //num元素出现次数为2,用该元素之和另外一个元素和为0，
            int target=0-2*num;
            if(map.containsKey(target) && target!=0){
                //如果map中存在target值，则说明（num，num,target）是一组解
                //target如果是0,那么就变成了（0,0,0）三个相同元素之和了
                ret.add(Arrays.asList(num,num,target));
            }
        }

        //三个不同元素相加的情况
        for(Integer num2:keySet){
            int num3=0-num-num2;
            //假设 [num,num2,num3]是有序的并且num<num2<num3
            if(num>=num2 || num2>=num3 || map.get(num3)==null){
                continue;
            }
            ret.add(Arrays.asList(num,num2,num3));
        }
    }
    return ret;
}
```
### 18
[18 4Sum](https://leetcode.com/problems/4sum/description/)

* 问题描述：

给定一个整型数组，寻找其中的所有不同的四元组（a,b,c,d）,是的a+b+c+d等于一个给定的数字target.

* 示例：

nums=[1,0,-1,0,-2,2],target=0

结果为：[[-1,0,0,1],[-2,-1,1,2],[-2,0,0,2]]

* 解题：
```java
//思路：对撞指针思路
public List<List<Integer>> fourSum(int[] nums, int target) {
    List<List<Integer>> ret=new ArrayList<>();
    if(nums.length<=3){
        return ret;
    }
    Arrays.sort(nums);

    //从第一个元素开始遍历，一直到倒数第四个元素
    for(int i=0;i<nums.length-3;i++){
        //相邻元素相等，就直接看下一个元素
        if(i>0 && nums[i-1]==nums[i]){
            continue;
        }
        if(nums[i]*4>target) {
            // Too Big!!太大了，后续只能更大(因为数组是按照升序排列的)，可以直接结束循环
            break;
        }
        if(nums[i]+3*nums[nums.length-1]<target){
            ////Too Small！太小了，当前值不需要再算，可以继续循环尝试后面的值。
            continue;
        }
        for(int j=i+1;j<nums.length-2;j++){
            //相邻元素相等，就直接看下一个元素
            if(j>i+1&&nums[j]==nums[j-1]){
                continue;
            }
            if(nums[j]*3>target-nums[i]){
                //Too Big！ 注意此时不能结束i的循环，因为j是移动的 当j移动到后面的时候继续i循环也sum可能变小
                break;
            }
            if(nums[j]+2*nums[nums.length-1]<target-nums[i]){
                continue;// Too Small
            }

            int begin=j+1;
            int end=nums.length-1;
            while(begin<end){
                int sum=nums[i]+nums[j]+nums[begin]+nums[end];
                if(sum==target){
                    ret.add(Arrays.asList(nums[i],nums[j],nums[begin],nums[end]));
                    //处理相邻的重复元素,否则存在重复的解
                    while(begin<end && nums[begin]==nums[begin+1]){begin++;}
                    while(begin<end && nums[end]==nums[end-1]){end--;}
                    begin++;
                    end--;
                }else if(sum<target){
                    begin++;
                }else{
                    end--;
                }
            }
        }
    }
    return ret;
}
```
### 16
[16 3Sum Closest](https://leetcode.com/problems/3sum-closest/description/)

* 问题描述：

给定一个整型数组，寻找其中的三个元素 a,b,c,使得a+b+c的值最接近另外一个给定的数字target

* 示例：

nums=[-1,2,1,-4],target=1

结果为2(-1+2+1=2)

* 解题：

```java
//时间复杂度 O(n^2)
public int threeSumClosest(int[] nums, int target) {
    if(nums.length<3){
        return 0;
    }
    Arrays.sort(nums);
    int ret=0;
    int closet=Integer.MAX_VALUE;
    for(int i=0;i<nums.length-2;i++){
       int begin=i+1;
       int end=nums.length-1;
       while(begin<end){
           int tmp=nums[i]+nums[begin]+nums[end];
           if(Math.abs(tmp-target)<closet){
               //不断更新最接近的数值
               closet=Math.abs(tmp-target);
               ret=tmp;
           }
           if(tmp<target){
               begin++;
           }else if(tmp>target){
               end--;
           }else{
               //tmp==target当然就是最接近的了
               return target;
           }
       }
    }
    return ret;
}
```

## 灵活选择键值I
### 454
[454 4Sum II](https://leetcode.com/problems/4sum-ii/description/)

* 问题：

给出四个整型数组A,B，C,D，寻找有多少i,j,k,l的组合，使得
A[i]+B[j]+C[k]=D[l]==0.其中A,B,C，D均含有相同的元素个数N,且0<=N<=500。

* 解题：
```java
//将C+D的每一种可能放入查找表中：时间复杂度:O（n^2）
public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {
    Map<Integer,Integer> map=new HashMap<>();
    //<C[i]+D[j],出现的次数>
    for(int i=0;i<C.length;i++){
        for(int j=0;j<D.length;j++){
            int freq=map.get(C[i]+D[j])==null?0:map.get(C[i]+D[j]);
            map.put(C[i]+D[j],++freq);
        }
    }

    int res=0;
    //记录解的个数
    for(int i=0;i<A.length;i++){
        for(int j=0;j<B.length;j++){
            if(map.containsKey(-A[i]-B[j])){
                res+=map.get(-A[i]-B[j]);
            }
        }
    }
    return res;
}
```
时间复杂度：O(n^2)

空间复杂度：O(n^2)

### 49
[49 Group Anagrams](https://leetcode.com/problems/group-anagrams/description/)
```java
public List<List<String>> groupAnagrams(String[] strs) {
    Map<String,List<String>> map=new HashMap<>();
    //map存储的是<字符串的字母按照字母排序后得到的字符串,与之相应的anagram>
    for(int i=0;i<strs.length;i++){
        char[] chs=strs[i].toCharArray();
        Arrays.sort(chs);
        //所有anagram排序后，得到的字符串是一致的
        String sortStr=new String(chs);
        if(!map.containsKey(sortStr)){
            map.put(sortStr,new ArrayList<>());
        }
        map.get(sortStr).add(strs[i]);
    }
    return new ArrayList<>(map.values());
}
```

### 697 
[697 Degree of an Array](https://leetcode.com/problems/degree-of-an-array/description/)
```java
//pos记录元素的起始位置和终止位置（中间可能包含其他元素）
//比如 [2,2,1,2]中2元素的起始位置是0，终止位置是3（这中间包括了1元素）
private class Pos{
    int start;
    int end;
    public Pos(int start,int end){
        this.start=start;
        this.end=end;
    }

    @Override
    public String toString() {
        StringBuilder builder=new StringBuilder();
        builder.append("[").append(start+","+end).append("]");
        return builder.toString();
    }
}

public int findShortestSubArray(int[] nums) {
    if(nums.length<=1){
        return nums.length;
    }
    //记录元素及其出现的频率
    Map<Integer,Integer> freq=new HashMap<>();
    //记录该元素的起始位置和终止位置
    Map<Integer,Pos> pos=new HashMap<>();
    for(int i=0;i<nums.length;i++){
        int num=nums[i];
        if(freq.get(num)==null){
            freq.put(num,0);
            pos.put(num,new Pos(i,i));
        }else{
            freq.put(num,freq.get(num)+1);
            pos.get(num).end=i;
        }
    }

    //获取该数组的度
    int degree=0;
    for(Integer key:freq.keySet()){
        Integer f=freq.get(key);
        degree=Math.max(degree,f);
    }

    //看看度为degree的元素，哪个是结果
    int len=nums.length;
    for(Integer num:freq.keySet()){
        if(freq.get(num)==degree){
            len=Math.min(len,pos.get(num).end-pos.get(num).start+1);
        }
    }
    return len;
}
```

## 灵活选择键值II
### 447
[447 Number of Boomerangs](https://leetcode.com/problems/number-of-boomerangs/description/)

* 问题：

给出一个平面上的n个点，寻找存在多少个由这些点构成的三元组(i.j.k),
使得i,j两点的距离等于i，k两点的距离，其中n最多为500，且所有点坐标的范围在
[-10000,10000]之间。

* 解题：

1、确定问题：

**n<=500,时间复杂度**? 最差要有O(n^2)

**坐标范围[-10000,10000]之间能不能使用int类型**？ (-10000)^2+10000^2=2*10^8 在int范围内，
可以使用int类型

2、思路：

(i,j)和(i,k)的距离相等，则i是一个“枢纽”，对于每个点i,遍历其余点到i的距离。
准备一个查找表其他点到点i的距离：

如果到点i的距离相等的点<2,返回0

如果到点i的距离相等的点>=2（假设为n）,则有n*(n-1)种可能

<div align="center"><img src="https://gitee.com/duhouan/ImagePro/raw/master/java-notes/leetcode/find//find_1.png" width="600"/></div>

```java
public int numberOfBoomerangs(int[][] points) {
    //points 表示 [[0,0],[1,0],[2,0]],实际上就是 points[points.length][2]
    int res=0;
    //存储返回的结果
    for(int i=0;i<points.length;i++){
        Map<Integer,Integer> map=new HashMap<Integer,Integer>();
        //距离到i距离相同的点出现的次数
        for(int j=0;j<points.length;j++){
            if(j!=i){
                int freq=map.get(distance(points,i,j))==null?0:map.get(distance(points,i,j));
                map.put(distance(points,i,j),++freq);
            }
        }

        //遍历map,如果到点i的距离相等的点>=2（假设为n）,则有n*(n-1)种可能
        Set<Integer> set=map.keySet();
        for(Integer key:set){
            int value=map.get(key);
            if(value>=2){
                res+=value*(value-1);
            }
        }
    }
    return res;
}

//计算点i到点j的距离
public int distance(int[][] points,int i,int j){
    return (points[i][0]-points[j][0])*(points[i][0]-points[j][0])+
            (points[i][1]-points[j][1])*(points[i][1]-points[j][1]);
}
```
### 149
[149 Max Points on a Line](https://leetcode.com/problems/max-points-on-a-line/description/)

* 解题：

1、确定问题：

**如果存在相同点如何处理**？包含在计算中

2、思路：
给定任意多个点，找到在一条线上最多的点。
都知道两点构成一条直线，如果要求另一点也在这条直线上，那个这个点跟其中任何一个点的斜率必须要求一致。
针对每个点，可以找到其他点跟它组成的直线中点最多的,跟它组成的直线，斜率一样的一定在一条直线上。
我们考虑对每个点，建一条斜率与点数的对应的查找表

```java
public int maxPoints(Point[] points) {
    if(points==null || points.length==0){
        return 0;
    }
    if(points.length==1){
        return 1;
    }
    int ret=0;
    for(int i=0;i<points.length;i++){
        Map<Double,Integer> map=new HashMap<Double, Integer>();
        //map存储的是斜率与点出现的频率
        int same=1;
        //记录出现相同的点的个数
        for(int j=0;j<points.length;j++){
            if(i==j){
                continue;
            }
            //先看看是否有相同点
            if(isSamePoint(points[i],points[j])){
                same++;
                continue;
            }else{
                double slope=getSlope(points[i],points[j]);
                int freq=map.getOrDefault(slope,0)+1;
                map.put(slope,freq);
            }
        }
        if(map.size()==0){
            //只有相同点的极端情况
            ret=Math.max(ret,same);
        }else {
            for (Double slope : map.keySet()) {
                ret = Math.max(ret,map.get(slope)+same);
                if(slope>=0.9999999894638303){
                    ret-=1;
                }
            }
        }
    }
    return ret;
}
```
### 719


## 查找表和滑动窗口
### 219
[219 Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/description/)

* 问题：

给出一个整型数组nums和一个整数k,是否存在索引i和j,使得nums[i]==nums[j]并且i和j之间的差不超过k
 
* 示例：

nums = [1,2,3,1], k = 3

返回的结果:true

* 解题：

滑动窗口和查找表的综合使用，维持一个长度为k的滑动窗口，只要在该窗口查找是否有两个相等的元素。
窗口不断向前滑行。
```java
public boolean containsNearbyDuplicate(int[] nums, int k) {
    Set<Integer> set=new HashSet<>();
    //set存储的是滑动窗口中的元素
    for(int i=0;i<nums.length;i++){
        if(set.contains(nums[i])){
            return true;
        }
        set.add(nums[i]);
        //维持滑动窗口的大小为k
        if(set.size()==k+1){
            set.remove(nums[i-k]);
        }
    }
    return false;
}
```
时间复杂度：O(n)

空间复杂度：O(k)

### 217
[217 Contains Duplicate](https://leetcode.com/problems/contains-duplicate/description/)
```java
public boolean containsDuplicate(int[] nums) {
    Set<Integer> set=new HashSet<>();
    for(int i=0;i<nums.length;i++){
        if(set.contains(nums[i])){
            return true;
        }
        set.add(nums[i]);
    }
    return false;
}
```
时间复杂度：O(n)

空间复杂度：O(n)

## 二分搜索树底层实现的顺序性
### 220
[220 Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii/description/)

* 问题：
给出一个整型数组nums,是否存在索引i和j，使得nums[i]和nums[j]之间的差别不超多给定的整数t,

且i和j之间的差别不超过给定的整数k.

* 解题：

1、确定问题

**t可以小于0**？t可以小于0的，但是这里两数字差绝对值，要求t>=0

**k可以小于1**？k可以小于1，但是k<1就没有意义了。

关键是判断条件： 对于|nums[i]-nums[j]|<=t ,有nums[i]-t<=nums[j]<=nums[i]+t,t>=0
```java
public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
    if (k < 1 || t < 0)
        return false;
    SortedSet<Long> set=new TreeSet<>();
    //采用Long类型是为了防止整型溢出
    for(int i=0;i<nums.length;i++){
        //判断是否存在元素在 [nums[i]-t,nums[i]+t]之间
        Set<Long> s = set.subSet((long) nums[i] - t, (long) nums[i] + t + 1);
        //左闭右开，所以 nums[i]+t要+1
        //s存储[nums[i]-t,nums[i]+t]之间的元素
        if(!s.isEmpty()){
            return true;
        }
        set.add((long)nums[i]);
        if(set.size()==k+1){
            set.remove((long)nums[i-k]);
        }
    }
    return false;
}
```

### 729
[729 My Calendar I](https://leetcode.com/problems/my-calendar-i/description/)
```java
class MyCalendar {
    private List<Event> data;

    //检查这两个事件是否会重叠
    private boolean overlapped(Event e1,Event e2){
        return e1.start<e2.end && e1.end>e2.start;
    }

    public MyCalendar() {
        data=new ArrayList<>();
    }

    public boolean book(int start, int end) {
        Event newEvent=new Event(start,end);
        for(Event e:data){
            if(overlapped(e,newEvent)){
                return false;
            }
        }
        data.add(newEvent);
        return true;
    }

    private class Event{
        int start;
        int end;
        public Event(int start,int end){
            this.start=start;
            this.end=end;
        }
    }
}
```

### 731
[731 My Calendar II](https://leetcode.com/problems/my-calendar-ii/description/)
```java
class MyCalendarTwo {
    //直接记录区间
    Set<Event> calendar;
    
    //记录交叉的区间
    Set<Event> overlap;

    //检查这两个事件是否会重叠
    private boolean overlapped(Event e1, Event e2){
        return e1.start<e2.end && e1.end>e2.start;
    }

    public MyCalendarTwo() {
        calendar=new HashSet<>();
        overlap=new HashSet<>();
    }

    public boolean book(int start, int end) {
        Event newEvent=new Event(start,end);
        for(Event schedule:overlap){
            if(overlapped(schedule,newEvent)){
                return false;
            }
        }
        for(Event schedule:calendar){
            if(overlapped(schedule,newEvent)){
                overlap.add(new Event(Math.max(schedule.start,newEvent.start),Math.min(schedule.end,newEvent.end)));
            }
        }
        calendar.add(newEvent);
        return true;
    }

    private class Event{
        int start;
        int end;
        public Event(int start,int end){
            this.start=start;
            this.end=end;
        }
    }
}
```

### 855
[855 Exam Room](https://leetcode.com/problems/exam-room/description/)
```java
/**
 * 思路：
 * 题目要求明确，新建一个容量为N的考试房间，每次向里放人或者向外赶人，
 * 放人要求必须放在离其他人最远的位置，这个数据结构的放置范围在1∼10~9，
 * 不能使用数组，可以使用List代替数组，存储学生座位位置
 * 每次先检查0和最后一个位置是否坐了人，毕竟这两个位置只需要考虑一边，
 * 而其它位置的的选取则必然是在两个座位中间选取。
 * maxDis变量记录最长的距离，
 * idx记录上一个同学的位置，遍历即可
 * 删除根据下标进行删除。
 */
class ExamRoom {
    //存储学生座位位置
    private List<Integer> seats;
    //座位总数
    private int n;

    public ExamRoom(int N) {
       seats=new ArrayList<>();
       n=N;
    }

    public int seat() {
        //一开始没有人，第一个人直接坐到0位置
        if(seats.isEmpty()){
            seats.add(0);
            return 0;
        }
        //res就是要坐的位置
        int res = 0;
        //idx记录上一个同学的位置
        int idx = 0;
        int maxDis = 0;
        //0位置有人
        if(seats.contains(0)){
            maxDis=seats.get(0)-0;
            res=0;
        }
        for(int i=0;i<seats.size();i++){
            int dis=(seats.get(i)-idx)/2;
            if(dis>maxDis){
                maxDis=dis;
                res=(seats.get(i)+idx)/2;
            }
            idx=seats.get(i);
        }
        //最后一个位置是否还有人
        if(seats.contains(n-1)){
            int dis = n - 1 - seats.get(seats.size()-1);
            if (dis > maxDis) {
                maxDis=dis;
                res = n - 1;
            }
        }
        return res;
    }

    public void leave(int p) {
        for(int i=0;i<seats.size();i++){
            if(seats.get(i)==p){
                seats.remove(i);
            }
        }
    }
}
```
 
 
## 查找表的更多问题
### 811 
[811 Subdomain Visit Count](https://leetcode.com/problems/subdomain-visit-count/description/)
```java
public List<String> subdomainVisits(String[] cpdomains) {
    List<String> res=new ArrayList<>();
    if(cpdomains==null || cpdomains.length==0){
        return res;
    }

    //存储域名和数字
    Map<String,Integer> map=new HashMap<>();
    for(String cpdomain:cpdomains){
        String[] arr=cpdomain.split(" ");
        if(arr!=null){
            Integer num=Integer.parseInt(arr[0]);
            String domain=arr[1];
            map.put(domain,num+ map.getOrDefault(domain,0));
            while(true){
                int index=domain.indexOf(".");
                if(index<0){
                    break;
                }
                domain=domain.substring(index+1);
                map.put(domain,num+map.getOrDefault(domain,0));
            }
        }
    }
    for(String domain: map.keySet()){
        Integer num=map.get(domain);
        res.add(num+" "+domain);
    }
    return res;
}
```

### 819
[819 Most Common Word](https://leetcode.com/problems/most-common-word/description/)
```java
public String mostCommonWord(String paragraph, String[] banned) {
    //存储--禁止单词，方便检查paragraph中是否有“禁止单词”
    Set<String> bannedSet=new HashSet<>();
    for(String word:banned){
        bannedSet.add(word);
    }

    //存储单词和单词出现的频率
    Map<String,Integer> map=new HashMap<>();
    int start=getFirstLetter(paragraph,0);
    for(int i=start+1;i<=paragraph.length();){
        if(i==paragraph.length() || !Character.isLetter(paragraph.charAt(i))){
            //!Character.isLetter(paragraph.charAt(i) i位置不是字符就要截取
            String word=paragraph.substring(start,i);
            //将该单词中字母都转化为小写
            word=word.toLowerCase();
            if(!bannedSet.contains(word)){ //word不能是“禁止单词”
                int freq=map.getOrDefault(word,0);
                map.put(word,++freq);
            }
            start=getFirstLetter(paragraph,i+1);
            i=start+1;
        }else{
            i++;
        }
    }
    String res="";
    int maxFreq=0;
    for(String word:map.keySet()){
        if(map.get(word)>maxFreq){
            res=word;
            maxFreq=map.get(word);
        }
    }
    return res;
}

//获取字符串s的首字母的下标
private int getFirstLetter(String s,int start){
    for(int i=start;i<s.length();i++){
        if(Character.isLetter(s.charAt(i))){
            return i;
        }
    }
    //没有字母，则返回该字符串长度
    return s.length();
}
```

## 869
[869 Reordered Power of 2](https://leetcode.com/problems/reordered-power-of-2/description/)

* 解题思路一：
 ```java
/**
 * 思路一：
 * 暴力解法-->列举N重排序后的所有可能结果
 */
public boolean reorderedPowerOf2(int N) {
    char[] digits=(N+"").toCharArray();
    return generatePermutation(digits,0);
}

private boolean generatePermutation(char[] digits, int index){
    if(index==digits.length){
        return isPowerOf2(new String(digits));
    }
    for(int i=index;i<digits.length;i++){
        if(index>0 || (digits[i]-'0')>0){
            swap(digits,index,i);
            if(generatePermutation(digits,index+1)){
                return true;
            }
            swap(digits,index,i);
        }
    }
    return false;
}

//判定一个数字是否是2的幂
private boolean isPowerOf2(String digits) {
    int N=Integer.parseInt(digits);
    if((N & (N-1))==0){
        return true;
    }
    return false;
}

private void swap(char[] digits,int i,int j){
    char tmp=digits[i];
    digits[i]=digits[j];
    digits[j]=tmp;
}
```
* 解题思路二：
```java
/**
 * 思路二：
 * 先把int范围下的2的N幂算出来，然后一个一个验证给出的数能不能拼成。
 */
public boolean reorderedPowerOf2(int N) {
   int[] cnt=count(N);
   for(int i=0;i<31;i++){
       if(Arrays.equals(cnt,count(1<<i))){
           return true;
       }
   }
   return false;
}

private int[] count(int num){
    //1 <= N <= 10^9,N的最大数字是10^9
    int[] res=new int[10];
    while(num>0){
        int index=num%10;
        res[index]++;
        num/=10;
    }
    return res;
}
```

### 884 
[884 Uncommon Words from Two Sentences](https://leetcode.com/problems/uncommon-words-from-two-sentences/description/)
```java
public String[] uncommonFromSentences(String A, String B) {
    StringBuilder res=new StringBuilder();
    Map<String,Integer> map=new HashMap<>();
    if(A.length()!=0){
        String[] arr=A.split(" ");
        for(String s:arr){
            map.put(s,map.getOrDefault(s,0)+1);
        }
    }
    if(B.length()!=0){
        String[] arr=B.split(" ");
        for(String s:arr){
            map.put(s,map.getOrDefault(s,0)+1);
        }
    }
    for(String s:map.keySet()){
        Integer num=map.get(s);
        if(num==1){
            res.append(s).append(" ");
        }
    }
    //res为空，说明没有解，则直接返回空字符串数组
    if(res.length()==0){
        return new String[]{};
    }
    return res.toString().split(" ");
}
```
### 888 
[888 Fair Candy Swap](https://leetcode.com/problems/fair-candy-swap/description/)
```java
public int[] fairCandySwap(int[] A, int[] B) {
    int[] res = new int[2];
    Set<Integer> setA=new HashSet<>();
    Set<Integer> setB=new HashSet<>();
    int sumA=0;
    int sumB=0;
    for(int i=0;i<A.length;i++){
        setA.add(A[i]);
        sumA+=A[i];
    }
    for(int i=0;i<B.length;i++){
        setB.add(B[i]);
        sumB+=B[i];
    }
    int sum=(sumA+sumB)/2;
    for(int a:A){
        if(setB.contains(sum-(sumA-a))){
            //(sumA-a) 表示数组中除去a元素的元素和
            //sum是交换后，数组和
            //sum-(sumA-a)就是要交换的元素值
            res[0]=a;
            res[1]=sum-(sumA-a);
            break;
        }
    }
    return res;
}
```

### 890 
[890 Find and Replace Pattern](https://leetcode.com/problems/find-and-replace-pattern/description/)
```java
public List<String> findAndReplacePattern(String[] words, String pattern) {
    List<String> res=new ArrayList<>();
    for(String word:words){
        if(ok(word,pattern)){
            res.add(word);
        }
    }
    return res;
}

/* private boolean ok(String word,String pattern){
    if(word.length()!=pattern.length()){
        return false;
    }
    //用于存储映射关系的Map
    Map<Character, Character> map = new HashMap<>();
    for(int i=0;i<word.length();i++){
        char p=pattern.charAt(i);
        char w=word.charAt(i);
        if(map.containsKey(p)){
            //pattern中的字母已经被映射，这时候只要判断对应的word中是否有对应的字母
            char value=map.get(p);
            if(w!=value){
                return false;
            }
        }else{
            //判断单词中的字母是否被映射，防止模式多个字母都映射单词中的同一个字母
            if(map.containsValue(w)){
               return false;
            }else {
                map.put(p, w);
            }
        }
    }
    return true;
}*/

private boolean ok(String word, String pattern) {
    if(word.length()!=pattern.length()){
        return false;
    }

    //记录word中字符和pattern中字符的映射关系
    Map<Character, Character> wordMap = new HashMap();
    //记录pattern中字符和word中字符的映射关系
    Map<Character, Character> patternMap = new HashMap();
    //如果匹配，则 wordMap、patternMap中映射关系都要全部满足

    for(int i = 0; i < word.length(); i ++) {
        char c = word.charAt(i);
        char p = pattern.charAt(i);

        if(wordMap.containsKey(c)) {
            if(p != wordMap.get(c)) {
                return false;
            }
        } else {
            wordMap.put(c, p);
        }
        if(patternMap.containsKey(p)) {
            if(c != patternMap.get(p)) {
                return false;
            }
        } else {
            patternMap.put(p, c);
        }
    }
    return true;
}
```

### 893
[893 Groups of Special-Equivalent Strings](https://leetcode.com/problems/groups-of-special-equivalent-strings/description/)
```java
public int numSpecialEquivGroups(String[] A) {
    Set<String> set=new HashSet<>();
    for(String s:A){
        set.add(getHashCode(s));
    }
    return set.size();
}

private String getHashCode(String s){
     //0-25统计s的偶数下标的字符频率
     //26-52统计s的奇数下标的字符频率
    int[] freq=new int[52];
    for(int i=0;i<s.length();i++){
        freq[(i%2)*26+(s.charAt(i)-'a')]++;
    }
    return getStr(freq);
}

private String getStr(int[] freq) {
    StringBuilder builder=new StringBuilder();
    for(int e:freq){
        builder.append(e).append(" ");
    }
    return builder.toString();
}
```