# [第七章 动态规划基础](#动态规划基础)

| 章节 | 典型题目 | 相关题目 | 更多扩展练习 | 难题推荐 |
| :---: | :---: | :---: | :---: | :---: |
| [7-1 什么是动态规划](#什么是动态规划) | [无] | [无] | | |
| [7-2 第一个动态规划问题 Climbing Stairs](#第一个动态规划问题) | [70](#70) | [120](#120) [64*](#64) | [118](#118) | |
| [7-3 发现重叠子问题 Integer Break](#发现重叠子问题) | [343](#343) | [279](#279) [91](#91) [62](#62) [63](#63) | | |
| [7-4 状态的定义和状态转移 House Robber](#状态的定义和状态转移) | [198](#198) | [213](#213) [337](#337) | [740](#740) | |
| [7-5 0-1背包问题](#0_1背包问题) | [无] | [无] | | |
| [7-6 0-1背包问题的优化和变种](#0_1背包问题的优化和变种) | [无] | [无] | | 115 |
| [7-7 面试中的0-1背包问题 Partition Equal Subset Sum](#面试中的0_1背包问题) | [416](#416) | [322](#322) [377](#377) [474](#474) [139](#139) [494](#494) | [518](#518) | 805 |
| [7-8 LIS问题 Longest Increasing Subsequence](#LIS问题) | [300](#300) | [376](#376) | [673*](#673) | |
| [7-9 LCS，最短路，求动态规划的具体解以及更多](#LCS问题_求LCS具体解) | [无] | [无] | [583](#583) [712*](#712) [718](#718) | |
| [补充1：股票交易问题](#股票交易问题) | [无] | [无] | [309](#309) [714](#714) [121](#121) [123](#123) [188](#188) | |
| [补充2：更多动态规划问题](#更多动态规划问题) | [无] | [无] | [790] [873](#873) [96](#96) | [600](#600)  [788](#788) [871] [879] [887] [902] [903] [741] |
| [补充3：最小编辑距离算法](#最小编辑距离算法) | [无] | [无] |  [无] | [无] |

# 动态规划基础
## 什么是动态规划
### 管窥动态规划：从斐波那契数列谈起

```java
public int fib(int n){
    if(n==0){
        return 0;
    }
    if(n==1){
        return 1;
    }
    return fib(n-1)+fib(n-2);
}
```
粗略地测试算法执行时间：
```java
@Test
public void test(){
    //int n=10; //time:2.0921E-5s
    //int n=20; //time:0.009386947s
    //int n=30; //time:0.049079365s
    //int n=40;//time:1.157836107s
    int n=42; //time:2.560889825s
    //可以看到时间是成指数级增长的
    long startTime=System.nanoTime();
    int res=fib(n);
    long endTime=System.nanoTime();
    System.out.println("fib("+n+")="+res);
    System.out.println("time:"+(endTime-startTime)/1000000000.0+"s");
}
```
40->42 时间就增长了接近一倍，这是非常可怕的，原因：存在大量的重复计算（途中粉色部分）：

<div align="center"><img src="pics//dp//dp_1.png" width="600"/></div>

<div align="center"><img src="pics//dp//dp_2.png" width="600"/></div>

使用记忆化搜索进行优化：
```java
//改进上面的方法：采用记忆化搜索
private int[] memo;

public int fib2(int n){
    if(n==0){
        return 0;
    }
    if(n==1){
        return 1;
    }
    if(memo[n]==-1){
        //memo[n]==-1说明是首次计算，下一次遇到该值就直接返回了
        memo[n]=fib2(n-1)+fib2(n-2);
    }
    return memo[n];
}
```
```java
@Test
public void test2(){
    //int n=10; //time:7.106E-6s
    //int n=20; //time:8.289E-6s
    //int n=30; //time:2.0132E-5s
    //int n=40;//time:1.2632E-5s
    int n=42; //time:1.1843E-5s
    //为memo分配空间，并且初始值设为-1,因为斐波那契数列中是没有-1的
    memo=new int[n+1];
    for(int i=0;i<n+1;i++){
        memo[i]=-1;
    }
    long startTime=System.nanoTime();
    int res=fib2(n);
    long endTime=System.nanoTime();
    System.out.println("fib2("+n+")="+res);
    System.out.println("time:"+(endTime-startTime)/1000000000.0+"s");
}
```

### 动态规划的解释
将原问题拆解成若干子问题，同时保存子问题的答案，使得每个子问题只求解一次，最终获得原问题的答案。

<div align="center"><img src="pics//dp//dp_4.png" width="600"/></div>

## 第一个动态规划问题
### 70 
[70 Climbing Stairs](https://leetcode.com/problems/climbing-stairs/description/)

* 问题：

有一个楼梯，总共有n阶台阶。每一次，可以上一个台阶，也可以上两个台阶。
问：爬上这样的一个楼梯，一共有多少种不同的方法？

* 示例：

n=3,可以爬上这个楼梯的方法有:[1,1,1],[1,2],[2,1]

答案为3

* 解题：

解法一：递归

分析（自顶向下）：

<div align="center"><img src="pics//dp//dp_4.png" width="600"/></div>

```java
private int calcWays(int n){
    if(n==1){
        return 1;
    }
    if(n==2){
        return 2;
    }
    return calcWays(n-1)+calcWays(n-2);
}

public int climbStairs(int n) {
    return calcWays(n);
}
```
存在大量重复计算
<div align="center"><img src="pics//dp//dp_5.png" width="600"/></div>

<div align="center"><img src="pics//dp//dp_6.png" width="600"/></div>

超出了LeetCode的时间限制，使用记忆化搜索进行改进:

```java
private int[] memo;
private int calcWays(int n){
    if(n==1){
        return 1;
    }
    if(n==2){
        return 2;
    }
    if(memo[n]==-1){
        memo[n]=calcWays(n-1)+calcWays(n-2);
    }
    return memo[n];
}

public int climbStairs(int n) {
    memo=new int[n+1];
    for(int i=0;i<n+1;i++){
        memo[i]=-1;
    }
    return calcWays(n);
}
```

解法二：动态规划
```java
public int climbStairs(int n) {
    int[] memo=new int[n+1];
    if(n<=1){
        return 1;
    }
    memo[1]=1;
    //注意：这里 小标是2,说明数组长度至少为3,n至少为2，所以前面要对n进行判断
    memo[2]=2;
    for(int i=3;i<=n;i++){
        memo[i]=memo[i-1]+memo[i-2];
    }
    return memo[n];
}
```

### 120 
[120 Triangle](https://leetcode.com/problems/triangle/description/)

给定一个三角形，找出从顶到底的最小路径和，每一步可以从上一行移动到下一行相邻的数字

状态：f(i,j)考虑从第0行到i行j列的最小路径和。

状态转移方程：

f(0,0)=tri[0][0]

f(i,0)=tri[i][0]+f(i-1,0) (i>0)

f(i,i)=tri[i][i]+f(i-1,i-1)(i>=1)

f(i,j)=tri[i][j]+min{f(i-1,j-1),f(i-1,j)}

```java
//空间复杂度O(n^2),不符合题目要求，要进行优化
public int minimumTotal(List<List<Integer>> triangle) {
    int n = triangle.size();

    int[][] memo=new int[n][];
    for(int i=0;i<n;i++){
        memo[i]=new int[i+1];
    }
    memo[0][0]=triangle.get(0).get(0);
    for(int i = 1 ; i < n ; i ++){
        memo[i][0]=triangle.get(i).get(0)+memo[i-1][0];
        memo[i][i]=triangle.get(i).get(i)+memo[i-1][i-1];
        for(int j=1;j<i;j++){
            memo[i][j]=triangle.get(i).get(j)+Math.min(memo[i-1][j-1],memo[i-1][j]);
        }
    }
    Arrays.sort(memo[n-1]);
    return memo[n-1][0];
}
```
```java
//观察状态转移方程，每次i都依赖于(i-1)
public int minimumTotal(List<List<Integer>> triangle) {
    int n = triangle.size();
    int[] memo=new int[n];

    for(int i = n-1; i >=0 ; i --){
        for(int j = 0 ; j <= i ; j ++){
           if(i==n-1) {
               memo[j]=triangle.get(i).get(j);
           }else {
               memo[j]=triangle.get(i).get(j)+Math.min(memo[j],memo[j+1]);
           }
        }
    }
    return memo[0];
}
```
```java
public int minimumTotal(List<List<Integer>> triangle) {
    int n = triangle.size();
    for(int i = 1 ; i < n ; i ++){
        triangle.get(i).set(0,triangle.get(i).get(0)+triangle.get(i-1).get(0));
        triangle.get(i).set(i,triangle.get(i).get(i)+triangle.get(i-1).get(i-1));
        for(int j = 1 ; j < i ; j ++)
            triangle.get(i).set(j,triangle.get(i).get(j)+Math.min(triangle.get(i-1).get(j-1),triangle.get(i-1).get(j)));
    }
    Collections.sort(triangle.get(n-1));
    return triangle.get(n-1).get(0);
}
```

### 64
[64 Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/description/)
```java
/**
 * 思路：
 * 对于其中一点grid[i][j](0<=i<m，0<=j<n)，（m,n只有是grid[][]的行数和列数）只有两种方法到达该点，所以到这点
 * 最短路径只能是上一点或者左边的点的最短路径加上当前点的值，即d(grid[i][j])=min{d(grid[i][j-1]),d(grid[i-1][j])} + grid[i][j]。
 * 但是对于第0行或者第0列来说都只有一种情况到达该点，所以需要直接**由前一个点的最短路径加上当前点值即可**。
 * 遍历整个网格，便可以得到最终值。
 */
public int minPathSum(int[][] grid) {
    int m=grid.length;
    if(m==0){
        return 0;
    }
    int n=grid[0].length;

    int[][] memo=new int[m][n];

    memo[0][0]=grid[0][0];

    //第0行或者第0列来说都只有一种情况到达该点
    //针对0行,涉及到上一行，所以j从1开始
    for(int j=1;j<n;j++){
        memo[0][j]=grid[0][j]+memo[0][j-1];
    }

    //针对0列
    for(int i=1;i<m;i++){
        memo[i][0]=grid[i][0]+memo[i-1][0];
    }

    for(int i=1;i<m;i++){
        for(int j=1;j<n;j++){
            memo[i][j]=grid[i][j]+Math.min(memo[i-1][j],memo[i][j-1]);
        }
    }
    return memo[m-1][n-1];
}
//时间复杂度 O(m*n)
//空间复杂度 O(m*n)
```

优化空间复杂度
```java
public int minPathSum(int[][] grid) {
    int m=grid.length;
    if(m==1){
        return getSum(grid[0]);
    }
    int n=grid[0].length;

    int[][] memo=new int[2][n];

    memo[0][0]=grid[0][0];

    //针对0行,涉及到上一行，所以j从1开始
    for(int j=1;j<n;j++){
        memo[0][j]=grid[0][j]+memo[0][j-1];
    }
    //与前面的memo[0][0]=grid[0][0]，一起组成第0列
    memo[1][0]=grid[1][0]+memo[0][0];

    for(int i=1;i<m;i++){
        memo[i%2][0]=grid[i][0]+memo[(i-1)%2][0];
        for(int j=1;j<n;j++){
            memo[i%2][j]=grid[i][j]+Math.min(memo[(i-1)%2][j],memo[i%2][j-1]);
        }
    }
    return memo[(m-1)%2][n-1];
}

int getSum(int[] nums){
    int sum=0;
    for(int i=0;i<nums.length;i++){
        sum+=nums[i];
    }
    return sum;
}
```

### 118
[118 Pascal's Triangle](https://leetcode.com/problems/pascals-triangle/description/)
```java
public List<List<Integer>> generate(int numRows) {
    List<List<Integer>> res=new ArrayList<>();
    if(numRows==0) {
        return res;
    }
    for(int i=0;i<numRows;i++){
        List<Integer> list = new ArrayList<>();
        for (int j = 0; j < i+1; j++) {
            if(j==0 || j==i){
                list.add(1);
            }else{
                list.add(res.get(i - 1).get(j - 1) + res.get(i - 1).get(j));
            }
        }
        res.add(list);
    }
    return res;
}
```

## 发现重叠子问题

最优子结构

通过求解子问题的最优解，可以获得原问题的最优解。

<div align="center"><img src="pics//dp//dp_8.png" width="600"/></div>

### 343 
[343 Integer Break](https://leetcode.com/problems/integer-break/description/)

* 问题：

给定一个正数n，可以将其等额城多个数字的和，要让这些数字的乘积最大，
求分割的方法（至少要凤城两个数）。算法返回这个最大的乘积。

* 示例：

Input: 10

Output: 36

Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.

* 解题：

解法一：自顶向下递归+记忆化搜索

<div align="center"><img src="pics//dp//dp_7.png" width="600"/></div>

```java
//自顶向上递归
private int max3(int a,int b,int c){
    int tmp=(a>b)?a:b;
    return c>tmp?c:tmp;
}

private int breakInteger(int n){
    if(n==1){
        return 1;
    }
    int res=-1;
    for(int i=1;i<n;i++){
        //i*(n-i)
        res=max3(res,i*(n-i),i*breakInteger(n-i));
    }
    return res;
}

public int integerBreak(int n) {
    return breakInteger(n);
}
```

```java
//使用记忆化搜索，进行优化
private int max3(int a,int b,int c){
    int tmp=(a>b)?a:b;
    return c>tmp?c:tmp;
}

private int[] memo;
private int breakInteger(int n){
    if(n==1){
        return 1;
    }
    if(memo[n]!=-1){
        return memo[n];
    }
    int res=-1;
    for(int i=1;i<n;i++){
        //i*(n-i)
        res=max3(res,i*(n-i),i*breakInteger(n-i));
    }
    memo[n]=res;
    return res;
}

public int integerBreak(int n) {
    memo=new int[n+1];
    for(int i=0;i<n+1;i++){
        memo[i]=-1;
    }
    return breakInteger(n);
}
```

解法二：动态规划(自底向上解决问题)
```java
public int integerBreak(int n) {
    assert n>=2;
    int[] memo=new int[n+1];
    memo[1]=1;
    //2--n个数字都能进行拆分
    for(int i=2;i<=n;i++){
        for(int j=1;j<i;j++){
            // j*(i-j)
            memo[i]=max3(memo[i],j*(i-j),j*memo[i-j]);
        }
    }
    return memo[n];
}
```

### 279 
[279 Perfect Squares](https://leetcode.com/problems/perfect-squares/description/)
```java
private int[] memo;
private int findNumSquare(int n){
    if(n==0){
        return 0;
    }
    if(memo[n]!=-1){
        return memo[n];
    }
    int min=Integer.MAX_VALUE;
    for(int j=1;n-j*j>=0;j++){
        min=Math.min(min,1+findNumSquare(n-j*j));
    }
    memo[n]=min;
    return memo[n];
}

public int numSquares(int n) {
    memo=new int[n+1];
    for(int i=0;i<n+1;i++){
        memo[i]=-1;
    }
    return findNumSquare(n);
}
```

```java
//动态规划
public int numSquares(int n) {
    if(n==1){
        return 1;
    }
    int[] memo=new int[n+1];
    for(int i=0;i<memo.length;i++){
        memo[i]=Integer.MAX_VALUE;
    }
    memo[0]=0;
    //1--->n个数进行遍历
    for(int i=1;i<=n;i++){
        for(int j=1;i-j*j>=0;j++){
            memo[i]=Math.min(memo[i],1+memo[i-j*j]);
        }
    }
    return memo[n];
}
```
### 91
[91 Decode Ways](https://leetcode.com/problems/decode-ways/description/)
```java
/**
 * 思路：
 * 使用动态规划，当前点的编码方法有两种情况：
 * （1）当前数在0-9之间，这样可以从前一个数到达；
 * （2）如果当前数和前一个数能编码，即在1-26之间，那么从当前数的前两个数可以到达当前数。
 */
public int numDecodings(String s) {
    int n=s.length();
    if(n==0){
        return 0;
    }
    //memo[i]记录从开始到i-1的有多少种方式
    int[] memo=new int[n+1];
    memo[0]=1;
    //如果第一位上是0，那么无法转码，返回0；
    if(s.charAt(0)>'0'){
        memo[1]=1;
    }

    for(int i=2;i<=n;i++) {
        if (s.charAt(i - 1) >= '1') {
            memo[i] = memo[i - 1];
        }
        int num = Integer.parseInt(s.substring(i - 2, i));
        if (num <= 26 && s.charAt(i - 2) != '0') {
            memo[i] = memo[i] + memo[i - 2];
        }
    }
    return memo[n];
}
```

### 62 
[62 Unique Paths](https://leetcode.com/problems/unique-paths/description/)

* 解题：

状态函数 memo[i][j]表示从[0,0]到点[i,j]的独特路径数。

初始状态:

<div align="center"><img src="pics//dp//dp_20.png" width="400"/></div>

当前这个状态只和左边和上边的格子有关系:

<div align="center"><img src="pics//dp//dp_21.png" width="400"/></div>

依次求解：

<div align="center"><img src="pics//dp//dp_22.png" width="400"/></div>

由此推导出状态转移方程：

memo[i][j] = memo[i-1][j] + memo[i][j-1]

```java
//注意这里是 n行m列
public int uniquePaths(int m, int n) {
    int[][] memo=new int[n][m];

    //初始化第0行数据
    memo[0][0]=1;
    for(int j=1;j<m;j++){
        memo[0][j]=memo[0][j-1];
    }

    //初始化第0列数据
    for(int i=1;i<n;i++){
        memo[i][0]=memo[i-1][0];
    }

    for(int i=1;i<n;i++){
        for(int j=1;j<m;j++){
            memo[i][j]=memo[i-1][j]+memo[i][j-1];
        }
    }
    return memo[n-1][m-1];
}
```

### 63
[63 Unique Paths II](https://leetcode.com/problems/unique-paths-ii/description/)
```java
public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    int m=obstacleGrid.length;
    if(m==0){
        return 0;
    }
    int n=obstacleGrid[0].length;
    if(n==0 || obstacleGrid[0][0]==1){
        return 0;
    }
    int[][] memo=new int[m][n];

    //这里已经排除了obstacleGrid[0][0]==1的情况
    memo[0][0]=1;
    //初始化第0行
    for(int j=1;j<n;j++){
        memo[0][j]=(obstacleGrid[0][j]==1)?0:memo[0][j-1];
    }

    //初始化第0列
    for(int i=1;i<m;i++){
        memo[i][0]=(obstacleGrid[i][0]==1)?0:memo[i-1][0];
    }

    for(int i=1;i<m;i++){
        for(int j=1;j<n;j++){
            memo[i][j]=(obstacleGrid[i][j]==1)?0:(memo[i-1][j]+memo[i][j-1]);
        }
    }
    return memo[m-1][n-1];
}
```

## 状态的定义和状态转移
### 198
[198 House Robber](https://leetcode.com/problems/house-robber/description/)
* 问题：

你是一个专业小偷，打算细节一条街的所有房子。
每一个房子都有不同价值的宝物，但是，如果你选择偷窃连续得我两栋房子，
会出发报警系统。编程求出你最多可以偷窃多少宝物？

* 示例：

[3,4,1,2],则返回6[3,(4),1,(2)]

[4,3,1,2],则返回6[(4),3,1,(2)]

* 解题：

<div align="center"><img src="pics//dp//dp_9.png" width="600"/></div>

其中对**状态**的定义：
**考虑**偷取[x..n-1]范围里的房子(函数f的定义)

根据状态的定义，决定**状态的转移**：

f(0)=max{ v(0)+f(2), v(1)+f(3),v(2)+f(4),...
    v(n-3)+f(n-1),v(n-2),v(n-1)}
    }
    
**状态转移方程**

f(0)表示考虑偷取[0...n-1]范围里的房子总价值
v(0)表示0号房子的价值

解法一：递归+记忆化搜索
```java
private int[] memo1;

//考虑抢劫nums[index...nums.length-1]者个范围内的所有房子
private int tryRob(int[] nums,int index){
    if(index>=nums.length){
        return 0;
    }
    if(memo1[index]!=-1){
        return memo1[index];
    }
    int res=-1;
    for(int i=index;i< nums.length;i++){
        res=Math.max(res,nums[i]+tryRob(nums,i+2));
    }
    memo1[index]=res;
    return res;
}

public int rob(int[] nums) {
    int n=nums.length;
    //房子的编号在[0...nums.length-1]，所以memo长度是nums.length即可
    memo1=new int[n];
    for(int i=0;i<n;i++){
        memo1[i]=-1;
    }
    return tryRob(nums,0);
}
```

解法二：
```java
//使用动态规划，先求出最优子结构
public int rob(int[] nums) {
    int n= nums.length;
    if(n==0){
        return 0;
    }
    // memo[i]表示抢劫[i...n-1]的最大收益
    int[] memo=new int[n];
    for(int i=0;i<n;i++){
        memo[i]=-1;
    }

    /**
     * 状态转移方程：
     * f(0)=max{ v(0)+f(2), v(1)+f(3),v(2)+f(4),...，v(n-3)+f(n-1),v(n-2),v(n-1)}
     */
    memo[n-1]=nums[n-1]; //注意这里n>=1
    for(int i=n-2;i>=0;i--){
        // 抢劫[i...n]中的房子
        for(int j=i;j<n;j++){
            //nums[j] 编号为j的房子下标
            //memo[j+2]抢劫 [j+2...n-1]的最大收益
            memo[i]=Math.max(memo[i],nums[j]+(j+2<n? memo[j+2]:0));
        }
    }
    return memo[0];
}
```

换一种思路：

其中对**状态**的定义：
**考虑**偷取[0..x]范围里的房子(函数f的定义)

根据状态的定义，决定**状态的转移**：

f(n-1)=max{ v(n-1)+f(n-3), v(n-2)+f(n-4),...,v(3)+f(1),v(2),v(1)}

```java
public int rob(int[] nums) {
    int n= nums.length;
    if(n==0){
        return 0;
    }
    // memo[i]表示抢劫[0...i]的最大收益
    int[] memo=new int[n];
    for(int i=0;i<n;i++){
        memo[i]=-1;
    }

    /**
     * 状态转移方程：
     * f(n-1)=max{ v(n-1)+f(n-3), v(n-2)+f(n-4),...,v(3)+f(1),v(2),v(1)}
     */
    memo[0]=nums[0]; //注意这里n>=1
    for(int i=1;i<n;i++){
        // 抢劫[0...i]中的房子
        for(int j=i;j>=0;j--){
            //nums[j] 编号为j的房子下标
            //memo[j+2]抢劫 [j+2...n-1]的最大收益
            memo[i]=Math.max(memo[i],nums[j]+(j-2>=0? memo[j-2]:0));
        }
    }
    return memo[n-1];
}
```

### 213 
[213 House Robber II](https://leetcode.com/problems/house-robber-ii/description/)
```java
//偷在[start,end]之间的房子
private int rob(int[] nums,int start,int end){
    //偷取start位置
    int preMax=nums[start];

    //偷取start+1位置
    int curMax=Math.max(preMax,nums[start+1]);
    //curMax表示偷取 start或者(start+1)的最大值

    for(int i=start+2;i<=end;i++){
        int tmp=curMax;
        //偷取编号为i的房子
        curMax=Math.max(curMax,nums[i]+preMax);
        preMax=tmp;
    }
    return curMax;
}

public int rob(int[] nums) {
    int n = nums.length;
    if (n == 0) {
        return 0;
    }
    if(n==1){
        return nums[0];
    }
    if(n==2){
        return Math.max(nums[0],nums[1]);
    }
    return Math.max(rob(nums,0,nums.length-2),rob(nums,1,nums.length-1));
}
```

### 337 
[337 House Robber III](https://leetcode.com/problems/house-robber-iii/description/)

解法一：
```java
public int rob(TreeNode root) {
    return rob(root,true);
}

private int rob(TreeNode root,boolean include){
    if(root==null){
        return 0;
    }
    int res=rob(root.left,true)+rob(root.right,true);
    if(include){
        res=Math.max(res,root.val+rob(root.left,false)+rob(root.right,false));
    }
    return res;
}
```

解法二：
```java
public int rob(TreeNode root) {
    int[] res=tryRob(root);
    return Math.max(res[0],res[1]);
}

private int[] tryRob(TreeNode root){
    if(root==null){
        return new int[]{0,0};
    }
    int[] resultL=tryRob(root.left);
    int[] resultR=tryRob(root.right);
    int[] res=new int[2];
    //小标0 表示不抢劫该根节点的最大价值，小标1表示抢劫该根节点的最大价值

    //不抢劫该根节点
    res[0]=resultL[1]+resultR[1];
    res[1]=Math.max(res[0],root.val+resultL[0]+resultR[0]);
    return res;
}
```

### 740
[740 Delete and Earn](https://leetcode.com/problems/delete-and-earn/description/)
```java
/**
 对于值为i的元素，要么抛弃它，要么选择它
 选择它意味着抛弃i-1和i+1：
 dp[i] = 所有i的和 + dp[i+2]
 而抛弃它意味着
 dp[i] = dp[i+1]
 */
public int deleteAndEarn(int[] nums) {
    int len = nums.length;

    //数组中元素范围在[1, 10000].
    int[] num=new int[10001];
    int[] dp=new int[10003];
    //num[i]统计值为nums数组中值为nums[i]的元素之和
    for (int i = 0; i < len; i++) {
        num[nums[i]] += nums[i];
    }
    for (int i = 10000; i >= 0; i--) {
        dp[i] = Math.max(num[i]+dp[i+2], dp[i+1]);
    }
    return dp[0];
}
```


## 0_1背包问题
* 问题：

有一个背包，它的容量为C.现在有n中不同的物品，编号为0...n-1，其中每一件物品的重量为w(i),价值为v(i)。
问可以向这个背包中盛放哪些物品，使得在不超过背包容量的基础上，包中物品的总价值最大。

* 解题：

贪心策略？
<div align="center"><img src="pics//dp//dp_10.png" width="600"/></div>

<div align="center"><img src="pics//dp//dp_11.png" width="600"/></div>

**递归+记忆化搜索**：

F(n,C) **考虑**将n个物品放进容量为C的背包，使得价值最大

则对于F(i,C)有两种情况：

(1)不将i物品放入，F(i,C)=F(i-1,C)

(2)将i物品放入，F(i,C)=v(i)+F(i-1,C-w(i))

F(i,C)=max{F(i-1,C),v(i)+F(i-1,C-w(i))}

```java
public class Knapsack01 {
    private int[][] memeo;
    //用[0...index]的物品，填充容积为C的背包的最大价值
    private int bestValue(int[] w, int[] v, int index, int C) {
        if(index<0 || C<=0){
            return 0;
        }
        if(memeo[index][C]!=-1){
            return memeo[index][C];
        }
        //不放入index物品
        int res=bestValue(w,v,index-1,C);
        //先判断背包能否放入index物品
        if(C>=w[index]){
            res=Math.max(res,v[index]+bestValue(w,v,index-1,C-w[index]));
        }
        memeo[index][C]=res;
        return res;
    }

    public int knapsack01(int[] w,int[] v,int C){
        int n=w.length;
        memeo=new int[n][C+1];
        for(int i=0;i<n;i++){
            for(int j=0;j<C+1;j++){
                memeo[i][j]=-1;
            }
        }
        return bestValue(w,v,n-1,C);
    }

    @Test
    public void test(){
        int[] w={1,2,3};
        int[] v={6,10,12};
        System.out.println(knapsack01(w,v,5));
    }
}
```

**动态规划**：

通过示例分析

<div align="center"><img src="pics//dp//dp_12.png" width="600"/></div>

```java
public class Knapsack01 {
    public int knapsack01(int[] w, int[] v, int C) {
        int n=w.length;
        int[][] memo=new int[n][C+1];
        for(int i=0;i<n;i++){
            for(int j=0;j<C+1;j++){
                memo[i][j]=-1;
            }
        }

        //将标号为0的物品，装入背包中
        for(int j=0;j<C+1;j++){
            //标号为0的物品，放入容量为j的背包中
            memo[0][j]=(j>w[0]?v[0]:0);
        }

        //memo[i][C]存储[0...i]填充容积为C的背包的最大价值
        for(int i=1;i<n;i++){
            for(int j=0;j<C+1;j++){
                //不放入编号为i的物品
                memo[i][j]=memo[i-1][j];
                if(j>=w[i]){
                    memo[i][j]=Math.max(memo[i][j],v[i]+memo[i-1][j-w[i]]);
                }
            }
        }
        return memo[n-1][C];
    }


    @Test
    public void test(){
        int[] w={1,2,3};
        int[] v={6,10,12};
        System.out.println(knapsack01(w,v,5));
    }
}
```

## 0_1背包问题的优化和变种
### 优化
上面的0-1背包问题

时间复杂度O(n*C)

空间复杂度O(n*C)

这里针对空间复杂度进行优化：

方案一：

F(i,C)=max{F(i-1,C),v(i)+F(i-1,C-w(i))}，
第i行元素，之依赖于(i-1)行元素，那么空间复杂度就变成了O(2*C)=O(C)

初始化memo二维数组，只有0行和1行

<div align="center"><img src="pics//dp//dp_13.png" width="600"/></div>

当更新到2行时，就覆盖原来的0行

<div align="center"><img src="pics//dp//dp_14.png" width="600"/></div>

当更新到3行时，就覆盖原来的1行

<div align="center"><img src="pics//dp//dp_15.png" width="600"/></div>
.
我们可以发现，覆盖0行的是偶数行，覆盖1行的是奇数行
<div align="center"><img src="pics//dp//dp_16.png" width="600"/></div>

```java
//0-1背包问题的优化
public int knapsack01(int[] w, int[] v, int C) {
    int n=w.length;
    if(n==0 || C==0){
        return 0;
    }
    int[][] memo=new int[2][C+1];
    for(int i=0;i<2;i++){
        for(int j=0;j<C+1;j++){
            memo[i][j]=-1;
        }
    }

    for(int j=0;j<C+1;j++){
        memo[0][j]=j>w[0]?w[0]:0;
    }
    //时间复杂度O(n*C)
    for(int i=1;i<n;i++){
        for(int j=0;j<C+1;j++){
            memo[i%2][j]=memo[(i-1)%2][j];
            if(j>=w[i]){
                memo[i%2][j]=Math.max(memo[i%2][j],v[i]+memo[(i-1)%2][j-w[i]]);
            }
        }
    }
    return memo[(n-1)%2][C];
}
```

方案二：

观察下图，可以看出F(i,C)
实际上就是 F(i,C)的值与 v(i)+F(i,C-w(i))去最大值的问题

<div align="center"><img src="pics//dp//dp_17.png" width="600"/></div>

从后向前遍历

i=0时初始情况
<div align="center"><img src="pics//dp//dp_18.png" width="600"/></div>

i=1时
<div align="center"><img src="pics//dp//dp_19.png" width="600"/></div>

```java
public int knapsack01(int[] w, int[] v, int C) {
    int n=w.length;
    if(n==0 || C==0){
        return 0;
    }
    int[] memo=new int[C+1];
    for(int i=0;i<C+1;i++){
        memo[i]=-1;
    }
    for(int j=0;j<C+1;j++){
        memo[j]=j>=w[0]?w[0]:0;
    }
    for(int i=1;i<n;i++){
        for(int j=C;j>=w[i];j--){
            memo[j]=Math.max(memo[j],v[i]+memo[j-w[i]]);
        }
    }
    return memo[C];
}
```
### 变种

## 面试中的0_1背包问题
### 416
[416 Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/description/)

* 问题：

给定一个非空数组，其中素有的数字都是正整数。问是否可以将这个数组的元素分成两部分，
使得没部分的数字和相等？

* 实例：

[1,5,11,5]，可以分成[1,5,5]和[11]两部分

[1,2,3,5]，无法分成元素和相等的两部分

* 解题：

将该问题转化为0-1背包问题，在n个物品中，选出几个物品，填满容量为sum/2背包。

F(n,C)考虑将n个物品填满容量为C的背包。

F(i,C)=F(i-1,C) || F(i-1,C-w(i))

时间复杂度：O(n*sum/2)=O(n*sum)

(1)递归+记忆化搜索：

```java
//使用记忆化搜索
//这里使用int类型：
//-1：表示未计算 0：表示不可以填充 1：表示可以填充
private int[][] memo;

//使用[0...index]之间的物品，是否可以填充容量为C的背包
private boolean tryPartition(int[] nums, int index, int C) {
    //填满背包
    if(C==0){
        return true;
    }
    //C<0 说明背包放不下了
    if(C<0 || index<0){
        return false;
    }
    if(memo[index][C]!=-1){
        return memo[index][C]==1;
    }
    memo[index][C]=(tryPartition(nums,index-1,C) || tryPartition(nums,index-1,C-nums[index]))==true?1:0;
    return memo[index][C]==1;
}

public boolean canPartition(int[] nums) {
    int n=nums.length;
    if(n==0){
        return false;
    }
    int sum=0;
    for(int i=0;i<nums.length;i++){
        sum+=nums[i];
    }
    if(sum%2==1){
        return false;
    }
    memo=new int[n][sum/2+1];
    for(int i=0;i<n;i++){
        for(int j=0;j<sum/2+1;j++){
            memo[i][j]=-1;
        }
    }
    return tryPartition(nums,nums.length-1,sum/2);
}
```

(2)动态规划：

```java
public boolean canPartition(int[] nums) {
    int n=nums.length;
    int sum=0;
    for(int i=0;i<n;i++){
        sum+=nums[i];
    }
    if(sum%2==1){
        return false;
    }
    int C=sum/2;
    boolean[] memo=new boolean[C+1];
    for(int j=0;j<C+1;j++){
        //因为要刚好装满，尝试放编号为0的物品
        memo[j]=(j==nums[0]);
    }
    for(int i=1;i<n;i++){
        for(int j=C;j>=nums[i];j--){
            memo[j]=(memo[j] || memo[j-nums[i]]);
        }
    }
    return memo[C];
}
```

### 322
[322 Coin Change](https://leetcode.com/problems/coin-change/description/)

* 解法一：
```java
private int[] dp;
private int max_amount;

private int tryChange(int[] coins,int amount){
    if(amount==0){
        return 0;
    }
    if(dp[amount]!=-1){
        return dp[amount];
    }
    int res=max_amount;
    for(int coin:coins){
        if(amount - coin >= 0){
            res=Math.min(res,1+tryChange(coins,amount-coin));   
        }
    }
    dp[amount]=res;
    return dp[amount];
}

public int coinChange(int[] coins, int amount) {
    max_amount=amount+1;
    dp=new int[amount+1];
    for(int i=0;i<amount+1;i++){
        dp[i]=-1;
    }
    int res=tryChange(coins,amount);
    return (res==max_amount)?-1:res;
}
```

* 解法二：
```java
/**
 * 思路：
 * 数组memo[i]存储凑齐钱数i时所需硬币的最少数量
 * memo[i]=min{memo[i],memo[i-coin]+1}
 */
public int coinChange(int[] coins, int amount) {
    int C=amount+1;
    int[] memo=new int[C];
    memo[0]=0;
    //初始化该数组，要求初始值大于amount即可
    for(int i=1;i<C;i++){
        memo[i]=amount+1;
    }
    for(int coin:coins){
        for(int i=coin;i<C;i++){
            memo[i]=Math.min(memo[i],memo[i-coin]+1);
        }
    }
    return memo[amount]==amount+1?-1:memo[amount];
}
```
### 377 
[377 Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/description/)

* 解法一：
```java
private int[] memo;
private int findCombination(int[] nums,int target){
    if(target==0){
        return 1;
    }
    if(memo[target]!=-1){
        return memo[target];
    }
    int res=0;
    for(int i=0;i<nums.length;i++){
        if(target>=nums[i]){
            res+=findCombination(nums,target-nums[i]);
        }
    }
    memo[target]=res;
    return memo[target];
}

public int combinationSum4(int[] nums, int target) {
    int n=nums.length;
    if(n==0){
        return 0;
    }
    memo=new int[target+1];
    for(int i=0;i<target+1;i++){
        memo[i]=-1;
    }
    findCombination(nums,target);
    return memo[target];
}
```
* 解法二：
```java
public int combinationSum4(int[] nums, int target) {
    int n=nums.length;
    if(n==0){
        return 0;
    }
    //memo[i]表示数组中表示存储的是目标i所得的组合数。
    int[] memo=new int[target+1];
    memo[0]=1;

    for(int i=1;i<target+1;i++){
        for(int j=0;j<n;j++){
            if(i>=nums[j]){
                memo[i]=memo[i]+memo[i-nums[j]];
            }
        }
    }
    return memo[target];
}
```

### 474 
[474 Ones and Zeroes](https://leetcode.com/problems/ones-and-zeroes/description/)
```java
public int findMaxForm(String[] strs, int m, int n) {
    int[][] memo=new int[m+1][n+1];
    for(String str:strs){
        //统计str中'0'和'1'的个数
        int cnt0=0;
        int cnt1=0;
        for(Character c:str.toCharArray()){
            if(c=='0'){
                cnt0++;
            }else{
                cnt1++;
            }
        }
        for(int i=m;i>=cnt0;i--){
            for(int j=n;j>=cnt1;j--){
                memo[i][j]=Math.max(memo[i][j],memo[i-cnt0][j-cnt1]+1);
            }
        }
    }
    return memo[m][n];
}
```

### 139 
[139 Word Break](https://leetcode.com/problems/word-break/description/)
```java
/**
 * 思路：
 * dp[i]表示字符串s[0...i)能否拆分成符合要求的子字符串。
 * 我们可以看出，如果s[j...i)在给定的字符串组中，且dp[j]为True（即字符串s[0...j)能够拆分成符合要求的子字符串），那么此时dp[i]也就为True了。
 * 状态转移方程：
 * dp[0]=true;
 * dp[i]=dp[j] && DICT（s[j...i)）,0<=j<i
 */
public boolean wordBreak(String s, List<String> wordDict) {
    int n=s.length();
    boolean[] memo=new boolean[n+1];
    memo[0]=true;
    for (int i = 1; i <= n; i++){
        for (int j = 0; j < i; j++) {
            // 注意substring是前闭后开
            String tmp = s.substring(j, i);
            if (memo[j] && wordDict.contains(tmp)) {
                memo[i] = true;
                break;
            }
        }
    }
    return memo[n];
}
```

### 494 
[494 Target Sum](https://leetcode.com/problems/target-sum/description/)
```java
/**
 * 思路：
 * 假设原数组为nums，目标值为S，那么原数组必然可以分成两个部分：
 * 一个部分里面的元素前面需要加-，即运算的时候应该是做减法，另一个部分里面的元素前面需要加+，即运算的时候应该是做加法；
 * 我们将做加法部分的数组记为P，做减法部分的数组记为N，
 * 举个例子，例如S = {1，2，3，4，5}，S = 3，那么有一种可以是1-2+3-4+5，即P = {1，3，5}，N = {2，4}；
 * 于是我们可以知道：S = sum(P) - sum(N)；
 * 那么sum(P) + sum(N) + sum(P) - sum(N) = sum(nums) + S = 2sum(P)；
 * 那么sum(P) = [S + sum(nums)] / 2； []表示向下取整
 * 也就是在nums数组中选择值为 (s+sum(nums))/2的动态规划问题。可以参考416题
 */
public int findTargetSumWays(int[] nums, int S) {
    int n=nums.length;
    int sum=0;
    for(int i=0;i<n;i++){
        sum+=nums[i];
    }
    if (sum < S || (sum + S) % 2 != 0) {
        return 0;
    }
    int C=(S+sum)/2;
    int[] memo=new int[C+1];
    memo[0]=1;
    for(int i=0;i<n;i++){
        for(int j=C;j>=nums[i];j--){
            memo[j]=memo[j]+ memo[j-nums[i]];
        }
    }
    return memo[C];
}
```

### 518
[518 Coin Change 2](https://leetcode.com/problems/coin-change-2/description/)
```java
/**
 * 思路：
 * memo[i]存储钱数为i时的组合数量
 * 则状态转移方程：memo[i]=memo[i]+memo[i-coin]
 */
public int change(int amount, int[] coins) {
    int C=amount+1;

    //memo[i]存储钱数为i时的组合数量
    int[] memo=new int[C];
    //钱数为0时,只有一种组合
    memo[0]=1;
    for(int coin:coins){
        for(int j=coin;j<C;j++){
            memo[j]=memo[j]+memo[j-coin];
        }
    }
    return memo[amount];
}
```

## LIS问题
### 300 
[300 Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/description/)

* 问题：

给定一个整数序列，求其中的最长上升子序列的长度。

* 示例：

[10,9,2,5,3,7,101,18],其最长上升子序列的长度。

返回4，最长上升子序列为[2,3,7,101]和[2,3,7.18]。

* 解题：

确定问题：

**什么是子序列**？不包括该序列本身

**什么是上升**？后一个元素大于前一个元素

**一个序列可能有多个最长上升子序列**？但是最长长度是唯一的。

思路：

LIS(i):表示以第i个数字为结尾的最长上升子序列的长度，
即在[0...i]范围内,
选择数字nums[i]可以获得的最长子序列的长度。

LIS(i)=max(j<i){1+LCS(j) if(nums[i]>nums[j])}

操作实例：

<div align="center"><img src="pics//dp//dp_23.png" width="600"/></div>

<div align="center"><img src="pics//dp//dp_24.png" width="600"/></div>

```java
public int lengthOfLIS(int[] nums) {
    int n=nums.length;
    if(n==0){
        return 0;
    }
    int[] memo=new int[n];
    for(int i=0;i<n;i++){
        memo[i]=1;
    }

    for(int i=1;i<n;i++){
        for(int j=0;j<i;j++){
            if(nums[i]>nums[j]){
                memo[i]=Math.max(memo[i],1+memo[j]);
            }
        }
    }

    int res=1;
    for(int i=0;i<n;i++){
        res=Math.max(res,memo[i]);
    }
    return res;
}
```
### 376
[376 Wiggle Subsequence](https://leetcode.com/problems/wiggle-subsequence/description/)
```java
//用up[i]和down[i]分别记录到第i个元素为止 以上升沿和下降沿[结束] 的最长“摆动”序列长度
public int wiggleMaxLength(int[] nums) {
    int n=nums.length;
    if(n==0 || n==1){
        return n;
    }
    int[] up=new int[n];
    int[] down=new int[n];
    up[0]=1;
    down[0]=1;
    for(int i=1;i<n;i++){
        if(nums[i]>nums[i-1]){ //下降
            down[i]=up[i-1]+1;
            up[i]=up[i-1];
        }else if(nums[i]<nums[i-1]){
            up[i]=down[i-1]+1;
            down[i]=down[i-1];
        }else{
            up[i]=up[i-1];
            down[i]=down[i-1];
        }
    }
    return Math.max(up[n-1],down[n-1]);
}
```
优化：
```java
public int wiggleMaxLength(int[] nums) {
    int n=nums.length;
    if(n==0 || n==1){
        return n;
    }
    int up=1;
    int down=1;
    for(int i=1;i<n;i++){
        if(nums[i]>nums[i-1]){
            down=up+1;
        }
        if(nums[i]<nums[i-1]){
            up=down+1;
        }
    }
    return Math.max(down,up);
}
```

### 673
[673 Number of Longest Increasing Subsequence](https://leetcode.com/problems/number-of-longest-increasing-subsequence/description/)
```java
/**
 * 思路：
 * LIS问题的变种：
 * LIS(i):表示以第i个数字为结尾的最长上升子序列的长度， 即在[0...i]范围内, 选择数字nums[i]可以获得的最长子序列的长度。
 * LIS(i)=max(j<i){1+LCS(j) if(nums[i]>nums[j])}
 * 这里要求统计 最长上升子序列的数目
 *
 * count[i]在[0...i]范围内的最长子序列的个数
 */
public int findNumberOfLIS(int[] nums) {
    int n=nums.length;
    if(n==0){
        return 0;
    }
    int[] memo=new int[n];
    int[] count=new int[n];
    int maxlen=1;
    for(int i=0;i<n;i++){
        memo[i]=1;
        count[i]=1;
    }
    for(int i=1;i<n;i++){
        for(int j=0;j<i;j++){
            if(nums[i]>nums[j]){
                if(memo[j]+1>memo[i]){
                    //说明这个长度的序列是新出现
                    memo[i]=1+memo[j];
                    count[i]=count[j];
                }else if(memo[j]+1==memo[i]){
                    count[i]+=count[j];
                }
            }
        }
        maxlen=Math.max(maxlen,memo[i]);
    }
    int res=0;
    for(int i=0;i<n;i++){
        if(memo[i]==maxlen){
            res+=count[i];
        }
    }
    return res;
}
```

## LCS问题_求LCS具体解
* 问题：

给出两个字符串S1和S2，求这两个字符串的最长公共子序列

* 示例：

s1=ABCD,s2=AEBD

最长公共子序列为[ABD]

* 解题：

状态：
LCS(m,n) S1[0...m]和S2[0...n]的最长公共子序列

状态转移方程：
当S1[m]==S2[n]时

LCS(m,n)=1+LCS(m-1,n-1);

当S1[m]!=S2[n]时

LCS(m,n)=max{LCS(m,n-1),LCS(m-1,n)}

```java
public int LCS(String s,String t){
    int m=s.length();
    int n=t.length();
    if(m==0 || n==0){
        return 0;
    }
    int[][] lcs=new int[m+1][n+1];
    for(int i=0;i<m+1;i++){
       for(int j=0;j<n+1;j++){
           lcs[i][j]=0;
       }
    }

    for(int i=1;i<m+1;i++){
        for(int j=1;j<n+1;j++){
            if(s.charAt(i-1)==t.charAt(j-1)){
                lcs[i][j]=1+lcs[i-1][j-1];
            }else{
                lcs[i][j]=Math.max(lcs[i-1][j],lcs[i][j-1]);
            }
        }
    }
    return lcs[m][n];
}
```
LCS的具体解：
```java
public class LCSSolution {
    //记录最长公共子序列的走向 'c'表示斜方向 ‘l’表示左方向 ‘u’表示上方向
    char[][] x;

    public int LCSLength(String s,String t,int m,int n){
        if(m==0 || n==0){
            return 0;
        }
        int[][] lcs=new int[m+1][n+1];
        x=new char[m+1][n+1];

        for(int i=0;i<m+1;i++){
           for(int j=0;j<n+1;j++){
               lcs[i][j]=0;
           }
        }

        for(int i=1;i<m+1;i++){
            for(int j=1;j<n+1;j++){
                //注意：这里的i是从1开始的 i=m时，实际上取到的是s的第m个元素
                if(s.charAt(i-1)==t.charAt(j-1)){
                    lcs[i][j]=1+lcs[i-1][j-1];
                    x[i][j]='c';
                }else if(lcs[i-1][j]>=lcs[i][j-1]){
                    lcs[i][j]=lcs[i-1][j];
                    x[i][j]='u';
                }else if(lcs[i-1][j]<lcs[i][j-1]){
                    lcs[i][j]=lcs[i][j-1];
                    x[i][j]='l';
                }
            }
        }
        return lcs[m][n];
    }

    public void printLCS(String s,int m,int n){
        if(m==0 || n==0){
            return;
        }
        if(x[m][n]=='c'){
            printLCS(s,m-1,n-1);
            System.out.print(s.charAt(m-1));
        }else if(x[m][n]=='u'){
            printLCS(s,m-1,n);
        }else if(x[m][n]=='l'){
            printLCS(s,m,n-1);
        }
    }

    @Test
    public void test(){
        String s="abcfbc";
        String t="abfcab";
        int m=s.length();
        int n=t.length();
        //String s="a";
        //String t="ab";
        LCSLength(s,t,m,n);
        printLCS(s,m,n);
    }
}
```

### 583
[583 Delete Operation for Two Strings](https://leetcode.com/problems/delete-operation-for-two-strings/description/)
```java
/**
 * 思路：
 * 要想获得最少步骤,只需要将这两个字符串通过一定步骤转化他们的最长公共子序列即可。
 * 由于1次步骤只能删除一个字符，则最少步骤就是
 * 两字符串长度和-2*最长公共子序列长度
 */
public int minDistance(String word1, String word2) {
    int m=word1.length();
    int n=word2.length();
    if(m==0){
        return n;
    }
    if(n==0){
        return m;
    }

    int[][] lcs=new int[m+1][n+1];
    for(int i=0;i<m+1;i++){
        for(int j=0;j<n+1;j++){
            lcs[i][j]=0;
        }
    }

    for(int i=1;i<m+1;i++){
        for(int j=1;j<n+1;j++){
            if(word1.charAt(i-1)==word2.charAt(j-1)){
                lcs[i][j]=1+lcs[i-1][j-1];
            }else{
                lcs[i][j]=Math.max(lcs[i-1][j],lcs[i][j-1]);
            }
        }
    }
    return (m+n-2*lcs[m][n]);
}
```

### 712 
[712 Minimum ASCII Delete Sum for Two Strings](https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/description/)

[参考补充4](#最小编辑距离算法)

```java
public int minimumDeleteSum(String s1, String s2) {
    int m=s1.length();
    int n=s2.length();
    int[][] res=new int[m+1][n+1];
    for(int i=1;i<=m;i++){
        res[i][0]=res[i-1][0]+s1.charAt(i-1);
    }
    for(int j=1;j<=n;j++){
       res[0][j]=res[0][j-1]+s2.charAt(j-1);
    }
    for(int i=1;i<=m;i++){
        for(int j=1;j<=n;j++){
            int dis=0;
            if(s1.charAt(i-1)!=s2.charAt(j-1)){
               dis=s1.charAt(i-1)+s2.charAt(j-1);
            }
            res[i][j]=min(res[i-1][j]+s1.charAt(i-1),res[i][j-1]+s2.charAt(j-1),res[i-1][j-1]+dis);
        }
    }
    return res[m][n];
}

private int min(int a,int b,int c){
    int tmp=(a<b)?a:b;
    return (tmp<c)?tmp:c;
}
```

### 718
[718 Maximum Length of Repeated Subarray](https://leetcode.com/problems/maximum-length-of-repeated-subarray/description/)
```java
/**
 * 思路：
 * lcs[i][j]表示数组
 * A[i-1]和B[j-1]结尾最长公共数组的长度
 * 
 * 则状态转移方程：
 * A[i-1]==B[j-1]时A[i-1]就加入到原来的最长公共数组中
 * 对此有 lcs[i][j]=lcs[i-1][j-1]+1
 */
public int findLength(int[] A, int[] B) {
    int m=A.length;
    int n=B.length;

    int[][] lcs=new int[m+1][n+1];
    int res=0;
    for(int i=1;i<=m;i++){
        for(int j=1;j<=n;j++){
            if(A[i-1]==B[j-1]){
                lcs[i][j]=lcs[i-1][j-1]+1;
                res=Math.max(lcs[i][j],res);
            }else{
                lcs[i][j]=0;
            }
        }
    }
    return res;
}
```

## 股票交易问题
### 309
[309 Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)
```java
/**
 * 思路：
 * 总共有三个状态：持有股票，卖掉股票，休息一天，后两种都可以归纳为未持有股票。
 * 状态有了，如何推断？
 * 未持有股票的状态:最大利润有两种可能：
 * (1)和昨天一样保持未持有；
 * (2)昨天持有股票今天卖掉。
 * unmemo[i]=max{unmemo[i-1],memo[i-1]+prices[i]}
 * 持有股票的状态，最大利润也有两种可能。(
 * (1)和昨天一样持有股票不卖；
 * (2)两天前未持有（休息一天）今天购买。
 * memo[i]=max{memo[i],unmemo[i-2]-prices[i]}
 */
public int maxProfit(int[] prices) {
    int n=prices.length;
    if (n == 0) {
        return 0;
    }
    int[] unmemo=new int[n];
    int[] memo=new int[n];
    unmemo[0]=0;
    //持有股票，也就是第一天必须要买入
    memo[0]=-prices[0];
    for(int i=1;i<n;i++){
        unmemo[i]=Math.max(unmemo[i-1],memo[i-1]+prices[i]);
        memo[i]=(i>2)?Math.max(memo[i-1],unmemo[i-2]-prices[i]):Math.max(memo[i-1],-prices[i]);
    }
    return unmemo[n-1];
}
```

### 714 
[714 Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)
```java
/**
* 思路：参考309题，注意这里是不需要休息一天的
*/
public int maxProfit(int[] prices, int fee) {
    int n=prices.length;
    if (n == 0) {
        return 0;
    }
    int[] unmemo=new int[n];
    int[] memo=new int[n];
    unmemo[0]=0;
    //持有股票，也就是第一天必须要买入
    memo[0]=-prices[0];
    /**
     *  未持有股票的状态:最大利润有两种可能：
     * (1)和昨天一样保持未持有；(2)昨天持有股票，今天卖掉。
     * unmemo[i]=max{unmemo[i-1],memo[i-1]+prices[i]}
     * 持有股票的状态，最大利润也有两种可能。
     * (1)和昨天一样持有股票不卖；(2)昨天未持有，今天购买。
     * memo[i]=max{memo[i-1],unmemo[i-1]-prices[i]}
     */
    for(int i=1;i<n;i++){
        //每次交易后，都是买入的时候，交手续费
        unmemo[i]=Math.max(unmemo[i-1],memo[i-1]+prices[i]-fee);
        memo[i]=Math.max(memo[i-1],unmemo[i-1]-prices[i]);
    }
    return unmemo[n-1];
}
```

### 121
[121 Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/)
```java
/**
 * 思路一:
 * 遍历数组，找出（后面元素-当前元素）最大值
 * （因为要求先买入，然后再卖出，所以要求后面元素减去前面元素）
 * 时间复杂度：O(N^2)
 */
public int maxProfit(int[] prices) {
    int n=prices.length;
    if(n==0 || n==1){
        return 0;
    }
    int res=0;
    for(int i=0;i<n;i++){
        for(int j=i+1;j<n;j++){
            res=Math.max(res,prices[j]-prices[i]);
        }
    }
    return res;
}
```

```java
/**
 * 思路二：
 * 使用minValue用来维护数组中的最小值，maxProfit来维护最大收益
 * 时间复杂度：O(N^2)
 */
public int maxProfit(int[] prices) {
    int n = prices.length;
    if (n == 0 || n == 1) {
        return 0;
    }
    //minValue用来维护数组中的最小值,也就是买入的股票
    int minValue=prices[0];
    //为什么要取maxProfict为0，因为有可能没有交易
    int maxProfit=0;
    for(int i=0;i<n;i++){
        minValue=Math.min(minValue,prices[i]);
        maxProfit=Math.max(maxProfit,prices[i]-minValue);
    }
    return maxProfit;
}
```

### 123 
[123 Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/)
```java
/**
 * 思路：
 * 参照121题
 */
public int maxProfit(int[] prices) {
    int n=prices.length;
    if(n==0 || n==1){
        return 0;
    }

    //从左向右遍历 maxBackward[i]表示从0到i天的最高买卖值
    //状态转移方程 maxForward[i]=max{maxForward[i-1],price[i]-minValue};
    //price[i]-minValue 表示第i天卖出股票的收益
    int[] maxBackward=new int[n];
    //从右向左遍历 maxForward[i]表示从i到(n-1)天的最高买卖值
    //maxValue-price[i] 表示第i天买入股票后的损失
    int[] maxForward=new int[n];

    maxBackward[0]=0;
    int minValue=prices[0];
    for(int i=1;i<n;i++){
        maxForward[i]=Math.max(maxForward[i-1],prices[i]-minValue);
        minValue=Math.min(minValue,prices[i]);
    }

    maxForward[n-1]=0;
    int maxValue=prices[n-1];
    for(int i=n-2;i>=0;i--){
        maxForward[i]=Math.max(maxForward[i+1],maxValue-prices[i]);
        maxValue=Math.max(maxValue,prices[i]);
    }

    //枚举断点,maxBackward[cnt-1]是可以取到maxBackward[0]的
    int ret=maxForward[0];
    for(int cut=1;cut<n;cut++){
        ret=Math.max(ret,maxBackward[cut-1]+maxForward[cut]);
    }
    return ret;
}
```
### 188
[188 Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/)
```java
public int maxProfit(int k, int[] prices) {
    int n=prices.length;
    if(k<=0){
        return 0;
    }
    if(k>=n/2){
        return maxProfit(prices);
    }
    //buy[i]表示完成第i笔交易的买入动作时的最大收益
    //sell[i]表示完成第i笔交易的卖出动作时的最大收益
    int[] buy=new int[k+1];
    int[] sell=new int[k+1];
    for(int i=0;i<k+1;i++){
        buy[i]=Integer.MIN_VALUE;
    }
    //buy[i] = max(buy[i], sell[i-1]-prices)[先要买入，然后才能卖出,i>=1]
    //第i次买入动作的最大收益=max{第i次买入动作是的最大收益,第(i-1)次卖出动作的最大收益-今天买入}
    //sell[i] = max(sell[i], buy[i]+prices)
    //第i次卖出动作的最大收益=max{第i次卖出动作的最大收益,第i次买入动作的最大收益+今天卖出}
    for(int price: prices){
        for(int i=k;i>=1;i--){
            buy[i]=Math.max(buy[i],sell[i-1]-price);
            sell[i]=Math.max(sell[i],buy[i]+price);
        }
    }
    return sell[k];
}

//k>=n/2，只要有利润，就可以买入
private int maxProfit(int[] prices){
    int n=prices.length;
    if(n<=1){
        return 0;
    }
    int res=0;
    for(int i=1;i<n;i++){
        if(prices[i]>prices[i-1]){
            res+=(prices[i]-prices[i-1]);
        }
    }
    return res;
}
```

## 更多动态规划问题
### 790 
[790 Domino and Tromino Tiling](https://leetcode.com/problems/domino-and-tromino-tiling/)

### 873 
[873 Length of Longest Fibonacci Subsequence](https://leetcode.com/problems/length-of-longest-fibonacci-subsequence/)
```java
/**
 * 思路：
 * 用一个二维数组memo来记录斐波那契序列的长度。
 * 二维数组中第i行第j列数字memo[i][j]的含义是以输入数组中A[i]结尾、并且前一个数字是A[j]的斐波那契序列的长度。
 * 如果存在一个数字k，满足A[k] + A[j] = A[i]，（符合斐波那契数列）
 * 那么memo[i][j] = memo[j][k] + 1。(A[i]就是A[j]的后面一个元素）
 * 如果不存在满足条件的k，那么意味这A[j]、A[i]不在任意一个斐波那契序列中,memo[i][j] = 2。
 */
public int lenLongestFibSubseq(int[] A) {
    if(A==null || A.length==0){
        return 0;
    }

    int N=A.length;

    //使用map存储<数字,在A中的下标>，由于是递增的,不用担心数字重复问题
    Map<Integer,Integer> num_index=new HashMap<>();
    for(int i=0;i<N;i++){
        num_index.put(A[i],i);
    }

    int[][] memo=new int[N][N];

    //将memo中元素都初始化为2
    //memo[i][j]表示以A[i]结尾，前面一个值为A[j]的斐波那契数列长度-->最小为2
    for(int i=0;i<N;i++){
        for(int j=0;j<N;j++){
            memo[i][j]=2;
        }
    }

    int res=0;

    for(int j=2;j<N;j++){
        if(A[0]+A[1]==A[j]){
            //以A[j]结尾的前面的元素为A[1]的斐波那契数列长度为3
            memo[1][j]=3;
            res=Math.max(res,3);
        }
    }

    for(int i=2;i<N;i++){
        for(int j=i+1;j<N;j++){
            if((A[j]-A[i]<A[i]) && num_index.containsKey(A[j]-A[i])){
                // A[k]+A[i]==A[j] --> memo[i][j]=memo[k][i]+1
                int k=num_index.get(A[j]-A[i]);
                memo[i][j] = memo[k][i]+1;
                res = Math.max(res,memo[i][j]);
            }
        }
    }

    return res;
}
```

### 96
[96 Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/)
```java
/**
 * 思路：
 * 这棵树的不同形态的二叉查找树的个数，就是根节点的左子树的个数 *  右子树的个数，
 * 想想还是很容易理解的，就是左边的所有情况乘以右边的所有情况，
 */
public int numTrees(int n) {
    int[] dp=new int[n+1];

    //n=0表示null,(null树也是二分树)只有1种情况
    dp[0]=1;
    //n=1表示只有一个节点，只有一种情况
    dp[1]=1;
    for(int i=2;i<=n;i++){ //i 表示的是BST树的节点个数
        for(int j=1;j<=i;j++){
            // dp[j-1] 表示左子树中不同形态的二叉搜索树的个数
            // dp[i-j]  表示右子树中不同形态的二叉搜索树的个数
            dp[i] += dp[j-1] * dp[i-j];
        }
    }
    return dp[n];
}
```

### 600 
[600 Non-negative Integers without Consecutive Ones](https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/)
```java
/**
 * 思路一：直接法，先判断num是否有连续的1
 */
public int findIntegers(int num) {
    long res=0L;
    for(int i=0;i<=num;i++){
        if(hasConsecutiveOnes(i)){
            res++;
        }
    }
   return (int)res;
}

//判断num是否有连续的1
private boolean hasConsecutiveOnes(int num){
    for(int i=0;i<32;i++){
        int bit1=num&1;
        int bit2=(num>>1)&1;
        if(bit1==1 && bit2==1){
            return false;
        }
        num=(num>>1);
    }
    return true;
}
```

```java
/**
 * 思路二：动态规划思路
 * (1)将原始n转换为二进制表示字符串
 * (2)设置两个数组
 * dp0 [i]：当前位设置为0时的整数的个数
 * dp1 [i]：当前位设置为1时的整数的个数
 * (3)任何整数都不能包含任何连续的1：
 * dp0[i]=dp1[i-1]+dp0[i-1] (二进制表示的数中0前面要么是1，要么是0)
 * dp1[i]=dp0[i-1]（二进制表示的数中1前面就只能是1）
 * (4) 进行最后的处理以找到小于或等于n的整数。
 * 1.由于要求的是<=n的整数个数，我们只对最高的有效位（数组最后一位）进行减操作
 * 2.如果这个num出现了2个连续的1，则剩下的<num的数他们的解必然<=num的解，则此um的解就是最优解！
 * 3.如果num中出现 0后面接着1，对解没有影响，1后面接着0，也是如此。
 * 4.如果num中出现 2个连续的0，对于第一个0的情况有“00”和“01”，
 * 此时只需要“00"的作为解，所以要减去"01"这种情况。
 */
public int findIntegers(int num) {
    String str_num=toBinaryStr(num);

    int size = str_num.length();
    int[] dp0=new int[size];
    int[] dp1=new int[size];

    dp0[0] = 1;
    dp1[0] = 1;
    for(int i = 1; i < size; i++){
        dp0[i] = dp0[i - 1] + dp1[i - 1];
        dp1[i] = dp0[i - 1];
    }

    int cnt = dp0[size - 1] + dp1[size - 1];
    for (int i = size - 2; i >= 0; i--) {
        if (str_num.charAt(i) == '1' && str_num.charAt(i+1) == '1') {
            break;
        }
        if (str_num.charAt(i) == '0' && str_num.charAt(i+1) == '0') {
            cnt -= dp1[i];
        }
    }
    return cnt;
}

//得到该数的倒序的二进制字符串，这样方便后续操作
private String toBinaryStr(int num){
   StringBuilder res=new StringBuilder();
   while(num>0){
       res.append(num%2+"");
       num/=2;
   }
   return res.toString();
}
```

### 788 
[788 Rotated Digits](https://leetcode.com/problems/rotated-digits/)

```java
public int rotatedDigits(int N) {
    int res=0;
    for(int num=1;num<=N;num++){
        if(isGood(num,false)){
            res++;
        }
    }
    return res;
}

//判断 num 是否是 good
//d在[1-9]之间，则 2，5，6，9 必然是 good
//当d是 0、1、8时要接着看上一位了
private boolean isGood(int num,boolean flag){
    if(num==0){
        return flag;
    }

    int d=num%10;
    //如果num数字每一位上，都有3或4或7,则num必然不是good
    //如347就不是good , 437也不是good
    if(d==3 || d==4 || d==7){
        return false;
    }

    if(d==0 || d==1 || d==8){
        return isGood(num/10,flag);
    }

    return isGood(num/10,true);
}
```

### 871 
[871 Minimum Number of Refueling Stops](https://leetcode.com/problems/minimum-number-of-refueling-stops/)

### 879 
[879 Profitable Schemes](https://leetcode.com/problems/profitable-schemes/)

### 887 
[887 Super Egg Drop](https://leetcode.com/problems/super-egg-drop/)

### 902 
[902 Numbers At Most N Given Digit Set](https://leetcode.com/problems/numbers-at-most-n-given-digit-set/)

### 903
[903 Valid Permutations for DI Sequence](https://leetcode.com/problems/valid-permutations-for-di-sequence/)

### 741 
[741 Cherry Pickup](https://leetcode.com/problems/cherry-pickup/)

## 最小编辑距离算法
### 概念
字符串的编辑距离，又称为Levenshtein距离，由俄罗斯的数学家Vladimir Levenshtein在1965年提出。
是指利用字符操作，把字符串A转换成字符串B所需要的最少操作数。其中，字符操作包括：
    
* 删除一个字符/Insert a character

* 插入一个字符/Delete a character

* 修改一个字符/Replace a character

例如对于字符串"if"和"iff"，可以通过插入一个'f'或者删除一个'f'来达到目的。
    
一般来说，两个字符串的编辑距离越小，则它们越相似。

如果两个字符串相等，则它们的编辑距离（为了方便，本文后续出现的“距离”，如果没有特别说明，则默认为“编辑距离”）为0（不需要任何操作）。
不难分析出，两个字符串的编辑距离肯定不超过它们的最大长度（可以通过先把短串的每一位都修改成长串对应位置的字符，然后插入长串中的剩下字符）。

### 问题描述
给定两个字符串A和B，求字符串A至少经过多少步字符操作变成字符串B。 

### 问题分析
* 首先考虑A串的第一个字符

假设存在两个字符串A和B，他们的长度分别是lenA和lenB。

首先考虑第一个字符，由于他们是一样的，所以只需要计算A[2...lenA]和B[2...lenB]之间的距离即可。
那么如果两个字符串的第一个字符不一样怎么办？可以考虑把第一个字符变成一样的（这里假设从A串变成B串）：

(1)修改A串的第一个字符成B串的第一个字符，之后仅需要计算A[2...lenA]和B[2...lenB]的距离即可

(2)删除A串的第一个字符，之后仅需要计算A[2...lenA]和B[1...lenB]的距离即可

(3)把B串的第一个字符插入到A串的第一个字符之前，之后仅需要计算A[1...lenA]和B[2...lenB]的距离即可

* 接下来考虑A串的第i个字符和B串的第j个字符

我们这个时候不考虑A的前i-1字符和B串的第j-1个字符。如果A串的第i个字符和B串的第j个字符相等，即A[i]=B[j]，
则只需要计算A[i...lenA]和B[j...lenB]之间的距离即可。如果不相等，则：

(1)修改A串的第i个字符成B串的第j个字符，之后仅需要计算A[i+1...lenA]和B[j+1...lenB]的距离即可

(2)删除A串的第i个字符，之后仅需要计算A[i+1...lenA]和B[j...lenB]的距离即可

(3)把B串的第j个字符插入到A串的第i个字符之前，之后仅需要计算A[i...lenA]和B[j+1...lenB]的距离即可

### 动态规划方程
 用edit[i][j]表示A串和B串的编辑距离。
 
edit[i][j]表示**A串从第0个字符开始到第i个字符**和**B串从第0个字符开始到第j个字符**，这两个字串的编辑距离。
 
注意：字符串的下标从1开始。


edit[0][0]表示word1和word2都为空的时候，此时他们的Edit Distance为0。

很明显可以得出的:

dis[0][j]就是word1为空，word2长度为j的情况，此时他们的Edit Distance为j，也就是从空，添加j个字符转换成word2的最小Edit Distance为j；

同理dis[i][0]就是，word1长度为i，word2为空时，word1需要删除i个字符才能转换成空，所以转换成word2的最小Edit Distance为i。

动态规划方程如下：

<div align="center"><img src="pics//dp//dp_25.gif" width="600"/></div>

其中

(1)当A[i]=B[j]时，flag=0

(2)当A[i]!=B[j]时，flag=1

edit[i-1][j]+1相当于给word2的最后插入了word1的最后的字符，插入操作使得edit+1，之后计算edit[i-1][j]；

edit[i][j-1]+1相当于将word2的最后字符删除，删除操作edit+1，之后计算edit[i][j-1];

edit[i-1][j-1]+flag相当于通过将word2的最后一个字符替换为word1的最后一个字符。flag标记替换的有效次数。

```java
public class LevenshteinDistanceAlgorithm {
    private int min(int a,int b,int c) {
        int tmp=a<b?a:b;
        return tmp<c?tmp:c;
    }


    public int editDistance(String s1,String s2){
        int m=s1.length();
        int n=s2.length();
        int[][] edit=new int[m+1][n+1];

        for(int i=0;i<=m;i++){
            edit[i][0]=i;
        }

        for(int j=0;j<=n;j++){
            edit[0][j]=j;
        }

        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                int flag=0;
                if(s1.charAt(i-1)!=s2.charAt(j-1)){
                    flag=1;
                }
                edit[i][j]=min(edit[i-1][j]+1,edit[i][j-1]+1,edit[i-1][j-1]+flag);
            }
        }
        return edit[m][n];
    }

    @Test
    public void test(){
        String s1="jary";
        String s2="jerry";
        System.out.println(editDistance(s1,s2));
    }
}
```