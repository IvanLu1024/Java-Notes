# [第六章 递归和回溯法](#递归和回溯法)

| 章节 | 典型题目 | 相关题目 | 更多扩展练习 | 难题推荐 |
| :---: | :---: | :---: | :---: | :---: |
| [6-1 树形问题 Letter Combinations of a Phone Number](#树形问题) | [17](#17) | [无] | [690](#690) | |
| [6-2 什么是回溯](#什么是回溯) | [17](#17) | [93](#93) [131](#131) | [797](#797) | |
| [6-3 排列问题 Permutations](#排列问题) | [46](#46) | [47](#47) | [784](#784) | |
| [6-4 组合问题 Combinations](#组合问题) | [77](#77) | [无] | | |
| [6-5 回溯法解决组合问题的优化](#回溯法解决组合问题的优化) | [77](#77题的优化)| [39](#39) [40](#40) [216](#216) [78*](#78) [90](#90) [401](#401) | [254](#254) | |
| [6-6 二维平面上的回溯法 Word Search](#二维平面上的回溯法) | [79*](#79) | [无] | | |
| [6-7 floodfill算法，一类经典问题 Number of Islands](#floodfill算法之一类经典问题) | [200](#200) | [130](#130) [417](#417) | [695](#695) [733](#733) | 711 |
| [6-8 回溯法是经典人工智能的基础 N Queens](#回溯法是经典人工智能的基础) | [51*](#51) | [52](#52) [37](#37) | | |
| [补充1 更多回溯问题](#更多回溯问题) | [473](#473) | [698](#698) | | |
| [补充2 其他递归问题](#其他递归问题) | [无] | [无] | | 390 |

# 递归和回溯法
## 树形问题
### 17
[17 Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/)

* 问题：

<div align="center"><img src="pics//backtrack//backtrack_1.png" width="600"/></div>

* 示例：

<div align="center"><img src="pics//backtrack//backtrack_2.png" width="600"/></div>

* 解题：

(1)确定问题

<div align="center"><img src="pics//backtrack//backtrack_3.png" width="600"/></div>

(2)解题思路

<div align="center"><img src="pics//backtrack//backtrack_4.png" width="600"/></div>

digits是数字字符串

s(digits)是digits所能代表的字母字符串

letter(digits[i])是digits[i]所能代表的字母

 s(digits[0...n-1])
 
= letter(digits[0]) + s(digits[1...n-1])

= letter(digits[0]) + letter(digits[1]) + s(digits[2...n-1])

= ...

(3)代码
```java
//注意：0和1是不表示字母的
private String[] letterMap={
        " ",
        "",
        "abc",//2
        "def",//3
        "ghi",//4
        "jkl",//5
        "mno",//6
        "pqrs",//7
        "tuv",//8
        "wxyz"//9
};

private ArrayList<String> res;

//s中保存从digits[0...index-1]翻译得到的一个字母字符串
//寻找和digits[index]匹配的字母，获得digits[0...index]翻译得到的字符串
private void findCombination(String digits,int index,String s){
    //递归结束条件
    if(index==digits.length()){
        //保存s
        res.add(s);
        return;
    }
    // c表示digits的index位置的数字
    char c=digits.charAt(index);
    assert  c>='0' && c<='9'&& c!='0';
    String letters=letterMap[c-'0'];
    for(int i=0;i<letters.length();i++){
        findCombination(digits,index+1,s+letters.charAt(i));
    }
}

public List<String> letterCombinations(String digits) {
    res=new ArrayList<>();
    //当digit为空字符串时，返回的是空集合
    if("".equals(digits)){
        return res;
    }
    findCombination(digits,0,"");
    return res;
}
```

### 690
[690 Employee Importance](https://leetcode.com/problems/employee-importance/description/)

* 解法一：
```java
//思路：直接暴力求解，这里循环是可终止的，所以不需要特殊的递归结束条件
public int getImportance(List<Employee> employees, int id) {
    int res=0;
    for(Employee e:employees){
        if(e.id==id){
            res=e.importance;
            List<Integer> subordinates=e.subordinates;
            if(subordinates!=null || subordinates.size()!=0){
                for(Integer subIds:subordinates){
                    res+=getImportance(employees,subIds);
                }
            }
        }
    }
    return res;
}
```

* 解法二：
```java
//思路：可以将这个employee的id表示一棵树，上下级的关系，就是层与层的关系,
// 进行层次遍历，这样可以不使用递归了。
public int getImportance(List<Employee> employees, int id) {
    Map<Integer,Employee> map = new HashMap<Integer,Employee>();
    for(int i=0;i<employees.size();i++)
        map.put(employees.get(i).id,employees.get(i));
    int res=0;
    Queue<Employee> queue = new LinkedList<Employee>();
    queue.add(map.get(id));
    while(!queue.isEmpty()){
        Employee employee=queue.poll();
        res+=employee.importance;
        List<Integer> subordinates=employee.subordinates;
        for(Integer subId:subordinates){
            queue.add(map.get(subId));
        }
    }
    return res;
}
```

## 什么是回溯
```java
public class BackTrackTest {
    //注意：0和1是不表示字母的
    private String[] letterMap={
            " ",
            "",
            "abc",//2
            "def",//3
            "ghi",//4
            "jkl",//5
            "mno",//6
            "pqrs",//7
            "tuv",//8
            "wxyz"//9
    };

    private ArrayList<String> res;

    //s中保存从digits[0...index-1]翻译得到的一个字母字符串
    //寻找和digits[index]匹配的字母，获得digits[0...index]翻译得到的字符串
    private void findCombination(String digits,int index,String s){
        System.out.println(index+":"+s);
        //递归结束条件
        if(index==digits.length()){
            //保存s
            res.add(s);
            System.out.println("get "+s+" ,return");
            return;
        }
        // c表示digits的index位置的数字
        char c=digits.charAt(index);
        assert  c>='0' && c<='9'&& c!='0';
        String letters=letterMap[c-'0'];
        for(int i=0;i<letters.length();i++){
            System.out.println("digits["+index+"]="+c+" ,use "+letters.charAt(i));
            findCombination(digits,index+1,s+letters.charAt(i));
        }
        System.out.println("digits["+index+"]="+c+" complete,return");
    }

    public List<String> letterCombinations(String digits) {
        res=new ArrayList<>();
        //当digit为空字符串时，返回的是空集合
        if("".equals(digits)){
            return res;
        }
        findCombination(digits,0,"");
        return res;
    }

    @Test
    public void test(){
        List<String> res=letterCombinations("23");
    }
}
```
输出结果:
```java
0:
digits[0]=2 ,use a
1:a
digits[1]=3 ,use d
2:ad
get ad ,return
digits[1]=3 ,use e
2:ae
get ae ,return
digits[1]=3 ,use f
2:af
get af ,return
digits[1]=3 complete,return
digits[0]=2 ,use b
1:b
digits[1]=3 ,use d
2:bd
get bd ,return
digits[1]=3 ,use e
2:be
get be ,return
digits[1]=3 ,use f
2:bf
get bf ,return
digits[1]=3 complete,return
digits[0]=2 ,use c
1:c
digits[1]=3 ,use d
2:cd
get cd ,return
digits[1]=3 ,use e
2:ce
get ce ,return
digits[1]=3 ,use f
2:cf
get cf ,return
digits[1]=3 complete,return
digits[0]=2 complete,return
```
时间复杂度：

近似为 3^n =O(2^n)


### 93
[93 Restore IP Addresses](https://leetcode.com/problems/restore-ip-addresses/description/)
```java
/**
 * 在输入字符串中加入三个点，将字符串分为四段，每一段必须合法，求所有可能的情况。
 * 我们用k来表示当前还需要分的段数，如果k = 0，则表示三个点已经加入完成，四段已经形成，若这时字符串刚好为空，则将当前分好的结果保存。
 * 若k != 0,
 * 则对于每一段，我们分别用一位，两位，三位来尝试，分别判断其合不合法，如果合法，则调用递归继续分剩下的字符串，最终和求出所有合法组合。
 * @param s
 * @return
 */
public List<String> restoreIpAddresses(String s){
    List<String> res=new ArrayList<>();
    if(s.length()<4 || s.length()>12){
        return res;
    }
    restore(s,1,"",res);
    return res;
}

//count表示的是取的是第count段
//p存储的前段的IP地址
//s表示的每一段的IP地址
private void restore(String s,int count,String p,List<String> res){
    if(count==4 && isValid(s)){
        res.add(p+s);
        return;
    }
    //Math.min(4, s.length())后面几位少于4的情况比如，0000
    for(int i=1;i< Math.min(4,s.length());i++){
        String cur=s.substring(0,i);
        if(isValid(cur)){
            restore(s.substring(i),count+1 ,p+cur+".",res);
        }
    }
    return;
}

/**
 * IP地址总共有四段，
 * 每一段可能有一位，两位或者三位，范围是[0, 255]，
 * 题目明确指出输入字符串只含有数字，所以当某段是三位时，我们要判断其是否越界（>255)，
 * 还有一点很重要的是，当只有一位时，0可以成某一段，
 * 如果有两位或三位时，像 00， 01， 001， 011， 000等都是不合法的，
 * 所以我们还是需要有一个判定函数来判断某个字符串是否合法。
 */
private boolean isValid(String s){
    //该字符串的第一个元素是0,则该字符串要合法的话，就只能是0
    if(s.charAt(0)=='0'){
        return "0".equals(s);
    }
    int num=Integer.parseInt(s);
    return num>0 && num<256;
}
```

### 131
[131 Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/description/)
```java
private List<List<String>> res;
public List<List<String>> partition(String s) {
    res=new ArrayList<>();
    if(s.length()==0){
        return res;
    }
    List<String> p=new ArrayList<>();
    findPalindrome(s,0,p);
    return res;
}

private void findPalindrome(String s,int index,List<String> p){
    if(index==s.length()){
        res.add(new ArrayList<>(p));
        return;
    }
    for(int i=index;i<s.length();i++){
        // 字符串[index,i+1) ，一共有 i-index+1个元素
        String tmp=s.substring(index,i+1);
        if(isPalindrome(tmp)){
            p.add(tmp);
            findPalindrome(s,i+1,p);
            p.remove(p.size()-1);
        }
    }
}

//判断字符串是否是回文串
private boolean isPalindrome(String s){
    int start=0;
    int end=s.length()-1;
    while(start<end){
        if(s.charAt(start)!=s.charAt(end)){
            return false;
        }
        start++;
        end--;
    }
    return true;
}
```

### 797
[797 All Paths From Source to Target](https://leetcode.com/problems/all-paths-from-source-to-target/description/)

* 示例：

Input: [[1,2], [3], [3], []]

Output: [[0,1,3],[0,2,3]]

Explanation: The graph looks like this:
 0--->1
 |    |
 v    v
 2--->3

这里面graph是使用的二维数组表示的，[[1,2], [3], [3], []]可以使用矩阵这样表示

<div align="center"><img src="pics//backtrack//backtrack_28.png" width="600"/></div>
 
```java
private List<List<Integer>> res;
/**
 * 思路：
 * 分析可知解集是子集树
 */
public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
    res=new ArrayList<>();
    int n=graph.length;
    if(n==0){
        return res;
    }
    List<Integer> p=new ArrayList<>();
    p.add(0);
    findPath(graph,0,n-1,p);
    return res;
}

//p保存的是[start...end]点的路径
private void findPath(int[][] graph,int start,int end,List<Integer> p){
    if(start==end){
        res.add(new ArrayList<>(p));
        return;
    }

    //(index,nodes[i])表示一条边
    int[] vertexs=graph[start];
    if(vertexs.length!=0){
        for(int vertex:vertexs){
            p.add(vertex);
            //查找到vertex顶点接着向下寻找
            findPath(graph,vertex,end,p);
            p.remove(p.size()-1);
        }
    }
}
```

## 排列问题
### 46
[46 Permutations](https://leetcode.com/problems/permutations/description/)

* 问题：

给定一个整型数组，其中每一个元素个不相同，返回这些元素所有排列的可能。

* 示例：

对于[1,2,3]

返回[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

* 解题：

典型的使用回溯法来解决的问题。

<div align="center"><img src="pics//backtrack//backtrack_5.png" width="600"/></div>

数学表达式的形式：

<div align="center"><img src="pics//backtrack//backtrack_6.png" width="600"/></div>

```java
private List<List<Integer>> res;

//用来去除已经访问过的元素,该数组长度为nums.lenth,其下标表示的元素和nums的下标表示的元素相同
private boolean[] visitecd;

//p中保存一个有index的元素的排列
//向这个排列的末尾添加第(index+1)个元素，获的有(index+1)个元素的排列
private void generatePermutation(int[] nums,int index,List<Integer> p){
    if(index==nums.length){
        //这里要尤其注意，p传过来的是引用
        res.add(new ArrayList<>(p));
        return;
    }
    for(int i=0;i<nums.length;i++){
        //判断nums[i]是否在p元素中
        if(visitecd[i]==false){
            //将nums[i]元素直接放入p中
            p.add(nums[i]);
            visitecd[i]=true;
            generatePermutation(nums,index+1,p);

            //回溯法的精髓
            p.remove(p.size()-1);
            visitecd[i]=false;
        }
    }
    return;
}

public List<List<Integer>> permute(int[] nums) {
    res=new ArrayList<>();
    if(nums.length==0){
        return res;
    }
    visitecd=new boolean[nums.length];
    List<Integer> p=new ArrayList<>();
    generatePermutation(nums,0,p);
    return res;
}
```

### 47
[47 Permutations II](https://leetcode.com/problems/permutations-ii/description/)
```java
private List<List<Integer>> res;

private boolean[]  vistied;

private void generatePermutation(int[] nums,int index,List<Integer> p){
    if(nums.length==index){
        res.add(new ArrayList<>(p));
        return;
    }
    for(int i=0;i<nums.length;i++){
        if(vistied[i]==false){
            //nums[i]是重复元素，并且相邻两个元素都没被访问过
            if(i>0 && nums[i]==nums[i-1] && vistied[i-1]==false){
                continue;
            }
            //要加入的元素，与前一个元素不能相同
            p.add(nums[i]);
            vistied[i]=true;

            generatePermutation(nums,index+1,p);

            p.remove(p.size()-1);
            vistied[i]=false;
        }
    }
    return;
}

/**
 * 思路：
 * 看到重复元素，首先要想到能否使用排序。
 * 这里如果已经访问过的数字如果是重复元素,排序后，相邻元素相同，则该元素是重复元素
 */
public List<List<Integer>> permuteUnique(int[] nums) {
    res=new ArrayList<>();
    if(nums.length==0){
        return res;
    }
    //先对数组进行排序，方便后面的
    Arrays.sort(nums);
    List<Integer> p=new ArrayList<>();
    vistied=new boolean[nums.length];
    generatePermutation(nums,0,p);
    return res;
}
```

### 784
[784 Letter Case Permutation](https://leetcode.com/problems/letter-case-permutation/description/)
```java
private List<String> res;

//处理index位置的字符
//如果是字母，那么要么进行小写处理，要么进行大写处理
private void replace(int index,StringBuilder builder){
    if(index==builder.length()){
        res.add(builder.toString());
        return;
    }
    char ch=builder.charAt(index);
    if(Character.isLetter(ch)){
        builder.setCharAt(index,Character.toLowerCase(ch));
        replace(index+1,builder);
        builder.setCharAt(index,Character.toUpperCase(ch));
        replace(index+1,builder);
    }else{
        replace(index+1,builder);
    }
}

public List<String> letterCasePermutation(String S) {
    res=new ArrayList<>();
    if(S.length()==0){
        res.add("");
        return res;
    }
    StringBuilder builder=new StringBuilder(S);
    replace(0,builder);
    return res;
}
```

## 组合问题
### 77
[77 Combinations](https://leetcode.com/problems/combinations/description/)

* 问题：

给出两个整数n和k，求在1...n这n个数中取出k个数字的所有组合。

* 示例：

n=4，k=2

结果为[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]

* 解题：

<div align="center"><img src="pics//backtrack//backtrack_7.png" width="600"/></div>

```java
private List<List<Integer>> res;

//c存储已经找到的组合
//从start开始搜索新的元素
private void findCombination(int n,int k,int start,List<Integer> c){
    //递归结束条件，这里就是c中有k个元素
    if(k==c.size()){
        res.add(new ArrayList<>(c));
        return;
    }
    for(int i=start;i<=n;i++){
        c.add(i);
        findCombination(n,k,i+1,c);
        c.remove(c.size()-1);
    }
}

public List<List<Integer>> combine(int n, int k) {
    res=new ArrayList<>();
    if(n<=0 || k<=0 || k>n){
        return res;
    }
    List<Integer> c=new ArrayList<>();
    findCombination(n,k,1,c);
    return res;
}
```

## 回溯法解决组合问题的优化
### 77题的优化
[77 Combinations](https://leetcode.com/problems/combinations/description/)

使用剪枝法

<div align="center"><img src="pics//backtrack//backtrack_8.png" width="600"/></div>

```java
private void findCombination(int n,int k,int start,List<Integer> c){
    //递归结束条件，这里就是c中有k个元素
    if(k==c.size()){
        res.add(new ArrayList<>(c));
        return;
    }
    //c存储的是已经找到的组合
    //此时还剩下k-c.size()个空位，
    //[i...n]之间的元素最少要有k-c.size()个,即 n-i+1>=k-c.size()
    //得到 i<=n-(k-c.size())+1
    for(int i=start;i<=n-(k-c.size())+1;i++){
        c.add(i);
        findCombination(n,k,i+1,c);
        c.remove(c.size()-1);
    }
}
```

### 39
[39 Combination Sum](https://leetcode.com/problems/combination-sum/description/)
```java
private List<List<Integer>> res;

public List<List<Integer>> combinationSum(int[] candidates, int target) {
    res=new ArrayList<>();
    if(candidates.length==0){
        return res;
    }
    List<Integer> p=new ArrayList<>();
    solve(candidates,0,target,p);
    return res;
}

private void solve(int[] candidates,int startIndex,int target,List<Integer> p){
    if(target==0){
        res.add(new ArrayList<>(p));
    }
    for(int i=startIndex;i<candidates.length;i++){
        if(target>=candidates[i]){
            p.add(candidates[i]);
            solve(candidates,i,target-candidates[i],p);
            p.remove(p.size()-1);
        }
    }
}
```

### 40 
[40 Combination Sum II](https://leetcode.com/problems/combination-sum-ii/description/)
```java
private List<List<Integer>> res;

public List<List<Integer>> combinationSum2(int[] candidates, int target) {
    res=new ArrayList<>();
    if(candidates.length==0){
        return res;
    }
    Arrays.sort(candidates);
    List<Integer> p=new ArrayList<>();
    solve(candidates,0,target,p);
    return res;
}

private void solve(int[] candidates,int startIndex,int target,List<Integer> p){
    if(target==0){
        res.add(new ArrayList<>(p));
        return;
    }
    for(int i=startIndex;i<candidates.length;i++){
        if(i > startIndex && candidates[i] == candidates[i-1])
            continue;
        if(target>=candidates[i]){
            p.add(candidates[i]);
            solve(candidates,i+1,target-candidates[i],p);
            p.remove(p.size()-1);
        }
    }
    return;
}
```

### 216
[216 Combination Sum III](https://leetcode.com/problems/combination-sum-iii/description/)
```java
class Solution {
    private List<List<Integer>> res;

    public List<List<Integer>> combinationSum3(int k, int n) {
        res=new ArrayList<>();
        if(k>n || k==0){
            return res;
        }
        List<Integer> p=new ArrayList<>();
        //数值是从1开始的
        findCombination(k,n,1,p);
        return res;
    }

    private void findCombination(int k,int n,int num,List<Integer> p){
        //注意，这里的递归结束条件
        if(k==0 && n==0){
            res.add(new ArrayList<>(p));
            return;
        }
        for(int i=num;i<=9;i++){
            //要求n>=i，这样保证(n-i)>=0,保证递归能终止
            if(n>=i){
                p.add(i);
                findCombination(k-1,n-i,i+1,p);
                p.remove(p.size()-1);
            }
        }
    }
}
```

### 78 
[78 Subsets](https://leetcode.com/problems/subsets/description/)
```java
private List<List<Integer>> res;

private void findSubset(int[] nums,int index,List<Integer> p){
    //这里不需要递归的结束条件
    //因为当index==nums.length之后，就会自动终止递归
    //为什么自己不递归？这样会导致解缺失的情况
    //if(index==nums.length){
    //    res.add(new ArrayList<>(p));
    //return;
    //}
    //结果：[[1, 2, 3], [1, 3], [2, 3], [3]]
    //因为每次递归对数组长度是没有要求的，加上条件后，每次只能获取定长的数据
    res.add(new ArrayList<>(p));
    for(int i=index;i<nums.length;i++){
        p.add(nums[i]);
        findSubset(nums,i+1,p);
        p.remove(p.size()-1);
    }
}

public List<List<Integer>> subsets(int[] nums) {
    res=new ArrayList<>();
    if(nums.length==0){
        return res;
    }
    List<Integer> p=new ArrayList<>();
    findSubset(nums,0,p);
    return res;
}
```

### 90 
[90 Subsets II](https://leetcode.com/problems/subsets-ii/description/)
```java
private List<List<Integer>> res;

private void findSubsets(int[] nums,int index,List<Integer> p){
    res.add(new ArrayList<>(p));
    for(int i=index;i<nums.length;i++){
        //剪枝去重复元素，对于搜索的任何一层决不能在本层出现重复，也就是说在相同index下不能出现重复的元素
        //(i>0 && nums[i-1]==nums[i]) 相邻的重复元素
        //i==index 表示在同一层
        if(i!=index && (i>0 && nums[i-1]==nums[i])){
            continue;
        }
        p.add(nums[i]);
        findSubsets(nums,i+1,p);
        p.remove(p.size()-1);
    }
}

public List<List<Integer>> subsetsWithDup(int[] nums) {
    res=new ArrayList<>();
    if(nums.length==0){
        return res;
    }
    Arrays.sort(nums);
    List<Integer> p=new ArrayList<>();
    findSubsets(nums,0,p);
    return res;
}
```

### 401
[401 Binary Watch](https://leetcode.com/problems/binary-watch/description/)
```java
public List<String> readBinaryWatch(int num) {
    List<String> res=new ArrayList<>();
    if(num<0){
        return res;
    }
    for(int h=0;h<12;h++){
        for(int m=0;m<60;m++){
            //统计h在二进制下“1”的数量
            //h=5 --> 转化为二进制(101)-->结果为2
            if(Integer.bitCount(h)+Integer.bitCount(m)==num){
                res.add(String.format("%d:%02d",h,m));
            }
        }
    }
    return res;
}
```
```java
//表示小时的灯
int[] hour={1,2,4,8};
//表示分钟的灯
int[] minute={1,2,4,8,16,32};

private List<String> res;

//num表示还需要点亮的LED数
//index表示所点的表示小时的LED的下标
private void solve(int num,int index,int[] watch){
    if(num==0){
        int h=0;
        int m=0;
        for(int i=0;i<hour.length;i++){
            h+=watch[i]*hour[i];
        }
        for(int i=0;i<minute.length;i++){
            m+=watch[i+4]*minute[i];
        }
        res.add(String.format("%d:%02d",h,m));
    }
    while(index<10){
        //选中index灯
        watch[index]=1;
        //条件取舍，对于hour>11 和 min>59的情况舍去
        if(!((watch[2]==1 && watch[3]==1)||(watch[6]==1 && watch[7]==1 && watch[8]==1 && watch[9]==1))){
            solve(num-1,index+1,watch);
        }
        watch[index]=0;
        index++;
    }
}

public List<String> readBinaryWatch(int num) {
    res=new ArrayList<>();
    //表示手表的10个LED灯，0:表示灯为开启，1表示灯开了
    int[] watch=new int[10];
    solve(num,0,watch);
    return res;
}
```

## 二维平面上的回溯法
### 79
[79 Word Search](https://leetcode.com/problems/word-search/description/)

* 问题：

给定一个二维平面的字母和
一个单词，
看是否可以在这个二维平面上找到该单词。
其中找到这个单词的规则是，从一个字母出发，
可以横向或者纵向连接二维平面上的其他字母。
同一个位置的字母只能使用一次。

* 示例：

```java
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E'],
]

"ABCCED" --> true
"SEE" --> true
"ABCB" --> false
```

* 解题：

从该二维平面的[0,0]位置开始，想上，右，下，左四个方向查找字符串中指定位置的字符

<div align="center"><img src="pics//backtrack//backtrack_9.png" width="600"/></div>

向上，越界了；向右，刚好找到下一位置元素

<div align="center"><img src="pics//backtrack//backtrack_10.png" width="600"/></div>

依次进行

<div align="center"><img src="pics//backtrack//backtrack_11.png" width="600"/></div>

<div align="center"><img src="pics//backtrack//backtrack_12.png" width="600"/></div>

<div align="center"><img src="pics//backtrack//backtrack_13.png" width="600"/></div>

<div align="center"><img src="pics//backtrack//backtrack_14.png" width="600"/></div>

再从[0,1]位置开始...

递归形式为：

<div align="center"><img src="pics//backtrack//backtrack_15.png" width="600"/></div>

```java
//TODO：使用一个数组来表示要查找的方向,这是一个小技巧
private int[][] d={{-1,0},{0,1},{1,0},{0,-1}};

//因为要求在一次查找中字符只能出现一次
private boolean[][] visited;

//判断是否越界
private boolean inArea(int x,int y){
    return (x>=0 && x<m) && (y>=0 && y<n);
}
//m，n分别表示该维数组的行和列
private int m;
private int n;

//从board[startx][starty]开始寻找word[index...word.ength()]
private boolean searchBoard(char[][] board, String word,int index,int startx,int starty){
    if(index==word.length()-1){
        //递归到最后一个字符，看看从[startx,starty]位置开始，是否有该字符
        return board[startx][starty]==word.charAt(index);
    }
    if(board[startx][starty]==word.charAt(index)){
        visited[startx][starty]=true;
        //从[startx,starty]位置开始，向四个方向查找下一元素
        for(int i=0;i<4;i++){
            //TODO：对四个方向都进行查找
            int newx=startx+d[i][0];
            int newy=starty+d[i][1];
            if(inArea(newx,newy) && visited[newx][newy]==false){
                //从board[newx][newy]开始寻找word[index+1...word.ength()]
                if(searchBoard(board,word,index+1,newx,newy)){
                    return true;
                }
            }
        }
        visited[startx][starty]=false;
    }
    return false;
}

public boolean exist(char[][] board, String word) {
    m=board.length;
    assert m>0;
    n=board[0].length;
    visited=new boolean[m][n];
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            if(searchBoard(board,word,0,i,j)){
                return true;
            }
        }
    }
    return false;
}
```
## floodfill算法之一类经典问题
### 200*
[200 Number of Islands](https://leetcode.com/problems/number-of-islands/description/)

* 问题：

给定一个二维数组，只含有0和1两个字符。
其中1代表陆地，0代表水域。**横向和纵向**的陆地连接成岛屿，被水域分开。
问给出的地图中有多少岛屿？

* 示例：

<div align="center"><img src="pics//backtrack//backtrack_16.png" width="600"/></div>

* 解题：

floodfill算法描述：

从[0,0]位置开始进行标记，看[0,0,]位置的左、上、右、下相邻元素

<div align="center"><img src="pics//backtrack//backtrack_17.png" width="600"/></div>

一直进行深度优先搜索

<div align="center"><img src="pics//backtrack//backtrack_18.png" width="600"/></div>

到达某一端后，再递归回去

回退到箭头所值节点，在进行查找

<div align="center"><img src="pics//backtrack//backtrack_19.png" width="600"/></div>

<div align="center"><img src="pics//backtrack//backtrack_20.png" width="600"/></div>

依次进行...

<div align="center"><img src="pics//backtrack//backtrack_21.png" width="600"/></div>

```java
private int m;
private int n;

//用来标记是否是同一个岛屿
private boolean[][] visited;

//TODO:二维数组四个方向查找的小技巧
private int[][] d={{-1,0},{0,1},{1,0},{0,-1}};

private boolean isArea(int x,int y){
    return (x>=0 && x<m) && (y>=0 && y<n);
}

//找到一个岛，就将这个岛标记
private void dfs(char[][] grid, int x, int y) {
    //[x,y]是陆地，并且标记为已经访问的了
    visited[x][y]=true;
    //向四个方向去扩散
    for(int i=0;i<4;i++){
        int newx=x+d[i][0];
        int newy=y+d[i][1];
        if(isArea(newx,newy)){
            //[newx,newy]合法
            if(grid[newx][newy]=='1' && visited[newx][newy]==false){
                //[newx,newy]位置陆地，并且未被标记，进行深度优先遍历
                //如果已经被标记了，则直接忽略
                ////找到一个岛，就将整个岛进行标记
                dfs(grid,newx,newy);
            }
        }
    }
}

public int numIslands(char[][] grid) {
    m=grid.length;
    if(m==0){
        return 0;
    }
    n=grid[0].length;
    visited=new boolean[m][n];
    int res=0;
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            //有陆地，并且这块陆地未被标记，则就是一个新的岛屿
            if(grid[i][j]=='1' && visited[i][j]==false){
                res++;
                //使用floodfill算法来标记这个新岛屿岛屿
                dfs(grid,i,j);
            }
        }
    }
    return res;
}
```

### 130
[130 Surrounded Regions](https://leetcode.com/problems/surrounded-regions/description/)

解法一：

```java
class Solution {
    private int m;
    private int n;

    //标记边界上的元素是否是'O'
    private boolean[][] isO;

    private int[][] d={{-1,0},{0,1},{1,0},{0,-1}};

    private boolean isArea(int x,int y){
        return (x>=0 && x<m) && (y>=0 && y<n);
    }

    //深度优先遍历，来标记边界 'O'
    private void dfs(char[][] board, int x, int y) {
        isO[x][y]=true;
        for(int i=0;i<4;i++){
            int newx=x+d[i][0];
            int newy=y+d[i][1];
            if(isArea(newx,newy)){
                if(board[newx][newy]=='O' && isO[newx][newy]==false){
                        dfs(board,newx,newy);
                }
            }
        }
    }

    /**
     * 思路：
     * 除了和边界有接触的’O'的区域，其他的‘O'的区域都会变成'X'。
     * 所以扫描一遍边界，对于在边界上的’O', 通过BFS标记与它相邻的'O'。
     */
    public void solve(char[][] board) {
        m=board.length;
        if(m==0){
            return;
        }
        n=board[0].length;
        isO= new boolean[m][n];
        //对边界进行深度优先遍历，标记‘O’
        for(int j=0;j<n;j++){
            if(board[0][j]=='O' && isO[0][j]==false){
                dfs(board,0,j);
            }
            if(board[m-1][j]=='O' && isO[m-1][j]==false){
                dfs(board,m-1,j);
            }
        }
        for(int i=0;i<m;i++){
            if(board[i][0]=='O' && isO[i][0]==false){
                dfs(board,i,0);
            }
            if(board[i][n-1]=='O' && isO[i][n-1]==false){
                dfs(board,i,n-1);
            }
        }

        //对整个数组进行遍历，覆盖非边界的 'O'
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(isO[i][j]==false && board[i][j]=='O'){
                    board[i][j]='X';
                }
            }
        }
    }
}
```

解法二：
```java
class Solution {
    private int m;
    private int n;

    //标记边界上的元素是否是'O'
    private boolean[][] isBoardO;

    private int[][] d={{-1,0},{0,1},{1,0},{0,-1}};

    private boolean isArea(int x,int y){
        return (x>=0 && x<m) && (y>=0 && y<n);
    }

    //对边界上的'O'进行广度优先遍历
    private void bfs(char[][] board, int x, int y) {
        isBoardO[x][y]=true;
        Queue<Pair<Integer,Integer>> q=new LinkedList<>();
        q.add(new Pair<>(x,y));
        while(!q.isEmpty()){
            Pair<Integer,Integer> p=q.poll();
            x=p.getKey();
            y=p.getValue();
            for(int i=0;i<4;i++){
                int newx=x+d[i][0];
                int newy=y+d[i][1];
                if(isArea(newx,newy) && board[newx][newy]=='O' && isBoardO[newx][newy]==false){
                    q.add(new Pair<>(newx,newy));
                    isBoardO[newx][newy]=true;
                }
            }
        }
    }

    /**
     * 思路：
     * 除了和边界有接触的’O'的区域，其他的‘O'的区域都会变成'X'。
     * 所以扫描一遍边界，对于在边界上的’O', 通过BFS标记与它相邻的'O'。
     */
    public void solve(char[][] board) {
        m=board.length;
        if(m==0){
            return;
        }
        n=board[0].length;
        isBoardO= new boolean[m][n];
        //对边界进行广度优先遍历，标记‘O’
        for(int j=0;j<n;j++){
            if(board[0][j]=='O' && isBoardO[0][j]==false){
                bfs(board,0,j);
            }
            if(board[m-1][j]=='O'&& isBoardO[m-1][j]==false){
                bfs(board,m-1,j);
            }
        }
        for(int i=0;i<m;i++){
            if(board[i][0]=='O' && isBoardO[i][0]==false){
                bfs(board,i,0);
            }
            if(board[i][n-1]=='O' && isBoardO[i][n-1]==false){
                bfs(board,i,n-1);
            }
        }

        //对整个数组进行遍历，覆盖非边界的 'O'
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(isBoardO[i][j]==false && board[i][j]=='O'){
                    board[i][j]='X';
                }
            }
        }
    }
}
```

### 417
[417 Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/description/)
```java
private int m;
private int n;

private boolean[][] pacific;
private boolean[][] atlantic;


//TODO:二维数组四个方向查找的小技巧
private int[][] d={{-1,0},{0,1},{1,0},{0,-1}};

private boolean isArea(int x,int y){
    return (x>=0 && x<m) && (y>=0 && y<n);
}

private void dfs(int[][] matrix,boolean[][] visited,int x,int y){
    visited[x][y]=true;
    for(int i=0;i<4;i++){
        int newx=x+d[i][0];
        int newy=y+d[i][1];
        if(isArea(newx,newy)){
            //[newx,newy]地势高，并且未被标记
            if(visited[newx][newy]==false && (matrix[newx][newy]>=matrix[x][y])){
                dfs(matrix,visited,newx,newy);
            }
        }
    }
}

public List<int[]> pacificAtlantic(int[][] matrix) {
    List<int[]> res=new ArrayList<>();
    m=matrix.length;
    if(m==0){
        return res;
    }
    n=matrix[0].length;
    pacific=new boolean[m][n];
    atlantic=new boolean[m][n];

    for(int i=0;i<m;i++){
        dfs(matrix,pacific,i,0);
        dfs(matrix,atlantic,i,n-1);
    }
    for(int j=0;j<n;j++){
        dfs(matrix,pacific,0,j);
        dfs(matrix,atlantic,m-1,j);
    }
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            if(pacific[i][j] && atlantic[i][j]){
                res.add(new int[]{i,j});
            }
        }
    }
    return res;
}
```

### 695
[695 Max Area of Island](https://leetcode.com/problems/max-area-of-island/description/)
```java
private int m;
private int n;

//用来标记是否是同一个岛屿
private boolean[][] visited;

//TODO:二维数组四个方向查找的小技巧
private int[][] d={{-1,0},{0,1},{1,0},{0,-1}};

private boolean isArea(int x,int y){
    return (x>=0 && x<m) && (y>=0 && y<n);
}

//找到一个岛，就将这个岛标记
//返回的值就是[x,y]所在岛屿的面积
private int dfs(int[][] grid, int x, int y) {
    if(grid[x][y] == 0){
        return 0;
    }

    //[x,y]是陆地，并且标记为已经访问的了
    visited[x][y]=true;

    int area=1;

    //向四个方向去扩散
    for(int i=0;i<4;i++){
        int newx=x+d[i][0];
        int newy=y+d[i][1];
        if(isArea(newx,newy)){
            //[newx,newy]合法
            if(grid[newx][newy]==1 && visited[newx][newy]==false){
                //[newx,newy]位置陆地，并且未被标记，进行深度优先遍历
                //如果已经被标记了，则直接忽略
                //找到一个岛，就将整个岛进行标记
                area+=dfs(grid,newx,newy);
            }
        }
    }
    return area;
}

public int maxAreaOfIsland(int[][] grid) {
    m=grid.length;
    if(m==0){
        return 0;
    }
    n=grid[0].length;
    visited=new boolean[m][n];
    int res=0;
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            //有陆地，并且这块陆地未被标记，则就是一个新的岛屿
            if(grid[i][j]==1 && visited[i][j]==false){
                //使用floodfill算法来标记这个新岛屿岛屿
                res=Math.max(res,dfs(grid,i,j));
            }
        }
    }
    return res;
}
```

### 733
[733 Flood Fill](https://leetcode.com/problems/flood-fill/description/)
```java
private int m;
private int n;

//用来标记是否是同一中颜色
private boolean[][] visited;

//TODO:二维数组四个方向查找的小技巧
private int[][] d={{-1,0},{0,1},{1,0},{0,-1}};

private boolean isArea(int x,int y){
    return (x>=0 && x<m) && (y>=0 && y<n);
}

//对颜色进行标记
private void dfs(int[][] image, int color,int newColor,int x, int y) {
    visited[x][y]=true;
    image[x][y]=newColor;
    //向四个方向去扩散
    for(int i=0;i<4;i++){
        int newx=x+d[i][0];
        int newy=y+d[i][1];
        if(isArea(newx,newy)==true){
            //[newx,newy]合法
            if(image[newx][newy]==color && visited[newx][newy]==false){
                //[newx,newy]，并且未被标记，进行深度优先遍历
                image[newx][newy]=newColor;
                dfs(image,color,newColor,newx,newy);
            }
        }
    }
}

public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
    m=image.length;
    if(m==0){
        return image;
    }
    n=image[0].length;
    visited=new boolean[m][n];
    int color=image[sr][sc];
    dfs(image,color,newColor,sr,sc);
    return image;
}
```

## 回溯法是经典人工智能的基础
### 51
[51 N-Queens](https://leetcode.com/problems/n-queens/description/)

* 问题：

<div align="center"><img src="pics//backtrack//backtrack_22.png" width="600"/></div>

<div align="center"><img src="pics//backtrack//backtrack_23.png" width="600"/></div>

* 解题：

<div align="center"><img src="pics//backtrack//backtrack_24.png" width="600"/></div>

<div align="center"><img src="pics//backtrack//backtrack_25.png" width="600"/></div>

判断对角线不合法的情况：

(1)竖向：col[i]表示第i列被占用

(2)对角线1：dai1[i]表示第i对角线被1占用

(3)对角线2：dai2[i]表示第i对角线被2占用

<div align="center"><img src="pics//backtrack//backtrack_26.png" width="600"/></div>
<div align="center"><img src="pics//backtrack//backtrack_27.png" width="600"/></div>

```java
private List<List<String>> res;

//用于判断是否在同一竖线上，因为index表示行数，是变化的，所以不用判断是否在相同行
private boolean col[];
//判断是是否在1类对角线上
private boolean dia1[];
//判断是是否在2类对角线上
private boolean dia2[];

//在 n*n 棋盘的index行上放皇后
//row用于存储在index行能够放皇后的位置
private void putQueuen(int n,int index,List<Integer> row){
    if(index==n){
        //generateBoard(n,row)用于产生棋盘
        res.add(generateBoard(n,row));
        return;
    }
    for(int j=0;j<n;j++){
        //TODO:对角线的表示
        // 1类对角线 i+j = 同一元素 （i，j为二维数组的下标）
        // 2类对角线 i-j+n-1 = 同一元素
        if(col[j]==false && dia1[index+j]==false && dia2[index-j+n-1]==false){
            row.add(j);
            col[j]=true;
            dia1[index+j]=true;
            dia2[index-j+n-1]=true;
            putQueuen(n,index+1,row);
            dia2[index-j+n-1]=false;
            dia1[index+j]=false;
            col[j]=false;
            row.remove(row.size()-1);
        }
    }
    return;
}

//row用于存储index行能够放皇后的位置
private List<String> generateBoard(int n,List<Integer> row){
    char[][] board=new char[n][n];
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            board[i][j]='.';
        }
    }
    for(int i=0;i<n;i++){
        board[i][row.get(i)]='Q';
    }
    List<String> list=new ArrayList<>();
    for(int i=0;i<n;i++){
        list.add(new String(board[i]));
    }
    return list;
}

public List<List<String>> solveNQueens(int n) {
    res=new ArrayList<>();
    if(n==0){
        return res;
    }
    col=new boolean[n];
    dia1=new boolean[2*n-1];
    dia2=new boolean[2*n-1];
    List<Integer> row=new ArrayList<>();
    putQueuen(n,0,row);
    return res;
}
```

### 52
[52 N-Queens II](https://leetcode.com/problems/n-queens-ii/description/)
```java
private int num=0;

private boolean[] col;
private boolean[] dia1;
private boolean[] dia2;

//在 n*n 棋盘的index行上放皇后
//row用于存储在index行能够放皇后的位置
private void putQuenen(int n,int index,List<Integer> row){
    if(index==n){
        num++;
        return;
    }
    for(int j=0;j<n;j++){
        if(col[j]==false && dia1[index+j]==false && dia2[index-j+n-1]==false){
            row.add(j);
            col[j]=true;
            dia1[index+j]=true;
            dia2[index-j+n-1]=true;
            putQuenen(n,index+1,row);
            dia2[index-j+n-1]=false;
            dia1[index+j]=false;
            col[j]=false;
            row.remove(row.size()-1);
        }
    }
}

public int totalNQueens(int n) {
    col=new boolean[n];
    dia1=new boolean[2*n-1];
    dia2=new boolean[2*n-1];
    List<Integer> row=new ArrayList<>();
    putQuenen(n,0,row);
    return num;
}
```

### 37
[37 Sudoku Solver](https://leetcode.com/problems/sudoku-solver/description/)

**数独（Sudoku）** 是一款大众喜爱的数字逻辑游戏。
玩家需要根据9X9盘面上的已知数字，推算出所有剩余空格的数字，并且满足
每一行、每一列、每一个**粗线宫内的数字均含1-9**，并且不重复。

```java
private boolean canPutNum(char[][] board,int pos,
                    boolean[][] row, boolean[][] col, boolean[][] block){
    if(pos==81){
        return true;
    }
    //next位置为pos位置后下一个要填写的位置
    int next = pos + 1;
    for(; next < 81; next ++){
        if(board[next / 9][next % 9] == '.'){
            break;
        }
    }

    //pos的位置在表格中是[x,y]
    int x = pos / 9;
    int y = pos % 9;

    //pos位置要填写的是数字[1...9]
    for(int i = 1; i <= 9; i ++){
        if(row[x][i]==false && col[y][i]==false && block[x/3*3+y/3][i]==false){
            row[x][i]=true;
            col[y][i]=true;
            block[x/3*3+y/3][i]=true;
            board[x][y]=(char)(i+'0');
            if(canPutNum(board,next,row,col,block)){
                return true;
            }
            block[x/3*3+y/3][i]=false;
            col[y][i]=false;
            row[x][i]=false;
            board[x][y]='.';
        }
    }
    return false;
}

public void solveSudoku(char[][] board) {
    boolean[][] row = new boolean[9][10];
    boolean[][] col = new boolean[9][10];
    boolean[][] block = new boolean[9][10];

    //对于表格中已经有的数据，设置成true
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (board[i][j] != '.') {
                int num = board[i][j] - '0';
                row[i][num] = true;
                col[j][num] = true;
                block[i / 3 * 3 + j / 3][num] = true;
            }
        }
    }
    for(int i=0;i<81;i++){
        if(board[i/9][i%9]=='.'){
            if(canPutNum(board,i,row,col,block)==false){
                continue;
            }
        }
    }
}
```

## 更多回溯问题
### 473 
[473 Matchsticks to Square](https://leetcode.com/problems/matchsticks-to-square/description/)
```java
/**
 * 思路：
 * 建立一个长度为4的数组sums来保四条的长度和，我们希望每条边都等于target=sum/4。
 * 所有火柴总长度必须是4的倍数，否则不能构成正方形。
 * 每根火柴必须用到，这里通过递归深度优先的方法逐个遍历所有火柴，
 * 依次将其加入到四条边上之后进行下一层遍历，
 * 如果最终四条边长度都达到边长长度则返回true，否则遍历完所有情况后返回false。
 */
public boolean makesquare(int[] nums) {
    if (nums == null || nums.length < 4) {
        return false;
    }
    int sum=0;
    for(int num:nums){
        sum+=num;
    }
    if(sum%4!=0){
        return false;
    }
    int[] sums=new int[4];
    int target=sum/4;
    return canPutMatchSticks(nums,sums,0,target);
}
/**
 * @param nums 火柴长度数组
 * @param sums 存储四条边的长度之和
 * @param step 每次放一根火柴棒的步数
 * @param target 目标正方形的边长
 */
private boolean canPutMatchSticks(int[] nums,int[] sums,int step,int target){
    if(step==nums.length){
        if(sums[0]==target && sums[1]==target &&
                sums[2]==target && sums[3]==target){
            return true;
        }else{
            return false;
        }
    }
    for(int i=0;i<4;i++){
        //sum[i]表示该正方形某一边的长度 nums[step]第step步放入火柴
        //sums[i]+nums[step] 就表示在step步将火柴放入长度为sum[i]的边上
        if(sums[i]+nums[step]>target){
            continue;
        }
        sums[i]+=nums[step];
        if(canPutMatchSticks(nums,sums,step+1,target)){
            return true;
        }
        sums[i]-=nums[step];
    }
    return false;
}
```

* 改进版: 使用剪枝，改进canPutMatchSticks()方法
```java
/**
 * @param nums 火柴长度数组
 * @param sums 存储四条边的长度之和
 * @param step 每次放一根火柴棒的步数
 * @param target 目标正方形的边长
 */
private boolean canPutMatchSticks(int[] nums,int[] sums,int step,int target){
    if(step==nums.length){
        return true;
    }
    for(int i=0;i<4;i++){
        //sum[i]表示该正方形某一边的长度 nums[step]第step步放入火柴
        //sums[i]+nums[step] 就表示在step步将火柴放入长度为sum[i]的边上
        if(sums[i]+nums[step]>target) {
            continue;
        }
        if(step<4 && i>step){
            break;
        }
        sums[i]+=nums[step];
        if(canPutMatchSticks(nums,sums,step+1,target)){
            return true;
        }
        sums[i]-=nums[step];
    }
    return false;
}
```

### 698
[698 Partition to K Equal Sum Subsets](https://leetcode.com/problems/partition-to-k-equal-sum-subsets/description/)
```java
public boolean canPartitionKSubsets(int[] nums, int k) {
    if(nums==null || nums.length<k){
        return false;
    }
    int sum=0;
    for(int num:nums){
        sum+=num;
    }
    if(sum%k!=0){
        return false;
    }
    int[] sums=new int[k];
    int target=sum/k;
    return canPartition(nums,sums,k,0,target);
}

private boolean canPartition(int[] nums,int[] sums,int k,int index,int target){
    if(index==nums.length){
        return true;
    }
    for(int i=0;i<k;i++){
        if(sums[i]+nums[index]>target){
            continue;
        }
        if(index<k && i>index){
            break;
        }
        sums[i]+=nums[index];
        if(canPartition(nums,sums,k,index+1,target)){
            return true;
        }
        sums[i]-=nums[index];
    }
    return false;
}
```
 
## 其他递归问题