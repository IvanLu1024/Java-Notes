# Socket的使用

Socket （套接字）这个名字很有意思，可以作插口或者插槽讲。虽然我们是写软件程序，但是你可以想象为弄一根网线，一头插在客户端，一头插在服务端，然后进行通信。所以在通信之前，双方都要建立一个Socket。

## 一. 基于 UDP 协议的 Socket 程序函数调用过程

因为对比于TCP，UDP是没有连接的，所以是不需要三次握手的也就不需要调用listen()和connect()函数。但是，UDP的交互仍然需要IP和端口号，因而需要bind()。UDP中是没有维护连接状态的数据结构，因此不需要对每个连接建立一组Socket，而是只要有一个Socket，就能够和多个客户端进行通信了。程序函数的调用过程如下图所示：

<div align="center" width="60px">
    <img  src="pics/socket_udp.png"/>
</div>




## 二. 基于 TCP 协议的 Socket 程序函数调用过程

TCP的服务端首先需要监听一个端口，例如调用bind()函数，给这个Socket赋予一个IP地址和端口号。

> 思考一下，为什么需要端口呢？
>
> 一个网络包，内核是要通过TCP头中的这个端口号，来查找你当前的应用程序的，这样就完成了从主机达到进程的步骤。

当服务端有了IP和端口号的时候，就可以调用listen()函数进行监听了，当调用这个函数以后，服务端就进入了LISTEN（监听）状态，这时候客户端就可以发起连接了。

在内核中会为每个Socket维护两个队列：

- 一个是已经建立连接的队列，这时候连接三次握手已经完毕，处于established状态；

- 另一个是还没有完全建立连接的队列，这时候三次握手还没完成，处于syn_rcvd状态。

接下来，服务端调用accept()函数，拿出一个已经完成的连接进行处理。如果还没有完成服务端就继续等待。

在服务端等待的时候，客户端就可以调用connect()函数发起连接。先在参数中指定需要连接的IP和端口号，然后开始发起三次握手。内核会给客户端分配一个临时的端口。一旦三次握手完成，服务端的accept就会返回**另一个Socket**。

> 监听使用的Socket个真正传输数据的Socket其实是两个，一个叫**监听Socket**，另一个叫**已连接Socket**。

连接建立成功以后，双方开始通过read()和write()函数来读写数据，这时候就好像往一个文件流中写数据一样了。

程序函数调用的过程如下图所示：

<div align="center" width="60px">
    <img  src="pics/socket_tcp.png"/>
</div>

准确地说，TCP中的Socket就是一个文件流，因为在Linux系统中Socket就是以文件的形式存在的。其中，写入和读出都是通过**文件描述符**。在内核中，每一个文件都有对应的文件描述符，每一个进程都有一个task_struct的数据结构，这个里面指向了一个文件描述符数组，来列出来这个进程打开的所有文件的文件描述符。

文件描述符是一个整数，也就是这个数组的下标。数组中的内容是一个指针，指向内核中所有打开文件的列表。既然Socket是一个文件，那么就会有一个对应的inode，这个inode不是保存在硬盘上而是在内存中。这个inode指向了Socket在内核中的结构。

这个结构中，主要是一个发送队列，一个接受队列。在这两个队列里面保存的是一个缓存的sk_buff，这个缓存里面能够看到完整包的结构。

整个数据结构如下图所示：

<div align="center" width="60px">
    <img  src="pics/socket_tcp_struct.png"/>
</div>

## 参考资料

《极客时间：趣谈网络协议》