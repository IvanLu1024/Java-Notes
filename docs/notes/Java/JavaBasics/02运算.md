<!-- GFM-TOC -->
* [三、运算](#三运算)
    * [参数传递](#参数传递)
    * [==和equals()](#==和equals)
    * [float 与 double](#float-与-double)
    * [隐式类型转换](#隐式类型转换)
    * [switch](#switch)
<!-- GFM-TOC -->
# 三、运算

## 参数传递

Java 的参数是以**值传递**的形式传入方法中，而不是引用传递。

以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。
在将一个参数传入一个方法时，本质上是**将对象的地址以值的方式传递到形参中**。
因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象，
在一方改变其所指向对象的内容时对另一方没有影响。

```java
public class Dog {

    String name;

    Dog(String name) {
        this.name = name;
    }

    String getName() {
        return this.name;
    }

    void setName(String name) {
        this.name = name;
    }

    String getObjectAddress() {
        return super.toString();
    }
}
```

```java
public class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog("A");
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        func(dog);
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        System.out.println(dog.getName());          // A
    }

    private static void func(Dog dog) {
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        dog = new Dog("B");
        System.out.println(dog.getObjectAddress()); // Dog@74a14482
        System.out.println(dog.getName());          // B
    }
}
```

如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。

```java
class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog("A");
        func(dog);
        System.out.println(dog.getName());          // B
    }

    private static void func(Dog dog) {
        dog.setName("B");
    }
}
```

## ==和equals()
- == 判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象。
   
基本数据类型"=="比较的是值
    
引用数据类型"=="比较的是内存地址
    
- equals()判断两个对象是否相等。但它一般有两种使用情况：

情况1：类没有重写 equals() 方法。等价于“==”。

情况2：类重写了 equals() 方法。一般用来**比较两个对象的内容**；
若它们的内容相等，则返回 true (即，认为这两个对象相等)。
 
```java
public class EqualsDemo {
    public static void main(String[] args) {
        String a = new String("ab"); // a 为一个引用
        String b = new String("ab"); // b为另一个引用,对象的内容一样
        String aa = "ab"; // 放在常量池中
        String bb = "ab"; // 从常量池中查找
        if (aa == bb) // true
            System.out.println("aa==bb");
        if (a == b) // false，非同一对象
            System.out.println("a==b");
        if (a.equals(b)) // true
            System.out.println("aEQb");
        if (42 == 42.0) { // true
            System.out.println("true");
        }
    }
}
```
> **说明**

- String 中的 **equals 方法是被重写过**的，因为 object 的 equals 方法是比较的对象的内存地址，
而 String 的 equals 方法比较的是对象的值。

- 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。
如果没有就在常量池中重新创建一个 String 对象。

## float 与 double

Java 不能隐式执行向下转型，因为这会使得精度降低。

1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。

```java
// float f = 1.1;
```

1.1f 字面量才是 float 类型。

```java
float f = 1.1f;
```

## 隐式类型转换

因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。

```java
short s1 = 1;
// s1 = s1 + 1;
```

但是使用 += 或者 ++ 运算符可以执行隐式类型转换。

```java
s1 += 1;
// s1++;
```

上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：

```java
s1 = (short) (s1 + 1);
```

## switch

从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。

```java
String s = "a";
switch (s) {
    case "a":
        System.out.println("aaa");
        break;
    case "b":
        System.out.println("bbb");
        break;
}
```

**switch 不支持 long**，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，
那么还是用 if 比较合适。

```java
// long x = 111;
// switch (x) { 
// Incompatible types. Found: 'long', required: 'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum'
//     case 111:
//         System.out.println(111);
//         break;
//     case 222:
//         System.out.println(222);
//         break;
// }
```