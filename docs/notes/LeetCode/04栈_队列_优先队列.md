# [第四章 栈、队列、优先队列](#栈_队列_优先队列)

| 章节 | 典型题目 | 相关题目 | 更多扩展练习 | 难题推荐 |
| :---: | :---: | :---: | :---: | :---: |
| [4-1 栈的基础应用 Valid Parentheses](#栈的基础应用) | [20](#20) | [150](#150) [71](#71) | [735](#735) | |
| [4-2 栈和递归的紧密关系 Binary Tree Preorder, Inorder and Postorder Traversal](#栈和递归的紧密关系) | [144](#144) [94](#94) [145](#145) | [无] | | |
| [4-3 运用栈模拟递归](#运用栈模拟递归) | [144](#144) [94](#94) [145](#145) | [341](#341) | [388](#388) | |
| [4-4 队列的典型应用 Binary Tree Level Order Traversal](#队列的典型应用) | [102](#102) [232](#232) | [107](#107) [103](#103) [199](#199) |  [637](#637) | |
| [4-5 BFS和图的最短路径 Perfect Squares](#BFS和图的最短路径) | [279](#279) | [127](#127) [126*](#126)  | [752](#752) | 675 |
| [4-6 优先队列](#优先队列) | [无] | [无] | | |
| [4-7 优先队列相关的算法问题 Top K Frequent Elements](#优先队列相关的算法问题) | [347](#347) | [23](#23) | [692](#692) | 23 239 786 857 |
| [补充1：更多和栈相关的问题](#更多和栈相关的问题) | [无] | [无] | [133*](#133) [856](#856) [227](#227) [901](#901) | 224 282 772 |
| [补充2：更多和队列相关的问题](#更多和队列相关的问题) | [无] | [无] |  [622](#622) | |


# 栈_队列_优先队列
## 栈的基础应用
### 20
[20 Valid Parentheses](https://leetcode.com/problems/valid-parentheses/description/)

* 问题：

给定一个字符串，只包含(,){,},[,],判定字符串找那个的括号是否合法。

* 示例：

"()"、"()[]{}"是合法的

"(])"、"([)]])"就是非法的

* 解题：

利用栈的思路：

（1）是左方向的括号，就直接入栈

（2）右方向的括号，就拿出站定元素与之对比，匹配就弹出

```java
public boolean isValid(String s) {
    Stack<Character> stack=new Stack<>();
    for(int i=0;i<s.length();i++) {
        char c = s.charAt(i);
        if (c == '(' || c == '{' || c == '[') {
            stack.push(c);
        } else {
            if (stack.empty()) {
                return false;
            }

            char match;
            if (c == ')') {
                match = '(';
            } else if (c == '}') {
                match = '{';
            } else {
                assert c == ']';
                match = '[';
            }

            char topChar = stack.pop();
            if (topChar != match) {
                return false;
            }
        }
    }
    //注意有可能，这个栈放入的都是左方向的括号，此时直接返回 true是不对的
    if(!stack.empty()){
        return false;
    }
    return true;
}
```
### 150
[150 Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/description/)
```java
public int evalRPN(String[] tokens) {
    if(tokens.length==1){
        return Integer.parseInt(tokens[0]);
    }
    Stack<String> stack=new Stack<>();
    for(String ele : tokens) {
        switch (ele){
            case "+":
                String num1 = stack.pop();
                String num2 = stack.pop();
                String num3 = Integer.parseInt(num2) + Integer.parseInt(num1) + "";
                stack.push(num3);
                break;
            case "-":
                String num4 = stack.pop();
                String num5 = stack.pop();
                String num6 = Integer.parseInt(num5) - Integer.parseInt(num4) + "";
                stack.push(num6);
                break;
            case "*":
                String num7 = stack.pop();
                String num8 = stack.pop();
                String num9 = Integer.parseInt(num8) * Integer.parseInt(num7) + "";
                stack.push(num9);
                break;
            case "/":
                String num10 = stack.pop();
                String num11 = stack.pop();
                String num12 = Integer.parseInt(num11) / Integer.parseInt(num10) + "";
                stack.push(num12);
                break;
            default:
                stack.push(ele);
                break;
        }
    }
    return Integer.parseInt(stack.pop());
}
```
### 71
[71 Simplify Path](https://leetcode.com/problems/simplify-path/description/)
```java
/**
 * 思路：
 * 字符串处理，由于".."是返回上级目录（如果是根目录则不处理），因此可以考虑用栈记录路径名，以便于处理。
 * 需要注意几个细节：
 *1、何时出栈？
 * "../ "代表回上一级目录，那么把栈定元素出栈
 *
 * 2、何时
 * 如果遇到不是 "."，也不是""，不是".."，那么进栈
 * "" 针对的是 // 这种情况。
 */
public String simplifyPath(String path) {
    String[] paths=path.split("/");

    Stack<String> stack=new Stack<>();
    for(String p:paths){
        //出栈的时候要保证栈是非空的
        if("..".equals(p) && !stack.empty()){
            stack.pop();
        }
        //注意条件是使用 && 进行连接的 
        if(! "..".equals(p) && !"".equals(p) && !".".equals(p)){
            stack.push(p);
        }
    }
    return "/"+String.join("/",stack);
}
```

### 735
[735 Asteroid Collision](https://leetcode.com/problems/asteroid-collision/)
```java
/**
 * 思路：
 * 利用stack存储，每次对比栈顶元素（相同的话就放入栈中），否则就对比，直至栈顶相同为止
 * 注意：当栈顶为负数时，直接进栈。
 * 只有当栈顶为正数才需要发生碰撞
 */
public int[] asteroidCollision(int[] asteroids) {
    if(asteroids==null || asteroids.length==0){
        return new int[]{};
    }
    if(asteroids.length==1){
        return new int[]{asteroids[0]};
    }
    Stack<Integer> stack=new Stack<>();
    for(int i=0;i<asteroids.length;i++){
        //栈为空或者入栈元素 > 0则直接加入栈中
        if(stack.isEmpty() || asteroids[i]>0){
            stack.push(asteroids[i]);
            continue;
        }
        //处理 asteroids[i]<0的情况
        while(true){
            //获取栈顶元素
            int top=stack.peek();
            //栈顶元素<0,那么就不会碰撞，直接入栈即可
            if(top<0){
                stack.push(asteroids[i]);
                break;
            }
            //栈顶元素>0的情况
            if(top==-asteroids[i]){
                //相等，则碰撞后，两颗行星都会消失：asteroids[i]不能插入，栈顶元素出栈
                stack.pop();
                break;
            }else if(top>-asteroids[i]){
                //相撞后，top方向质量更大：asteroids[i]不能插入
                break;
            }else{
                //相撞后，asteroids[i]方向质量更大：将top出栈，将asteroids[i]插入
                stack.pop();
                if(stack.isEmpty()){
                    //栈为空说明asteroids[i]是质量最大的
                    stack.push(asteroids[i]);
                    break;
                }
            }
        }
    }

    int [] res=new int[stack.size()];
    int i=stack.size()-1;
    while(!stack.empty()){
        res[i--]=stack.pop();
    }
    return res;
}
```

## 栈和递归的紧密关系
### 144
[144 Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/description/)

* 解题：

使用栈模拟系统栈，解决前序遍历的问题。

（1）将头结点压入栈中，对栈进行初始化，go-1表示访问1结点

<div align="center"><img src="pics//stackQueue//stack_1.png"/></div>

（2）由于先序遍历，根据栈的特性，先访问1的右子节点，再访问1的左子节点，最后访问1结点

<div align="center"><img src="pics//stackQueue//stack_2.png"/></div>

（3）1结点是栈顶元素，由于命令是cout，cout 1出栈，所以直接输出节点值1

<div align="center"><img src="pics//stackQueue//stack_3.png"/></div>

（4）此时go 1-L是栈顶元素,就访问1结点的左孩子节点，也就是节点2

<div align="center"><img src="pics//stackQueue//stack_4.png"/></div>

（5）这时候访问结点2，再访问2的右子树的根节点和2的左子树的根节点，最后再访问2节点

<div align="center"><img src="pics//stackQueue//stack_5.png"/></div>

（6）栈顶是 cout-2，输出结果后，栈顶元素是 go-2-L==null,go-2-R==null，do nothing

<div align="center"><img src="pics//stackQueue//stack_6.png"/></div>

(7)访问到3结点

<div align="center"><img src="pics//stackQueue//stack_7.png"/></div>

（8）最终栈为空

```java
private enum Command{GO,PRINT};

private class StackNode{
    Command command;
    TreeNode node;
    StackNode(Command command,TreeNode node){
        this.command=command;
        this.node=node;
    }
}

public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> ret=new ArrayList<>();
    if(root==null){
        return ret;
    }
    Stack<StackNode> stack=new Stack<>();
    stack.push(new StackNode(Command.GO,root));
    while(!stack.empty()){
        StackNode stackNode=stack.pop();
        Command command=stackNode.command;
        if(command==Command.PRINT){
            ret.add(stackNode.node.val);
        }else{
            if(stackNode.node.right!=null){
                stack.push(new StackNode(Command.GO,stackNode.node.right));
            }
            if(stackNode.node.left!=null){
                stack.push(new StackNode(Command.GO,stackNode.node.left));
            }
            stack.push(new StackNode(Command.PRINT,stackNode.node));
        }
    }
    return ret;
}
```
### 94
[94 Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/description/)
```java
private enum Command{GO,PRINT};

private class StackNode{
    Command command;
    TreeNode node;
    StackNode(Command command, TreeNode node){
        this.command=command;
        this.node=node;
    }
}

public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> ret=new ArrayList<>();
    if(root==null){
        return ret;
    }

    Stack<StackNode> stack=new Stack<>();
    stack.push(new StackNode(Command.GO,root));
    while(!stack.empty()){
        StackNode stackNode=stack.pop();
        Command command=stackNode.command;
        if(command==Command.PRINT){
            ret.add(stackNode.node.val);
        }else{
            if(stackNode.node.right!=null){
                stack.push(new StackNode(Command.GO,stackNode.node.right));
            }
            stack.push(new StackNode(Command.PRINT,stackNode.node));
            if(stackNode.node.left!=null){
                stack.push(new StackNode(Command.GO,stackNode.node.left));
            }
        }
    }
    return ret;
}
```
### 145
[145 Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/description/)
```java
private enum Command{GO,PRINT};

private class StackNode{
    Command command;
    TreeNode node;
    StackNode(Command command,TreeNode node){
        this.command=command;
        this.node=node;
    }
}

public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> ret=new ArrayList<>();
    if(root==null){
        return ret;
    }
    Stack<StackNode> stack=new Stack<>();
    stack.push(new StackNode(Command.GO,root));
    while(!stack.empty()){
        StackNode stackNode=stack.pop();
        Command command=stackNode.command;
        if(command==Command.PRINT){
            ret.add(stackNode.node.val);
        }else{
            stack.push(new StackNode(Command.PRINT,stackNode.node));
            if(stackNode.node.right!=null){
                stack.push(new StackNode(Command.GO,stackNode.node.right));
            }
            if(stackNode.node.left!=null){
                stack.push(new StackNode(Command.GO,stackNode.node.left));
            }
        }
    }
    return ret;
}
```
## 运用栈模拟递归
### 341
[341 Flatten Nested List Iterator](https://leetcode.com/problems/flatten-nested-list-iterator/description/)
```java
/**
 * 思路:
 * 先把list中所有的元素都倒序push进stack，
 * 然后每次遇到不是integer的，就重复第一个过程，把list里的元素按照倒序push进stack，直到stack为空。
 */
public class NestedIterator implements Iterator<Integer> {
    Stack<NestedInteger> stack;

    public NestedIterator(List<NestedInteger> nestedList) {
        stack=new Stack<>();
        for(int i=nestedList.size()-1;i>=0;i--){
            NestedInteger tmp=nestedList.get(i);
            stack.push(tmp);
        }
    }

    @Override
    public Integer next() {
        return stack.pop().getInteger();
    }

    @Override
    public boolean hasNext() {
        while (!stack.isEmpty()){
            NestedInteger cur=stack.peek();
            if(cur.isInteger()){
                return true;
            }else{
                //将该cur出栈
                stack.pop();
                List<NestedInteger> tmpList=cur.getList();
                for(int i=tmpList.size()-1;i>=0;i--){
                    stack.push(tmpList.get(i));
                }
            }
        }
        return false;
    }
}
```
### 388
[388 Longest Absolute File Path](https://leetcode.com/problems/longest-absolute-file-path/)
```java
/**
 * 思路：
 * 该字符串中包含\n和\t这种表示回车和空格的特殊字符，让我们找到某一个最长的绝对文件路径。
 * 要注意的是，最长绝对文件路径不一定是要最深的路径。
 * 我们可以用哈希表来建立深度和当前深度的绝对路径长度之间的映射，
 * 那么当前深度下的文件的绝对路径长度就是文件名长度加上哈希表中当前深度对应的长度，
 * 我们的思路是遍历整个字符串，遇到\n或者\t就停下来，然后我们判断，
 * 如果遇到的是回车:
 * 我们把这段文件名提取出来，如果里面包含"."，说明是文件，我们更新res长度，
 * 如果不包含点“.”，说明是文件夹，我们深度level自增1，然后建立当前深度和总长度之间的映射，然后我们将深度level重置为0。
 *
 * 如果遇到的是空格\t，
 * 那么我们深度加1，
 * 通过累加\t的个数，我们可以得知当前文件或文件夹的深度，然后做对应的处理。
 */
public int lengthLongestPath(String input) {
    int res = 0;
    //<深度,当前深度的绝对路径长度>
    Map<Integer, Integer> map = new HashMap<>();
    map.put(0, 0);
    //根据\n切分文件
    String[] arr=input.split("\n");
    //以"dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"为例
    //arr={"dir","\tsubdir1","\t\tfile1.ext","\t\tsubsubdir1","\tsubdir2","\t\tsubsubdir2","\t\t\tfile2.ext"}
    if(arr!=null){
        for (String s : arr) {
            //根据 \t的位置看看有几层
            int level = s.lastIndexOf("\t") + 1;
            //s.substring(level)-->s就是文件夹或者我呢见
            int len = s.substring(level).length();
            if (s.contains(".")) {
                //包含“.”，说明是文件，那么就要更新最大值-->说明到达该层的文件
                //get(level)是该文件前一层的绝对路径长度
                //len是文件路径长度
                res = Math.max(res, map.get(level) + len);
            } else {
                //+1是算上"/"的长度
                map.put(level + 1, map.get(level) + len + 1);
            }
        }
    }
    return res;
}
```
# 队列
## 队列的典型应用
### 102
[102 Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/description/)

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> ret=new ArrayList<>();
    if(root==null){
        return ret;
    }

    Queue<Pair<TreeNode,Integer>> queue=new LinkedList<>();
    queue.add(new Pair<TreeNode,Integer>(root,0));
    //root结点对应的是0层
    while(!queue.isEmpty()){
        Pair pair=queue.poll();
        TreeNode node= (TreeNode) pair.getKey();
        int level= (int) pair.getValue();

        if(level==ret.size()){
            //因为level是从0开始的，当level=ret.size()表示需要新创建 List，来存储level层的元素
            ret.add(new ArrayList<>());
        }
        //ret.get(level)表示的是level层
        ret.get(level).add(node.val);

        if(node.left!=null){
            queue.add(new Pair<TreeNode,Integer>(node.left,level+1));
        }
        if(node.right!=null){
            queue.add(new Pair<TreeNode,Integer>(node.right,level+1));
        }
    }
    return ret;
}
```
### 232
[232 Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/description/)

* 解法一：
```java
/**
 * 思路一：
 * 使用一个栈来存储数据
 * 在push时使用另外一个栈进行转换
 * 使之符合队列FIFO的特性
 */
class MyQueue {
    Stack<Integer> s;

    /** Initialize your data structure here. */
    public MyQueue() {
       s=new Stack<>();
    }

    /** Push element x to the back of queue. */
    public void push(int x) {
        Stack<Integer> s2=new Stack<>();
        //先将s中元素放入s2中
        while(!s.isEmpty()){
            s2.push(s.pop());
        }
        s.push(x);
        //再将s2中元素放入s中
        while(!s2.isEmpty()){
            s.push(s2.pop());
        }
    }

    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        return s.pop();
    }

    /** Get the front element. */
    public int peek() {
        return s.peek();
    }

    /** Returns whether the queue is empty. */
    public boolean empty() {
        return s.isEmpty();
    }
}
```
* 解法二：
```java
/**
 * 思路二：
 * 准备两个栈
 * 一个栈s1用于入队操作，若栈为空，此时进入的元素就是队首元素
 * 一个栈s2用于出队操作，若栈为空，则将s1中元素压入s2中，弹出s2的栈顶元素即可
 * 和一个front存储队列头元素
 */
class MyQueue {
    //入队操作使用
    private Stack<Integer> s1;
    //出队操作是使用
    private Stack<Integer> s2;
    //存储队列头元素
    private int front;

    /** Initialize your data structure here. */
    public MyQueue() {
        s1=new Stack<>();
        s2=new Stack<>();
    }

    /** Push element x to the back of queue. */
    public void push(int x) {
        //方便后面的peek操作
       if(s1.isEmpty()){
           front=x;
       }
       s1.push(x);
    }

    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        if(s2.isEmpty()){
            while(!s1.isEmpty()){
                s2.push(s1.pop());
            }
        }
        return s2.pop();
    }

    /** Get the front element. */
    public int peek() {
        if(!s2.isEmpty()){
           return s2.peek();
        }
        return front;
    }

    /** Returns whether the queue is empty. */
    public boolean empty() {
        return (s1.isEmpty() && s2.isEmpty());
    }
}
```

### 107
[107 Binary Tree Level Order Traversal II](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/)
```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    List<List<Integer>> ret=new ArrayList<>();
    if(root==null){
        return new ArrayList<>();
    }
    Queue<Pair<TreeNode,Integer>> queue=new LinkedList<>();
    queue.add(new Pair<TreeNode,Integer>(root,0));
    while(!queue.isEmpty()){
        Pair pair=queue.poll();
        TreeNode node=(TreeNode) pair.getKey();
        int level=(int)pair.getValue();
        if(level==ret.size()){
            ret.add(new ArrayList<>());
        }
        ret.get(level).add(node.val);

        if(node.left!=null){
            queue.add(new Pair<TreeNode,Integer>(node.left,level+1));
        }
        if(node.right!=null){
            queue.add(new Pair<TreeNode,Integer>(node.right,level+1));
        }
    }
    Collections.reverse(ret);

    return ret;
}
```
### 103
[103 Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/)
```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> ret=new ArrayList<>();
    if(root==null){
        return ret;
    }

    Queue<Pair<TreeNode,Integer>> queue=new LinkedList<>();
    queue.add(new Pair<TreeNode,Integer>(root,0));
    //root结点对应的是0层
    while(!queue.isEmpty()){
        Pair pair=queue.poll();
        TreeNode node= (TreeNode) pair.getKey();
        int level= (int) pair.getValue();

        if(level==ret.size()){
            //因为level是从0开始的，当level=ret.size()表示需要新创建 List，来存储level层的元素
            ret.add(new ArrayList<>());
        }
        //ret.get(level)表示的是level层
        ret.get(level).add(node.val);

        if(node.left!=null){
            queue.add(new Pair<TreeNode,Integer>(node.left,level+1));
        }
        if(node.right!=null){
            queue.add(new Pair<TreeNode,Integer>(node.right,level+1));
        }
    }
    //进行层次遍历后，对于偶数层的数据，进行逆序处理
    int cnt=0;
    for(List<Integer> list:ret){
        if(cnt%2==1){
            Collections.reverse(list);
        }
        cnt++;
    }
    return ret;
}
```
### 199
[199 Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/description/)
```java
public List<Integer> rightSideView(TreeNode root) {
    List<Integer> ret=new ArrayList<>();
    if(root==null){
        return ret;
    }
    Queue<TreeNode> queue=new LinkedList<>();
    queue.add(root);
    
    while(!queue.isEmpty()){
        //nodeNumsEachLevel表示每层的节点数
        int nodeNumsEachLevel=queue.size();
        while(nodeNumsEachLevel>0){
            TreeNode tmp=queue.poll();
            if(tmp.left!=null){
                queue.add(tmp.left);
            }
            if(tmp.right!=null){
                queue.add(tmp.right);
            }
            //每出队一次，该层就减少一个节点
            nodeNumsEachLevel--;
            //nodeNumsEachLevel==0，该层的最右侧节点
            if(nodeNumsEachLevel==0){
                ret.add(tmp.val);
            }
        }
    }
    return ret;
}
```
### 637
[637 Average of Levels in Binary Tree](https://leetcode.com/problems/average-of-levels-in-binary-tree/)
```java
public List<Double> averageOfLevels(TreeNode root) {
    //存储层序遍历各层的元素
    List<List<Integer>> list=new ArrayList<>();
    Queue<Pair> q=new LinkedList<>();
    q.add(new Pair(root,0));
    while(!q.isEmpty()){
        Pair pair=q.poll();
        TreeNode treeNode=pair.treeNode;
        int level=pair.level;
        if(level==list.size()){
            list.add(new ArrayList<>());
        }
        list.get(level).add(treeNode.val);
        if(treeNode.left!=null){
            q.add(new Pair(treeNode.left,level+1));
        }
        if(treeNode.right!=null){
            q.add(new Pair(treeNode.right,level+1));
        }
    }

    List<Double> res=new ArrayList<>();
    if(list.size()==0){
        return res;
    }
    int sum=0;
    for(List<Integer> tmp:list){
        res.add(getAverage(tmp));
    }
    return res;
}

private double getAverage(List<Integer> list){
    //这里要注意 节点值为2147483647相加的情况
    long sum=0L;
    for(Integer num:list){
        sum+=num;
        //[2147483647.0,2147483647.0]
    }
    return (sum*1.0)/list.size();
}

private class Pair{
    TreeNode treeNode;
    int level;
    Pair(TreeNode treeNode,int level){
        this.treeNode=treeNode;
        this.level=level;
    }
}
```

## BFS和图的最短路径
### 279
[279 Perfect Squares](https://leetcode.com/problems/perfect-squares/description/)

* 问题：

给出一个正整数n，寻找最少的完全平方数，使他的平方和为n。

完全平方数：1，4，9，16 ...

* 举例：

12=4+4+4

13=4+9

* 解题：

确定问题：

**没有解怎么办**？ 一定有解，因为1是完全平方数，最差的情况就是n=n个1相加

思路：

1、贪心算法？

使用贪心策略：每次取最大的完全平方数，则12=9+1+1+1，但是12=4+4+4是最终解。

2、对问题建模：将整个问题转化为**图论问题**。

从n到0，每个数字表示一个节点；

如果两个数字x到y相差一个完全平方数，则连接一条边。我们就得到了填个无权图。

那么，原来的问题就转化成，求这个无权图中从n到0的最短路径。

<div align="center"><img src="pics//stackQueue//stack_8.png"/></div>
 
图中1->0的距离是1,2->1的就离是1,
3->2的距离是1，
4->3的距离是1，
4->0的距离是0

<div align="center"><img src="pics//stackQueue//stack_9.png" width="600"/></div>
<div align="center"><img src="pics//stackQueue//stack_10.png" width="600"/></div>
<div align="center"><img src="pics//stackQueue//stack_11.png" width="600"/></div>
<div align="center"><img src="pics//stackQueue//stack_12.png" width="600"/></div>

```java
private class Pair{
    int num;
    //记录节点的数值
    int steps;
    //记录num数值该走几步
    Pair(int num,int steps){
        this.num=num;
        this.steps=steps;
    }
}

public int numSquares(int n) {
    Queue<Pair> queue=new LinkedList<>();
    queue.add(new Pair(n,0));
    
    boolean[] isVisited=new boolean[n+1];
    isVisited[n]=true;

    while(!queue.isEmpty()){
        Pair pair=queue.poll();
        int num=pair.num;
        int steps=pair.steps;
        if(num==0){
            return steps;
        }
        for(int i=1;;i++){
            int tmp=num-i*i;
            if(tmp<0){
                break;
            }
            if(!isVisited[tmp]){
                queue.add(new Pair(tmp,steps+1));
                isVisited[tmp]=false;
            }
        }
    }
    //如果结果不存在，就返回0
    return 0;
}
```
### 127
[127 Word Ladder](https://leetcode.com/problems/word-ladder/description/)
```java
/**
 * BFS
 * 将这个问题看成图问题:
 * word1-->word2 的路径就是word1和word2 "相似"（word1和wordd2根据题目规则可以相互转化）
 * 最后从beginWord走到endWord.
 */
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    //使用set去除重复元素-->BFS更高效
    Set<String> wordSet=new HashSet<>();
    for(String word:wordList){
        wordSet.add(word);
    }

    //存储已经访问过的节点，保证下次不会再走了
    Set<String> visited = new HashSet<>();

    //从beginWord开始进行BFS
    Queue<Pair> q=new LinkedList<>();
    //从 begin开始，走的是第一步
    q.add(new Pair(beginWord,1));
    while (!q.isEmpty()){
        Pair p=q.poll();
        //访问当前节点
        String curWord=p.word;
        int curStep=p.step;
        visited.clear();
        //看下一个节点的情况
        for(String word:wordSet){
            if(isSimilar(curWord,word)){ //isSimilar(curWord,word) 说明beginWod-->word有路径
                if(word.equals(endWord)){
                    return curStep+1;
                }
                //将word加入队列，即访问了word
                q.add(new Pair(word,curStep+1));
                visited.add(word);
            }
        }
        //删除已经访问过的节点
        for(String w:visited){
            wordSet.remove(w);
        }
    }
    return 0;
}

private class Pair{
    String word;
    int step;
    Pair(String word,int step){
        this.word=word;
        this.step=step;
    }
}

//判断word1和word2是否相似，即word1和word是否可以相互转化
private boolean isSimilar(String word1,String word2){
    if(word1.length()!=word2.length() || word1.equals(word2)){
        return false;
    }
    int diff=0;
    for(int i=0;i<word1.length();i++){
        if(word1.charAt(i)!=word2.charAt(i)){
            diff++;
        }
        if(diff>1){
            return false;
        }
    }
    return true;
}
```
### 126
[126 Word Ladder II](https://leetcode.com/problems/word-ladder-ii/description/)
```java

```

### 752
[752 Open the Lock](https://leetcode.com/problems/open-the-lock/)
```java
public int openLock(String[] deadends, String target) {
    Set<String> deadSet=new HashSet<>();
    for(String deadend:deadends){
        deadSet.add(deadend);
    }

    if(deadSet.contains(target) || deadSet.contains("0000")){
        return -1;
    }

    Set<String> visited=new HashSet<>();
    Queue<Pair> q=new LinkedList<>();
    q.add(new Pair("0000",0));
    visited.add("0000");
    while(!q.isEmpty()){
        Pair p=q.poll();
        String curS=p.s;
        int curTurn=p.turn;
        Set<String> next=getNextLock(curS,deadSet);
        for(String lock:next){
            if(!visited.contains(lock)){
                if(target.equals(lock)){
                    return curTurn+1;
                }
                visited.add(lock);
                q.add(new Pair(lock,curTurn+1));
            }
        }
    }
    return -1;
}

//锁的密码是s时，获取下一个有可能的锁密码
private Set<String> getNextLock(String s,Set<String> deadends){
    Set<String> res=new HashSet<>();
    assert s.length()==4;
    for(int i=0;i<4;i++){
        int num = s.charAt(i)- '0';
        int d = num + 1;
        if(d > 9) d = 0;
        String t=s.substring(0,i)+((char) (d+'0'))+s.substring(i+1,4);
        if(!deadends.contains(t)){
            res.add(t);
        }
        d=num-1;
        if(d < 0) d = 9;
        t=s.substring(0,i)+((char) (d+'0'))+s.substring(i+1,4);
        if(!deadends.contains(t)){
            res.add(t);
        }
    }
    return res;
}

private class Pair{
    String s;
    int turn;
    Pair(String s,int turn){
        this.s=s;
        this.turn=turn;
    }
}
```


## 优先队列
* [堆的底层实现，白板编程](https://github.com/DuHouAn/DataStructureNotes/blob/master/src/code_01_heap/MaxHeap.java)

* Java中优先队列的使用
```java
public class PriorityQueueUsing {
    public static void main(String[] args) {
        Random random=new Random();

        //Java语言，默认情况下是最小堆
        PriorityQueue<Integer> pq=new PriorityQueue<>();
        for(int i=0;i<10;i++){
            int num=random.nextInt(100)+1;
            //产生[1,100]之间的随机数
            System.out.println("insert "+num+" into priority queue.");
            pq.add(num);
        }
        while(!pq.isEmpty()){
            int num=pq.poll();
            System.out.print(num+" ");
        }
        System.out.println();

        //底层使用最小堆
        PriorityQueue<Integer> pq2=new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                int num=o2-o1;
                return num;
            }
        });
        for(int i=0;i<10;i++){
            int num=random.nextInt(100)+1;
            //产生[1,100]之间的随机数
            System.out.println("insert "+num+" into priority queue.");
            pq2.add(num);
        }
        while(!pq2.isEmpty()){
            int num=pq2.poll();
            System.out.print(num+" ");
        }
        System.out.println();

        //自定义Comparator的优先队列
        PriorityQueue<Integer> pq3=new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                int num=o2%10-o1%10;
                //这里是按照个位上的数字，得到的最大堆
                return num;
            }
        });
        for(int i=0;i<10;i++){
            int num=random.nextInt(100)+1;
            //产生[1,100]之间的随机数
            System.out.println("insert "+num+" into priority queue.");
            pq3.add(num);
        }
        while(!pq3.isEmpty()){
            int num=pq3.poll();
            System.out.print(num+" ");
        }
        System.out.println();
    }
}
```

## 优先队列相关的算法问题
### 347
[347 Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/description/)

* 问题：

给定一个非空数组，返回前k个出现频率最高的元素。

* 示例：

给定[1,1,1,2,2,3],k=2

返回[1,2]

* 解题：

1、确定问题：

k的合法性问题

2、思路一：

扫描一遍统计频率；

排序找到前k个出现频率最高的元素。

时间复杂度O(n log n)

3、思路二：

维护一个优先队列

时间复杂度O(n log k)

```java
private class Pair implements Comparable<Pair> {
    int numFreq;
    int num;
    Pair(int numFreq,int num){
        this.numFreq=numFreq;
        this.num=num;
    }

    @Override
    public int compareTo(Pair o) {
        return this.numFreq-o.numFreq;
    }
}

public List<Integer> topKFrequent(int[] nums, int k) {
    //统计数字出现的频率
    Map<Integer,Integer> map=new HashMap<>();
    for(int num:nums){
        int freq=map.get(num)==null?0:map.get(num);
        map.put(num,++freq);
    }

    //维护一个优先队列，最小堆，维护当前频率最高的元素
    PriorityQueue<Pair> priorityQueue=new PriorityQueue<>();
    //pair存的是（频率，元素）的形式
    for(Integer num:map.keySet()){
        int numFreq=map.get(num);
        if(priorityQueue.size()==k){
            if(numFreq>priorityQueue.peek().numFreq){
                priorityQueue.poll();
                priorityQueue.add(new Pair(numFreq,num));
            }
        }else{
            priorityQueue.add(new Pair(numFreq,num));
        }
    }

    List<Integer> ret=new ArrayList<>();
    while(!priorityQueue.isEmpty()){
        ret.add(priorityQueue.poll().num);
    }
    return ret;
}
```
### 23
[23 Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/description/)
```java
//思路一：逐步合并有序链表,n是数组长度，K是数组中的链表平均长度
//时间复杂度：O(n*K)
//空间复杂度：O(1)
public ListNode mergeKLists(ListNode[] lists) {
    if(lists==null || lists.length==0){
        return null;
    }

    //将该数组中元素逐步合并
    ListNode head=lists[0];
    for(int i=1;i< lists.length;i++){
        head=mergeTwoLists(head,lists[i]);
    }
    return head;
}

private ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    if(l1==null){
        return l2;
    }
    if(l2 ==null){
        return l1;
    }

    ListNode dummyHead=new ListNode(0);

    ListNode cur1=l1;
    ListNode cur2=l2;
    ListNode cur=dummyHead;
    while(cur1!=null && cur2!=null){
        if(cur1.val <cur2.val){
            cur.next=cur1;
            cur1=cur1.next;
        }else{
            cur.next=cur2;
            cur2=cur2.next;
        }
        cur=cur.next;
    }
    if(cur1!=null){
        cur.next=cur1;
    }
    if(cur2!=null){
        cur.next=cur2;
    }

    ListNode retNode=dummyHead.next;
    dummyHead.next=null;
    return retNode;
}
```

```java
//思路二:使用优先队列,n是数组长度，K是链表平均长度
//时间复杂度：O(n * k log k)
//空间复杂度：O(n)
public ListNode mergeKLists(ListNode[] lists) {
    if(lists==null || lists.length==0){
        return null;
    }
    if (lists.length == 1){
        return lists[0];
    }

    //维护一个最小堆
    PriorityQueue<ListNode> queue = new PriorityQueue<>(new Comparator<ListNode>() {
        public int compare(ListNode o1, ListNode o2) {
            return o1.val - o2.val;
        }
    });
    for (int i = 0; i < lists.length; i++) {
        //这里只是加了每个链表的头结点
        if (lists[i] != null) queue.add(lists[i]);
    }

    ListNode dummyHead=new ListNode(-1);
    ListNode cur=dummyHead;

    while(!queue.isEmpty()){
        ListNode tmp=queue.poll();
        cur.next=tmp;
        cur=tmp;
        //看看该结点是否有下一个结点，这样就确保所有的元素都加入优先队列中了。
        if (tmp.next != null){
            queue.add(tmp.next);
        }
    }
    cur.next=null;

    ListNode retNode=dummyHead.next;
    dummyHead=null;

    return retNode;
}
```

### 692
[692 Top K Frequent Words](https://leetcode.com/problems/top-k-frequent-words/)
```java
public List<String> topKFrequent(String[] words, int k) {
    List<String> res=new ArrayList<>();
    PriorityQueue<Pair> pq=new PriorityQueue<>(new Comparator<Pair>() {
        @Override
        public int compare(Pair p1, Pair p2) {
            //先按照词频进行升序排列
            int num=p1.freq-p2.freq;
            //再按照word种地字母顺序进行排序
            int num2=(num==0)?p2.word.compareTo(p1.word):num;
            return num2;
        }
    });

    //统计单词及词频
    HashMap<String,Integer> map=new HashMap<>();
    for(String word:words){
        int freq=map.getOrDefault(word,0);
        map.put(word,++freq);
    }

    for(String word:map.keySet()){
        pq.add(new Pair(word,map.get(word)));
        if (pq.size() > k){
            pq.poll();
        }
    }

    while(!pq.isEmpty()){
        Pair p=pq.poll();
        res.add(p.word);
    }
    Collections.reverse(res);
    return res;
}

//封装单词和对应的词频
private class Pair{
    String word;
    int freq;
    public Pair(String word,int freq){
           this.word=word;
           this.freq=freq;
    }
}
```

## 更多和栈相关的问题
### 133
[133 Clone Graph](https://leetcode.com/problems/clone-graph/)
```java
/**
* 思路一:BFS
*/
public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
    if(node==null){
        return null;
    }
    Map<UndirectedGraphNode, UndirectedGraphNode> map=
            new HashMap<UndirectedGraphNode, UndirectedGraphNode>();
    Queue<UndirectedGraphNode> q=new LinkedList<>();
    UndirectedGraphNode newNode=new UndirectedGraphNode(node.label);
    map.put(node,newNode);
    q.add(node);
    while(!q.isEmpty()){
        UndirectedGraphNode curNode=q.poll();
        List<UndirectedGraphNode> curNeightbors=curNode.neighbors;
        for(UndirectedGraphNode neighbor:curNeightbors){
            if(map.containsKey(neighbor)){
                map.get(curNode).neighbors.add(map.get(neighbor));
            }else{
                UndirectedGraphNode newNode2=new UndirectedGraphNode(neighbor.label);
                map.put(neighbor,newNode2);
                map.get(curNode).neighbors.add(newNode2);
                q.add(neighbor);
            }
        }
    }
    return newNode;
}
```

```java
/**
* 思路二：DFS
*/
Map<UndirectedGraphNode, UndirectedGraphNode> map=
        new HashMap<UndirectedGraphNode, UndirectedGraphNode>();
public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
    if(node==null){
        return null;
    }
    //不访问重复的顶点
    if(map.containsKey(node)){
        return map.get(node);
    }
    UndirectedGraphNode newNode=new UndirectedGraphNode(node.label);
    map.put(node,newNode);
    for(UndirectedGraphNode neighbor: node.neighbors){
        newNode.neighbors.add(cloneGraph(neighbor));
    }
    return newNode;
}
```

### 856 
[856 Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/)

* 解题思路一：
```java
/**
 * 思路一：
 * 用栈解决的话，如果遇到左括号，则入栈。
 * 如果遇到右括号，判断栈顶是不是右括号，如果是则说明是()，出栈并压数字1；
 * 否则说明是(A)型，将内部数字全部加起来的和*2，得到的结果再次入栈。
 * 最后栈内是各种数字，加起来就可以了。
 */
public int scoreOfParentheses(String S) {
    int res=0;
    Stack<String> s=new Stack<>();
    for(int i=0;i<S.length();i++){
        String c=S.charAt(i)+"";
        if("(".equals(c)) {
            s.push("(");
        }else{
            if (!s.isEmpty() && s.peek().equals("(")){
                s.pop();
                s.push("1");
            }else {
                int subSum=0;
                while (!s.isEmpty() && !s.peek().equals("(")) {
                    String num = s.pop();
                    subSum += Integer.parseInt(num);
                }
                //将对应的“（”删除
                if (!s.isEmpty()) {
                    s.pop();
                }
                s.push(subSum * 2 + "");
            }
        }
    }
    while (!s.isEmpty()){
        String num=s.pop();
        res+=Integer.parseInt(num);
    }
    return res;
}
```
* 解题思路二：
```java
/**
 * 思路二：
 * "(()(()))" -->转化为："(())"+"((()))" --> 计算 2^(2-1) + 2^(3-1)
 * "(()(()()))" --> 转换为："(())"+"((()))"+"((())))" --> 计算 2^(2-1)+2^(3-1)+2^(3-1)
 */
public int scoreOfParentheses(String S) {
    int res = 0;
    //记录"("的数量
    int balance = 0;
    for(int i=0;i<S.length();i++){
        char c=S.charAt(i);
        if(c=='('){
            balance++;
        }else{
            balance--;
            if(S.charAt(i-1)=='('){
                res+=(1<<balance);
            }
        }
    }
    return res;
}
```
### 227 
[227 Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/)
```java
/**
 * 思路：
 * 关键在于怎么处理乘法和除法，如果是乘法或者除法，我们需要用前面的数和当前的数做运算。
 * 因此此处可以用栈来记录前面的数字，用一个符号变量记录前一个符号，当遍历到一个新数字时，
 * 判断一下前面的符号是什么，如果是乘除，就和前面的数字运算，
 * 如果是+，就向栈中push这个数字，如果是-，就push这个数字的负数。
 * 遍历到结尾，把最后一个数字入栈，此时栈中存放的都是要进行加法运算的数字。
 */
public int calculate(String s) {
    if(s==null || s.length()==0){
        return 0;
    }
    //stack存储的是数字，其中的所有数组只要进行加法即可。
    Stack<Integer> stack=new Stack<>();;

    //"351"这样的字符串，使用num保存各位数据
    int num=0;
    char op='+';
    //用一个符号变量记录前一个符号
    for(int i=0;i<s.length();i++){
        char c=s.charAt(i);
        if(Character.isDigit(c)){
            num=num*10+(c-'0');
        }
        if((!Character.isDigit(c) && c!=' ') || (i==s.length()-1)){
            //(i==s.length()-1)是数字，是要进行入栈处理的
            if(op=='+'){
                stack.push(num);
            }else if(op=='-'){
                stack.push(-num);
            }else if(op=='*'){
                stack.push(stack.pop()*num);
            }else if(op=='/'){
                stack.push(stack.pop()/num);
            }
            op=c;
            num=0;
        }
    }
    int res=0;
    while (!stack.isEmpty()) {
        res += stack.pop();
    }
    return res;
}
```

### 901
[901 Online Stock Span](https://leetcode.com/problems/online-stock-span/)
```java
class StockSpanner {
    private Stack<Pair<Integer,Integer>> stack;

    public StockSpanner() {
        stack=new Stack<>();
    }

    public int next(int price) {
        if(stack.isEmpty() || stack.peek().getKey()>price){
            stack.push(new Pair<>(price,1));
            return 1;
        }
        int cnt=1;
        while(!stack.isEmpty() && stack.peek().getKey()<=price){
            cnt+=stack.pop().getValue();
        }
        stack.push(new Pair<>(price,cnt));
        return cnt;
    }
}
```

## 更多和队列相关的问题
### 622
[622 Design Circular Queue](https://leetcode.com/problems/design-circular-queue/)

[参考数据结构-队列笔记](https://github.com/DuHouAn/Java-Notes/blob/master/DataStructureNotes/notes/01栈和队列.md)

```java
class MyCircularQueue {
        private int[] data;

        //front==tail 队列为空
        //(tail+1)/data.length==front队列为空
        private int front,tail;
        private int size;

        /** Initialize your data structure here. Set the size of the queue to be k. */
        public MyCircularQueue(int k) {
            //损失一个1单位，用来区分队列是满的还是空的
            data=new int[k+1];
            front=0;
            tail=0;
            size=0;
        }

        /** Insert an element into the circular queue. Return true if the operation is successful. */
        public boolean enQueue(int value) {
            //先判断队列是否满了
            if(isFull()){
                return false;
            }
            data[tail]=value;
            tail=(tail+1)%data.length;
            size++;
            return true;
        }

        /** Delete an element from the circular queue. Return true if the operation is successful. */
        public boolean deQueue() {
            if(isEmpty()){
                return false;
            }
            //E保存出队的元素
            int E=data[front];
            front=(front+1)%data.length;
            size--;
            return true;
        }

        /** Get the front item from the queue. */
        public int Front() {
            if(isEmpty()){
                return -1;
            }
            return data[front];
        }

        /** Get the last item from the queue. */
        public int Rear() {
            if(isEmpty()) {
                return -1;
            }
            //注意这是循环队列，tail的值是循环变化的
            return data[(tail+data.length-1)%data.length];
        }

        /** Checks whether the circular queue is empty or not. */
        public boolean isEmpty() {
            return front==tail;
        }

        /** Checks whether the circular queue is full or not. */
        public boolean isFull() {
            return (tail+1)%data.length==front;
        }
    }
```