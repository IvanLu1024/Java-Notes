# Spring 事务管理

## 事务属性

事务属性可以理解成事务的一些基本配置，描述事务策略如何应用到方法上。

事务属性包含了 5 个方面：

- 传播行为
- 隔离级别
- 是否只读事务
- 事务超时
- 回滚规则

### 1、传播行为

当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。

事务传播行为：**用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的事务时如何传播**。

Spring中有七种事务传播类型：

|                   类型                   |                             说明                             |
| :--------------------------------------: | :----------------------------------------------------------: |
|     PROPAGATION_REQUIRED（required）     | 表示**当前方法必须运行在事务中**。<br>如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务。 |
|     PROPAGATION_SUPPORTS（support）      |   表示支持当前事务，如果当前没有事务，就以无事务方式执行。   |
|    PROPAGATION_MANDATORY（mandatory）    |      表示使用当前的事务，如果当前没有事务，就抛出异常。      |
| PROPAGATION_REQUIRES_NEW（required_new） |       表示新建事务，如果当前存在事务，把当前事务挂起。       |
| PROPAGATION_NOT_SUPPORTED（not_support） | 表示以无事务方式执行操作，如果当前存在事务，就把当前事务挂起。 |
|        PROPAGATION_NEVER（never）        |     表示以无事务方式执行，如果当前存在事务，则抛出异常。     |
|       PROPAGATION_NESTED（nested）       | 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 |

### 2、隔离级别

事务隔离级别是指多个事务之间的隔离程度。

TransactionDefinition 接口中定义了五个表示隔离级别的常量：

|                隔离级别                |                             说明                             |
| :------------------------------------: | :----------------------------------------------------------: |
|       ISOLATION_DEFAULT（默认）        |        这是默认值，表示使用底层数据库的默认隔离级别。        |
| ISOLATION_READ_UNCOMMITTED（读未提交） | 该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据，该级别不能防止脏读和不可重复读，因此很少使用该隔离级别 |
|  ISOLATION_READ_COMMITTED（读可提交）  | 该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值 |
| ISOLATION_REPEATABLE_READ（可重复读）  | 该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读 |
|   ISOLATION_SERIALIZABLE（可串行化）   | 所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是，这将严重影响程序的性能，通常情况下也不会用到该级别 |

### 3、是否只读事务

如果事务只对后端的数据库进行操作，数据库可以利用事务的只读特性来进行一些特定的优化。

### 4、事务超时

为了使应用程序很好地运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，所以长时间的事务会不必要的占用数据库资源。

事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自然回滚，而不是一直等待其结束。

### 5、回滚规则

这些规则定义了哪些异常会导致事务回滚哪些不会。

默认情况下，事务只有遇到运行期异常事时才回滚，而在遇到检查型异常时不会回滚，但是我们可以声明事务在遇到特殊性的检查型异常时像遇到运行期异常那样回滚。同样，我们也可以声明遇到特定的异常不回滚，及时这些异常时运行期异常。



## Spring事务管理

Spring 的事务有两种类型：

- 全局事务（分布式事务）
- 局部事务（单机事务）

我们平时常用的是单机事务，也就是操作一个数据库的事务。

按照使用方式来分，又可以分为编程式事务（TransactionTemplate）和声明式事务（@Transactional注解）：

- 编程式事务
- 声明式事务

### 编程式事务

编程式事务指的是通过编码方式实现事务，类似 JDBC 编程实现事务管理。

### 声明式事务

声明式事务实现方式：

- XML 实现
-  @Transactional 注解实现

常使用的 @Transactional 注解方式来使用事务，比编程式方式方便得多。

声明式事务主要是利用了[AOP 原理](https://duhouan.github.io/Java-Notes/#/./Spring/02SpringAOP)来实现了这个功能，对于 @Transactional 修饰的方法，Spring 会为其创建一个**代理对象**，这个代理对象中就会有事务开启、提交、回滚等逻辑。

### 编程式和声明式的对比

|    类型    |         优点         |               缺点               |
| :--------: | :------------------: | :------------------------------: |
| 编程式事务 |  显式调用，不易出错  |       侵入式代码，编码量大       |
| 声明式事务 | 简洁，对代码侵入性小 | 隐藏了实现细节，出现问题不易定位 |

### Spring 事务管理

Spring 对事务管理是通过**事务管理器**实现的，Spring 提供了许多内置事务管理器实现。

Spring 事务管理器的接口是  PlatformTransactionManager，我们在使用的时候，只需要通过 Spring IoC，告诉Spring，要注入哪个 TransactionManager，要使用哪种策略即可。

具体的事务管理机制对 Spring 来说是透明的，而具体的事务管理机制是各个平台（如 JDBC 等）自己处理。

Spring 事务管理机制的提个优点就是为不同事务的 API 提供一致的编程模型。

## 补充资料

- [使用方式](https://juejin.im/post/5b010f27518825426539ba38)

- [使用@Transactional注解可能会遇到的问题](<https://zhuanlan.zhihu.com/p/38208248>)

# 参考资料

https://zhuanlan.zhihu.com/p/38772486

https://zhuanlan.zhihu.com/p/41864893

https://segmentfault.com/a/1190000013341344

- [全面分析 Spring 的编程式事务管理及声明式事务管理](https://www.ibm.com/developerworks/cn/education/opensource/os-cn-spring-trans/index.html)

