# [第四章 栈、队列、优先队列](#栈_队列_优先队列)

| 章节 | 典型题目 | 相关题目 | 更多扩展练习 | 难题推荐 |
| :---: | :---: | :---: | :---: | :---: |
| [4-1 栈的基础应用 Valid Parentheses](#栈的基础应用) | [20](#20) | [150](#150) [71](#71) | [735](#735) | |
| [4-2 栈和递归的紧密关系 Binary Tree Preorder, Inorder and Postorder Traversal](#栈和递归的紧密关系) | [144](#144) [94](#94) [145](#145) | [无] | | |
| [4-3 运用栈模拟递归](#运用栈模拟递归) | [144](#144) [94](#94) [145](#145) | [341](#341) | [388](#388) | |
| [4-4 队列的典型应用 Binary Tree Level Order Traversal](#队列的典型应用) | [102](#102) [232](#232) | [107](#107) [103](#103) [199](#199) |  [637](#637) | |
| [4-5 BFS和图的最短路径 Perfect Squares](#BFS和图的最短路径) | [279](#279) | [127](#127) [126*](#126)  | [752](#752) | 675 |
| [4-6 优先队列](#优先队列) | [无] | [无] | | |
| [4-7 优先队列相关的算法问题 Top K Frequent Elements](#优先队列相关的算法问题) | [347](#347) | [23](#23) | [692](#692) | 23 239 786 857 |
| [补充1：更多和栈相关的问题](#更多和栈相关的问题) | [无] | [无] | [133*] 856 227  901 | 224 282 772 |
| [补充2：更多和队列相关的问题](#更多和队列相关的问题) | [无] | [无] | 490 622 | |


# 栈_队列_优先队列
## 栈的基础应用
### 20
[20 Valid Parentheses](https://leetcode.com/problems/valid-parentheses/description/)

* 问题：

给定一个字符串，只包含(,){,},[,],判定字符串找那个的括号是否合法。

* 示例：

"()"、"()[]{}"是合法的

"(])"、"([)]])"就是非法的

* 解题：

利用栈的思路：

（1）是左方向的括号，就直接入栈

（2）右方向的括号，就拿出站定元素与之对比，匹配就弹出

```java
public boolean isValid(String s) {
    Stack<Character> stack=new Stack<>();
    for(int i=0;i<s.length();i++) {
        char c = s.charAt(i);
        if (c == '(' || c == '{' || c == '[') {
            stack.push(c);
        } else {
            if (stack.empty()) {
                return false;
            }

            char match;
            if (c == ')') {
                match = '(';
            } else if (c == '}') {
                match = '{';
            } else {
                assert c == ']';
                match = '[';
            }

            char topChar = stack.pop();
            if (topChar != match) {
                return false;
            }
        }
    }
    //注意有可能，这个栈放入的都是左方向的括号，此时直接返回 true是不对的
    if(!stack.empty()){
        return false;
    }
    return true;
}
```
### 150
[150 Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/description/)
```java
public int evalRPN(String[] tokens) {
    if(tokens.length==1){
        return Integer.parseInt(tokens[0]);
    }
    Stack<String> stack=new Stack<>();
    for(String ele : tokens) {
        switch (ele){
            case "+":
                String num1 = stack.pop();
                String num2 = stack.pop();
                String num3 = Integer.parseInt(num2) + Integer.parseInt(num1) + "";
                stack.push(num3);
                break;
            case "-":
                String num4 = stack.pop();
                String num5 = stack.pop();
                String num6 = Integer.parseInt(num5) - Integer.parseInt(num4) + "";
                stack.push(num6);
                break;
            case "*":
                String num7 = stack.pop();
                String num8 = stack.pop();
                String num9 = Integer.parseInt(num8) * Integer.parseInt(num7) + "";
                stack.push(num9);
                break;
            case "/":
                String num10 = stack.pop();
                String num11 = stack.pop();
                String num12 = Integer.parseInt(num11) / Integer.parseInt(num10) + "";
                stack.push(num12);
                break;
            default:
                stack.push(ele);
                break;
        }
    }
    return Integer.parseInt(stack.pop());
}
```
### 71
[71 Simplify Path](https://leetcode.com/problems/simplify-path/description/)
```java
/**
 * 思路：
 * 字符串处理，由于".."是返回上级目录（如果是根目录则不处理），因此可以考虑用栈记录路径名，以便于处理。
 * 需要注意几个细节：
 *1、何时出栈？
 * "../ "代表回上一级目录，那么把栈定元素出栈
 *
 * 2、何时
 * 如果遇到不是 "."，也不是""，不是".."，那么进栈
 * "" 针对的是 // 这种情况。
 */
public String simplifyPath(String path) {
    String[] paths=path.split("/");

    Stack<String> stack=new Stack<>();
    for(String p:paths){
        //出栈的时候要保证栈是非空的
        if("..".equals(p) && !stack.empty()){
            stack.pop();
        }
        //注意条件是使用 && 进行连接的 
        if(! "..".equals(p) && !"".equals(p) && !".".equals(p)){
            stack.push(p);
        }
    }
    return "/"+String.join("/",stack);
}
```

### 735
[735 Asteroid Collision](https://leetcode.com/problems/asteroid-collision/)
```java
/**
 * 思路：
 * 利用stack存储，每次对比栈顶元素（相同的话就放入栈中），否则就对比，直至栈顶相同为止
 * 注意：当栈顶为负数时，直接进栈。
 * 只有当栈顶为正数才需要发生碰撞
 */
public int[] asteroidCollision(int[] asteroids) {
    if(asteroids==null || asteroids.length==0){
        return new int[]{};
    }
    if(asteroids.length==1){
        return new int[]{asteroids[0]};
    }
    Stack<Integer> stack=new Stack<>();
    for(int i=0;i<asteroids.length;i++){
        //栈为空或者入栈元素 > 0则直接加入栈中
        if(stack.isEmpty() || asteroids[i]>0){
            stack.push(asteroids[i]);
            continue;
        }
        //处理 asteroids[i]<0的情况
        while(true){
            //获取栈顶元素
            int top=stack.peek();
            //栈顶元素<0,那么就不会碰撞，直接入栈即可
            if(top<0){
                stack.push(asteroids[i]);
                break;
            }
            //栈顶元素>0的情况
            if(top==-asteroids[i]){
                //相等，则碰撞后，两颗行星都会消失：asteroids[i]不能插入，栈顶元素出栈
                stack.pop();
                break;
            }else if(top>-asteroids[i]){
                //相撞后，top方向质量更大：asteroids[i]不能插入
                break;
            }else{
                //相撞后，asteroids[i]方向质量更大：将top出栈，将asteroids[i]插入
                stack.pop();
                if(stack.isEmpty()){
                    //栈为空说明asteroids[i]是质量最大的
                    stack.push(asteroids[i]);
                    break;
                }
            }
        }
    }

    int [] res=new int[stack.size()];
    int i=stack.size()-1;
    while(!stack.empty()){
        res[i--]=stack.pop();
    }
    return res;
}
```

## 栈和递归的紧密关系
### 144
[144 Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/description/)

* 解题：

使用栈模拟系统栈，解决前序遍历的问题。

（1）将头结点压入栈中，对栈进行初始化，go-1表示访问1结点

<div align="center"><img src="pics//stackQueue//stack_1.png"/></div>

（2）由于先序遍历，根据栈的特性，先访问1的右子节点，再访问1的左子节点，最后访问1结点

<div align="center"><img src="pics//stackQueue//stack_2.png"/></div>

（3）1结点是栈顶元素，由于命令是cout，cout 1出栈，所以直接输出节点值1

<div align="center"><img src="pics//stackQueue//stack_3.png"/></div>

（4）此时go 1-L是栈顶元素,就访问1结点的左孩子节点，也就是节点2

<div align="center"><img src="pics//stackQueue//stack_4.png"/></div>

（5）这时候访问结点2，再访问2的右子树的根节点和2的左子树的根节点，最后再访问2节点

<div align="center"><img src="pics//stackQueue//stack_5.png"/></div>

（6）栈顶是 cout-2，输出结果后，栈顶元素是 go-2-L==null,go-2-R==null，do nothing

<div align="center"><img src="pics//stackQueue//stack_6.png"/></div>

(7)访问到3结点

<div align="center"><img src="pics//stackQueue//stack_7.png"/></div>

（8）最终栈为空

```java
private enum Command{GO,PRINT};

private class StackNode{
    Command command;
    TreeNode node;
    StackNode(Command command,TreeNode node){
        this.command=command;
        this.node=node;
    }
}

public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> ret=new ArrayList<>();
    if(root==null){
        return ret;
    }
    Stack<StackNode> stack=new Stack<>();
    stack.push(new StackNode(Command.GO,root));
    while(!stack.empty()){
        StackNode stackNode=stack.pop();
        Command command=stackNode.command;
        if(command==Command.PRINT){
            ret.add(stackNode.node.val);
        }else{
            if(stackNode.node.right!=null){
                stack.push(new StackNode(Command.GO,stackNode.node.right));
            }
            if(stackNode.node.left!=null){
                stack.push(new StackNode(Command.GO,stackNode.node.left));
            }
            stack.push(new StackNode(Command.PRINT,stackNode.node));
        }
    }
    return ret;
}
```
### 94
[94 Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/description/)
```java
private enum Command{GO,PRINT};

private class StackNode{
    Command command;
    TreeNode node;
    StackNode(Command command, TreeNode node){
        this.command=command;
        this.node=node;
    }
}

public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> ret=new ArrayList<>();
    if(root==null){
        return ret;
    }

    Stack<StackNode> stack=new Stack<>();
    stack.push(new StackNode(Command.GO,root));
    while(!stack.empty()){
        StackNode stackNode=stack.pop();
        Command command=stackNode.command;
        if(command==Command.PRINT){
            ret.add(stackNode.node.val);
        }else{
            if(stackNode.node.right!=null){
                stack.push(new StackNode(Command.GO,stackNode.node.right));
            }
            stack.push(new StackNode(Command.PRINT,stackNode.node));
            if(stackNode.node.left!=null){
                stack.push(new StackNode(Command.GO,stackNode.node.left));
            }
        }
    }
    return ret;
}
```
### 145
[145 Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/description/)
```java
private enum Command{GO,PRINT};

private class StackNode{
    Command command;
    TreeNode node;
    StackNode(Command command,TreeNode node){
        this.command=command;
        this.node=node;
    }
}

public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> ret=new ArrayList<>();
    if(root==null){
        return ret;
    }
    Stack<StackNode> stack=new Stack<>();
    stack.push(new StackNode(Command.GO,root));
    while(!stack.empty()){
        StackNode stackNode=stack.pop();
        Command command=stackNode.command;
        if(command==Command.PRINT){
            ret.add(stackNode.node.val);
        }else{
            stack.push(new StackNode(Command.PRINT,stackNode.node));
            if(stackNode.node.right!=null){
                stack.push(new StackNode(Command.GO,stackNode.node.right));
            }
            if(stackNode.node.left!=null){
                stack.push(new StackNode(Command.GO,stackNode.node.left));
            }
        }
    }
    return ret;
}
```
## 运用栈模拟递归
### 341
[341 Flatten Nested List Iterator](https://leetcode.com/problems/flatten-nested-list-iterator/description/)
```java
/**
 * 思路:
 * 先把list中所有的元素都倒序push进stack，
 * 然后每次遇到不是integer的，就重复第一个过程，把list里的元素按照倒序push进stack，直到stack为空。
 */
public class NestedIterator implements Iterator<Integer> {
    Stack<NestedInteger> stack;

    public NestedIterator(List<NestedInteger> nestedList) {
        stack=new Stack<>();
        for(int i=nestedList.size()-1;i>=0;i--){
            NestedInteger tmp=nestedList.get(i);
            stack.push(tmp);
        }
    }

    @Override
    public Integer next() {
        return stack.pop().getInteger();
    }

    @Override
    public boolean hasNext() {
        while (!stack.isEmpty()){
            NestedInteger cur=stack.peek();
            if(cur.isInteger()){
                return true;
            }else{
                //将该cur出栈
                stack.pop();
                List<NestedInteger> tmpList=cur.getList();
                for(int i=tmpList.size()-1;i>=0;i--){
                    stack.push(tmpList.get(i));
                }
            }
        }
        return false;
    }
}
```
### 388
[388 Longest Absolute File Path](https://leetcode.com/problems/longest-absolute-file-path/)
```java
/**
 * 思路：
 * 该字符串中包含\n和\t这种表示回车和空格的特殊字符，让我们找到某一个最长的绝对文件路径。
 * 要注意的是，最长绝对文件路径不一定是要最深的路径。
 * 我们可以用哈希表来建立深度和当前深度的绝对路径长度之间的映射，
 * 那么当前深度下的文件的绝对路径长度就是文件名长度加上哈希表中当前深度对应的长度，
 * 我们的思路是遍历整个字符串，遇到\n或者\t就停下来，然后我们判断，
 * 如果遇到的是回车:
 * 我们把这段文件名提取出来，如果里面包含"."，说明是文件，我们更新res长度，
 * 如果不包含点“.”，说明是文件夹，我们深度level自增1，然后建立当前深度和总长度之间的映射，然后我们将深度level重置为0。
 *
 * 如果遇到的是空格\t，
 * 那么我们深度加1，
 * 通过累加\t的个数，我们可以得知当前文件或文件夹的深度，然后做对应的处理。
 */
public int lengthLongestPath(String input) {
    int res = 0;
    //<深度,当前深度的绝对路径长度>
    Map<Integer, Integer> map = new HashMap<>();
    map.put(0, 0);
    //根据\n切分文件
    String[] arr=input.split("\n");
    //以"dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext"为例
    //arr={"dir","\tsubdir1","\t\tfile1.ext","\t\tsubsubdir1","\tsubdir2","\t\tsubsubdir2","\t\t\tfile2.ext"}
    if(arr!=null){
        for (String s : arr) {
            //根据 \t的位置看看有几层
            int level = s.lastIndexOf("\t") + 1;
            //s.substring(level)-->s就是文件夹或者我呢见
            int len = s.substring(level).length();
            if (s.contains(".")) {
                //包含“.”，说明是文件，那么就要更新最大值-->说明到达该层的文件
                //get(level)是该文件前一层的绝对路径长度
                //len是文件路径长度
                res = Math.max(res, map.get(level) + len);
            } else {
                //+1是算上"/"的长度
                map.put(level + 1, map.get(level) + len + 1);
            }
        }
    }
    return res;
}
```
# 队列
## 队列的典型应用
### 102
[102 Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/description/)

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> ret=new ArrayList<>();
    if(root==null){
        return ret;
    }

    Queue<Pair<TreeNode,Integer>> queue=new LinkedList<>();
    queue.add(new Pair<TreeNode,Integer>(root,0));
    //root结点对应的是0层
    while(!queue.isEmpty()){
        Pair pair=queue.poll();
        TreeNode node= (TreeNode) pair.getKey();
        int level= (int) pair.getValue();

        if(level==ret.size()){
            //因为level是从0开始的，当level=ret.size()表示需要新创建 List，来存储level层的元素
            ret.add(new ArrayList<>());
        }
        //ret.get(level)表示的是level层
        ret.get(level).add(node.val);

        if(node.left!=null){
            queue.add(new Pair<TreeNode,Integer>(node.left,level+1));
        }
        if(node.right!=null){
            queue.add(new Pair<TreeNode,Integer>(node.right,level+1));
        }
    }
    return ret;
}
```
### 232
[232 Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/description/)

* 解法一：
```java
/**
 * 思路一：
 * 使用一个栈来存储数据
 * 在push时使用另外一个栈进行转换
 * 使之符合队列FIFO的特性
 */
class MyQueue {
    Stack<Integer> s;

    /** Initialize your data structure here. */
    public MyQueue() {
       s=new Stack<>();
    }

    /** Push element x to the back of queue. */
    public void push(int x) {
        Stack<Integer> s2=new Stack<>();
        //先将s中元素放入s2中
        while(!s.isEmpty()){
            s2.push(s.pop());
        }
        s.push(x);
        //再将s2中元素放入s中
        while(!s2.isEmpty()){
            s.push(s2.pop());
        }
    }

    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        return s.pop();
    }

    /** Get the front element. */
    public int peek() {
        return s.peek();
    }

    /** Returns whether the queue is empty. */
    public boolean empty() {
        return s.isEmpty();
    }
}
```
* 解法二：
```java
/**
 * 思路二：
 * 准备两个栈
 * 一个栈s1用于入队操作，若栈为空，此时进入的元素就是队首元素
 * 一个栈s2用于出队操作，若栈为空，则将s1中元素压入s2中，弹出s2的栈顶元素即可
 * 和一个front存储队列头元素
 */
class MyQueue {
    //入队操作使用
    private Stack<Integer> s1;
    //出队操作是使用
    private Stack<Integer> s2;
    //存储队列头元素
    private int front;

    /** Initialize your data structure here. */
    public MyQueue() {
        s1=new Stack<>();
        s2=new Stack<>();
    }

    /** Push element x to the back of queue. */
    public void push(int x) {
        //方便后面的peek操作
       if(s1.isEmpty()){
           front=x;
       }
       s1.push(x);
    }

    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        if(s2.isEmpty()){
            while(!s1.isEmpty()){
                s2.push(s1.pop());
            }
        }
        return s2.pop();
    }

    /** Get the front element. */
    public int peek() {
        if(!s2.isEmpty()){
           return s2.peek();
        }
        return front;
    }

    /** Returns whether the queue is empty. */
    public boolean empty() {
        return (s1.isEmpty() && s2.isEmpty());
    }
}
```

### 107
[107 Binary Tree Level Order Traversal II](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/)
```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    List<List<Integer>> ret=new ArrayList<>();
    if(root==null){
        return new ArrayList<>();
    }
    Queue<Pair<TreeNode,Integer>> queue=new LinkedList<>();
    queue.add(new Pair<TreeNode,Integer>(root,0));
    while(!queue.isEmpty()){
        Pair pair=queue.poll();
        TreeNode node=(TreeNode) pair.getKey();
        int level=(int)pair.getValue();
        if(level==ret.size()){
            ret.add(new ArrayList<>());
        }
        ret.get(level).add(node.val);

        if(node.left!=null){
            queue.add(new Pair<TreeNode,Integer>(node.left,level+1));
        }
        if(node.right!=null){
            queue.add(new Pair<TreeNode,Integer>(node.right,level+1));
        }
    }
    Collections.reverse(ret);

    return ret;
}
```
### 103
[103 Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/)
```java
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> ret=new ArrayList<>();
    if(root==null){
        return ret;
    }

    Queue<Pair<TreeNode,Integer>> queue=new LinkedList<>();
    queue.add(new Pair<TreeNode,Integer>(root,0));
    //root结点对应的是0层
    while(!queue.isEmpty()){
        Pair pair=queue.poll();
        TreeNode node= (TreeNode) pair.getKey();
        int level= (int) pair.getValue();

        if(level==ret.size()){
            //因为level是从0开始的，当level=ret.size()表示需要新创建 List，来存储level层的元素
            ret.add(new ArrayList<>());
        }
        //ret.get(level)表示的是level层
        ret.get(level).add(node.val);

        if(node.left!=null){
            queue.add(new Pair<TreeNode,Integer>(node.left,level+1));
        }
        if(node.right!=null){
            queue.add(new Pair<TreeNode,Integer>(node.right,level+1));
        }
    }
    //进行层次遍历后，对于偶数层的数据，进行逆序处理
    int cnt=0;
    for(List<Integer> list:ret){
        if(cnt%2==1){
            Collections.reverse(list);
        }
        cnt++;
    }
    return ret;
}
```
### 199
[199 Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/description/)
```java
public List<Integer> rightSideView(TreeNode root) {
    List<Integer> ret=new ArrayList<>();
    if(root==null){
        return ret;
    }
    Queue<TreeNode> queue=new LinkedList<>();
    queue.add(root);
    
    while(!queue.isEmpty()){
        //nodeNumsEachLevel表示每层的节点数
        int nodeNumsEachLevel=queue.size();
        while(nodeNumsEachLevel>0){
            TreeNode tmp=queue.poll();
            if(tmp.left!=null){
                queue.add(tmp.left);
            }
            if(tmp.right!=null){
                queue.add(tmp.right);
            }
            //每出队一次，该层就减少一个节点
            nodeNumsEachLevel--;
            //nodeNumsEachLevel==0，该层的最右侧节点
            if(nodeNumsEachLevel==0){
                ret.add(tmp.val);
            }
        }
    }
    return ret;
}
```
### 637
[637 Average of Levels in Binary Tree](https://leetcode.com/problems/average-of-levels-in-binary-tree/)
```java
public List<Double> averageOfLevels(TreeNode root) {
    //存储层序遍历各层的元素
    List<List<Integer>> list=new ArrayList<>();
    Queue<Pair> q=new LinkedList<>();
    q.add(new Pair(root,0));
    while(!q.isEmpty()){
        Pair pair=q.poll();
        TreeNode treeNode=pair.treeNode;
        int level=pair.level;
        if(level==list.size()){
            list.add(new ArrayList<>());
        }
        list.get(level).add(treeNode.val);
        if(treeNode.left!=null){
            q.add(new Pair(treeNode.left,level+1));
        }
        if(treeNode.right!=null){
            q.add(new Pair(treeNode.right,level+1));
        }
    }

    List<Double> res=new ArrayList<>();
    if(list.size()==0){
        return res;
    }
    int sum=0;
    for(List<Integer> tmp:list){
        res.add(getAverage(tmp));
    }
    return res;
}

private double getAverage(List<Integer> list){
    //这里要注意 节点值为2147483647相加的情况
    long sum=0L;
    for(Integer num:list){
        sum+=num;
        //[2147483647.0,2147483647.0]
    }
    return (sum*1.0)/list.size();
}

private class Pair{
    TreeNode treeNode;
    int level;
    Pair(TreeNode treeNode,int level){
        this.treeNode=treeNode;
        this.level=level;
    }
}
```

## BFS和图的最短路径
### 279
[279 Perfect Squares](https://leetcode.com/problems/perfect-squares/description/)

* 问题：

给出一个正整数n，寻找最少的完全平方数，使他的平方和为n。

完全平方数：1，4，9，16 ...

* 举例：

12=4+4+4

13=4+9

* 解题：

确定问题：

**没有解怎么办**？ 一定有解，因为1是完全平方数，最差的情况就是n=n个1相加

思路：

1、贪心算法？

使用贪心策略：每次取最大的完全平方数，则12=9+1+1+1，但是12=4+4+4是最终解。

2、对问题建模：将整个问题转化为**图论问题**。

从n到0，每个数字表示一个节点；

如果两个数字x到y相差一个完全平方数，则连接一条边。我们就得到了填个无权图。

那么，原来的问题就转化成，求这个无权图中从n到0的最短路径。

<div align="center"><img src="pics//stackQueue//stack_8.png"/></div>
 
图中1->0的距离是1,2->1的就离是1,
3->2的距离是1，
4->3的距离是1，
4->0的距离是0

<div align="center"><img src="pics//stackQueue//stack_9.png" width="600"/></div>
<div align="center"><img src="pics//stackQueue//stack_10.png" width="600"/></div>
<div align="center"><img src="pics//stackQueue//stack_11.png" width="600"/></div>
<div align="center"><img src="pics//stackQueue//stack_12.png" width="600"/></div>

```java
private class Pair{
    int num;
    //记录节点的数值
    int steps;
    //记录num数值该走几步
    Pair(int num,int steps){
        this.num=num;
        this.steps=steps;
    }
}

public int numSquares(int n) {
    Queue<Pair> queue=new LinkedList<>();
    queue.add(new Pair(n,0));
    
    boolean[] isVisited=new boolean[n+1];
    isVisited[n]=true;

    while(!queue.isEmpty()){
        Pair pair=queue.poll();
        int num=pair.num;
        int steps=pair.steps;
        if(num==0){
            return steps;
        }
        for(int i=1;;i++){
            int tmp=num-i*i;
            if(tmp<0){
                break;
            }
            if(!isVisited[tmp]){
                queue.add(new Pair(tmp,steps+1));
                isVisited[tmp]=false;
            }
        }
    }
    //如果结果不存在，就返回0
    return 0;
}
```
### 127
[127 Word Ladder](https://leetcode.com/problems/word-ladder/description/)
```java
/**
 * BFS
 * 将这个问题看成图问题:
 * word1-->word2 的路径就是word1和word2 "相似"（word1和wordd2根据题目规则可以相互转化）
 * 最后从beginWord走到endWord.
 */
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    //使用set去除重复元素-->BFS更高效
    Set<String> wordSet=new HashSet<>();
    for(String word:wordList){
        wordSet.add(word);
    }

    //存储已经访问过的节点，保证下次不会再走了
    Set<String> visited = new HashSet<>();

    //从beginWord开始进行BFS
    Queue<Pair> q=new LinkedList<>();
    //从 begin开始，走的是第一步
    q.add(new Pair(beginWord,1));
    while (!q.isEmpty()){
        Pair p=q.poll();
        //访问当前节点
        String curWord=p.word;
        int curStep=p.step;
        visited.clear();
        //看下一个节点的情况
        for(String word:wordSet){
            if(isSimilar(curWord,word)){ //isSimilar(curWord,word) 说明beginWod-->word有路径
                if(word.equals(endWord)){
                    return curStep+1;
                }
                //将word加入队列，即访问了word
                q.add(new Pair(word,curStep+1));
                visited.add(word);
            }
        }
        //删除已经访问过的节点
        for(String w:visited){
            wordSet.remove(w);
        }
    }
    return 0;
}

private class Pair{
    String word;
    int step;
    Pair(String word,int step){
        this.word=word;
        this.step=step;
    }
}

//判断word1和word2是否相似，即word1和word是否可以相互转化
private boolean isSimilar(String word1,String word2){
    if(word1.length()!=word2.length() || word1.equals(word2)){
        return false;
    }
    int diff=0;
    for(int i=0;i<word1.length();i++){
        if(word1.charAt(i)!=word2.charAt(i)){
            diff++;
        }
        if(diff>1){
            return false;
        }
    }
    return true;
}
```
### 126
[126 Word Ladder II](https://leetcode.com/problems/word-ladder-ii/description/)
```java

```

### 752
[752 Open the Lock](https://leetcode.com/problems/open-the-lock/)
```java
public int openLock(String[] deadends, String target) {
    Set<String> deadSet=new HashSet<>();
    for(String deadend:deadends){
        deadSet.add(deadend);
    }

    if(deadSet.contains(target) || deadSet.contains("0000")){
        return -1;
    }

    Set<String> visited=new HashSet<>();
    Queue<Pair> q=new LinkedList<>();
    q.add(new Pair("0000",0));
    visited.add("0000");
    while(!q.isEmpty()){
        Pair p=q.poll();
        String curS=p.s;
        int curTurn=p.turn;
        Set<String> next=getNextLock(curS,deadSet);
        for(String lock:next){
            if(!visited.contains(lock)){
                if(target.equals(lock)){
                    return curTurn+1;
                }
                visited.add(lock);
                q.add(new Pair(lock,curTurn+1));
            }
        }
    }
    return -1;
}

//锁的密码是s时，获取下一个有可能的锁密码
private Set<String> getNextLock(String s,Set<String> deadends){
    Set<String> res=new HashSet<>();
    assert s.length()==4;
    for(int i=0;i<4;i++){
        int num = s.charAt(i)- '0';
        int d = num + 1;
        if(d > 9) d = 0;
        String t=s.substring(0,i)+((char) (d+'0'))+s.substring(i+1,4);
        if(!deadends.contains(t)){
            res.add(t);
        }
        d=num-1;
        if(d < 0) d = 9;
        t=s.substring(0,i)+((char) (d+'0'))+s.substring(i+1,4);
        if(!deadends.contains(t)){
            res.add(t);
        }
    }
    return res;
}

private class Pair{
    String s;
    int turn;
    Pair(String s,int turn){
        this.s=s;
        this.turn=turn;
    }
}
```


## 优先队列
* [堆的底层实现，白板编程](https://github.com/DuHouAn/DataStructureNotes/blob/master/src/code_01_heap/MaxHeap.java)

* Java中优先队列的使用
```java
public class PriorityQueueUsing {
    public static void main(String[] args) {
        Random random=new Random();

        //Java语言，默认情况下是最小堆
        PriorityQueue<Integer> pq=new PriorityQueue<>();
        for(int i=0;i<10;i++){
            int num=random.nextInt(100)+1;
            //产生[1,100]之间的随机数
            System.out.println("insert "+num+" into priority queue.");
            pq.add(num);
        }
        while(!pq.isEmpty()){
            int num=pq.poll();
            System.out.print(num+" ");
        }
        System.out.println();

        //底层使用最小堆
        PriorityQueue<Integer> pq2=new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                int num=o2-o1;
                return num;
            }
        });
        for(int i=0;i<10;i++){
            int num=random.nextInt(100)+1;
            //产生[1,100]之间的随机数
            System.out.println("insert "+num+" into priority queue.");
            pq2.add(num);
        }
        while(!pq2.isEmpty()){
            int num=pq2.poll();
            System.out.print(num+" ");
        }
        System.out.println();

        //自定义Comparator的优先队列
        PriorityQueue<Integer> pq3=new PriorityQueue<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                int num=o2%10-o1%10;
                //这里是按照个位上的数字，得到的最大堆
                return num;
            }
        });
        for(int i=0;i<10;i++){
            int num=random.nextInt(100)+1;
            //产生[1,100]之间的随机数
            System.out.println("insert "+num+" into priority queue.");
            pq3.add(num);
        }
        while(!pq3.isEmpty()){
            int num=pq3.poll();
            System.out.print(num+" ");
        }
        System.out.println();
    }
}
```

## 优先队列相关的算法问题
### 347
[347 Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/description/)

* 问题：

给定一个非空数组，返回前k个出现频率最高的元素。

* 示例：

给定[1,1,1,2,2,3],k=2

返回[1,2]

* 解题：

1、确定问题：

k的合法性问题

2、思路一：

扫描一遍统计频率；

排序找到前k个出现频率最高的元素。

时间复杂度O(n log n)

3、思路二：

维护一个优先队列

时间复杂度O(n log k)

```java
private class Pair implements Comparable<Pair> {
    int numFreq;
    int num;
    Pair(int numFreq,int num){
        this.numFreq=numFreq;
        this.num=num;
    }

    @Override
    public int compareTo(Pair o) {
        return this.numFreq-o.numFreq;
    }
}

public List<Integer> topKFrequent(int[] nums, int k) {
    //统计数字出现的频率
    Map<Integer,Integer> map=new HashMap<>();
    for(int num:nums){
        int freq=map.get(num)==null?0:map.get(num);
        map.put(num,++freq);
    }

    //维护一个优先队列，最小堆，维护当前频率最高的元素
    PriorityQueue<Pair> priorityQueue=new PriorityQueue<>();
    //pair存的是（频率，元素）的形式
    for(Integer num:map.keySet()){
        int numFreq=map.get(num);
        if(priorityQueue.size()==k){
            if(numFreq>priorityQueue.peek().numFreq){
                priorityQueue.poll();
                priorityQueue.add(new Pair(numFreq,num));
            }
        }else{
            priorityQueue.add(new Pair(numFreq,num));
        }
    }

    List<Integer> ret=new ArrayList<>();
    while(!priorityQueue.isEmpty()){
        ret.add(priorityQueue.poll().num);
    }
    return ret;
}
```
### 23
[23 Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/description/)
```java
//思路一：逐步合并有序链表,n是数组长度，K是数组中的链表平均长度
//时间复杂度：O(n*K)
//空间复杂度：O(1)
public ListNode mergeKLists(ListNode[] lists) {
    if(lists==null || lists.length==0){
        return null;
    }

    //将该数组中元素逐步合并
    ListNode head=lists[0];
    for(int i=1;i< lists.length;i++){
        head=mergeTwoLists(head,lists[i]);
    }
    return head;
}

private ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    if(l1==null){
        return l2;
    }
    if(l2 ==null){
        return l1;
    }

    ListNode dummyHead=new ListNode(0);

    ListNode cur1=l1;
    ListNode cur2=l2;
    ListNode cur=dummyHead;
    while(cur1!=null && cur2!=null){
        if(cur1.val <cur2.val){
            cur.next=cur1;
            cur1=cur1.next;
        }else{
            cur.next=cur2;
            cur2=cur2.next;
        }
        cur=cur.next;
    }
    if(cur1!=null){
        cur.next=cur1;
    }
    if(cur2!=null){
        cur.next=cur2;
    }

    ListNode retNode=dummyHead.next;
    dummyHead.next=null;
    return retNode;
}
```

```java
//思路二:使用优先队列,n是数组长度，K是链表平均长度
//时间复杂度：O(n * k log k)
//空间复杂度：O(n)
public ListNode mergeKLists(ListNode[] lists) {
    if(lists==null || lists.length==0){
        return null;
    }
    if (lists.length == 1){
        return lists[0];
    }

    //维护一个最小堆
    PriorityQueue<ListNode> queue = new PriorityQueue<>(new Comparator<ListNode>() {
        public int compare(ListNode o1, ListNode o2) {
            return o1.val - o2.val;
        }
    });
    for (int i = 0; i < lists.length; i++) {
        //这里只是加了每个链表的头结点
        if (lists[i] != null) queue.add(lists[i]);
    }

    ListNode dummyHead=new ListNode(-1);
    ListNode cur=dummyHead;

    while(!queue.isEmpty()){
        ListNode tmp=queue.poll();
        cur.next=tmp;
        cur=tmp;
        //看看该结点是否有下一个结点，这样就确保所有的元素都加入优先队列中了。
        if (tmp.next != null){
            queue.add(tmp.next);
        }
    }
    cur.next=null;

    ListNode retNode=dummyHead.next;
    dummyHead=null;

    return retNode;
}
```

### 692
[692 Top K Frequent Words](https://leetcode.com/problems/top-k-frequent-words/)
```java
public List<String> topKFrequent(String[] words, int k) {
    List<String> res=new ArrayList<>();
    PriorityQueue<Pair> pq=new PriorityQueue<>(new Comparator<Pair>() {
        @Override
        public int compare(Pair p1, Pair p2) {
            //先按照词频进行升序排列
            int num=p1.freq-p2.freq;
            //再按照word种地字母顺序进行排序
            int num2=(num==0)?p2.word.compareTo(p1.word):num;
            return num2;
        }
    });

    //统计单词及词频
    HashMap<String,Integer> map=new HashMap<>();
    for(String word:words){
        int freq=map.getOrDefault(word,0);
        map.put(word,++freq);
    }

    for(String word:map.keySet()){
        pq.add(new Pair(word,map.get(word)));
        if (pq.size() > k){
            pq.poll();
        }
    }

    while(!pq.isEmpty()){
        Pair p=pq.poll();
        res.add(p.word);
    }
    Collections.reverse(res);
    return res;
}

//封装单词和对应的词频
private class Pair{
    String word;
    int freq;
    public Pair(String word,int freq){
           this.word=word;
           this.freq=freq;
    }
}
```

## 更多和栈相关的问题
### 133
[133 Clone Graph](https://leetcode.com/problems/clone-graph/)
```java
/**
* 思路一:BFS
*/
public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
    if(node==null){
        return null;
    }
    Map<UndirectedGraphNode, UndirectedGraphNode> map=
            new HashMap<UndirectedGraphNode, UndirectedGraphNode>();
    Queue<UndirectedGraphNode> q=new LinkedList<>();
    UndirectedGraphNode newNode=new UndirectedGraphNode(node.label);
    map.put(node,newNode);
    q.add(node);
    while(!q.isEmpty()){
        UndirectedGraphNode curNode=q.poll();
        List<UndirectedGraphNode> curNeightbors=curNode.neighbors;
        for(UndirectedGraphNode neighbor:curNeightbors){
            if(map.containsKey(neighbor)){
                map.get(curNode).neighbors.add(map.get(neighbor));
            }else{
                UndirectedGraphNode newNode2=new UndirectedGraphNode(neighbor.label);
                map.put(neighbor,newNode2);
                map.get(curNode).neighbors.add(newNode2);
                q.add(neighbor);
            }
        }
    }
    return newNode;
}
```

```java
/**
* 思路二：DFS
*/
Map<UndirectedGraphNode, UndirectedGraphNode> map=
        new HashMap<UndirectedGraphNode, UndirectedGraphNode>();
public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
    if(node==null){
        return null;
    }
    //不访问重复的顶点
    if(map.containsKey(node)){
        return map.get(node);
    }
    UndirectedGraphNode newNode=new UndirectedGraphNode(node.label);
    map.put(node,newNode);
    for(UndirectedGraphNode neighbor: node.neighbors){
        newNode.neighbors.add(cloneGraph(neighbor));
    }
    return newNode;
}
```

### 856 
[856 Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/)

### 227 
[227 Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/)

### 901
[901 Online Stock Span](https://leetcode.com/problems/online-stock-span/)

## 更多和队列相关的问题
### 622
[622 Design Circular Queue](https://leetcode.com/problems/design-circular-queue/)