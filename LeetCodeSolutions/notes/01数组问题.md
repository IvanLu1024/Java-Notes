# [第一章 数组问题](#常见的数组问题)

| 章节 | 典型题目 | 相关题目 | 更多扩展练习 | 难题推荐 |
| :---: | :---: | :---: | :---: | :---: |
| [1-1 从二分查找法看如何写出正确的程序](#二分查找法) | [704](#704) | [69](#69) | [875](#875) [153*](#153) |  |
| [1-2 改变变量定义，依然可以写出正确的算法](#写出正确的算法) | [无] |  [374](#374) | [33](#33) [34](#34) |  |
| [1-3 在LeetCode上解决第一个问题 Move Zeros](#简单的面试问题) | [283](#283) | [728](#728) [747](#747) |  |  |
| [1-4 即使简单的问题，也有很多优化的思路](#简单的面试问题) | [283](#283) | [26](#26) [27](#27)  | [80](#80) | |
| [1-5 三路快排partition思路的应用 Sort Color](#排序算法思路的应用) | [75](#75) | [88](#88) [215](#215) | | |
| [1-6 对撞指针 Two Sum II - Input Array is Sorted](#对撞指针) | [167](#167) | [125](#125) [344](#344) [345](#345) | [11](#11) | |
| [1-7 滑动窗口 Minimum Size Subarray Sum](#滑动窗口) | [209](#209) [3](#3) | [438](#438) | [76](#76) [713](#713) | 159 |
| [补充1：更多数组中的问题](#更多数组中的问题) | [无] | [303](#303) [121](#121) [122](#122)  [717](#717) [674](#674) [268](#268)  [485](#485) [852](#852) [868](#868) [189](#189)  [896](#896)  |  [56](#56)  [853](#853)  [739](#739)  | 123 |
| [补充2：二维数组中的问题](#二维数组中的问题) | [54](#54) [59](#59) | [598](#598)  [766](#766) [867](#867) [883](#883)  [892](#892) |  [885](#885) [36](#36)  [794](#794) [807](#807) [498](#498) [48](#48) | |

# 常见的数组问题

## 二分查找法

二分查找法在1946年提出。
第一个没有bug的二分查找在1962才出现。

<div align="center"> <img src="pics//array//array_01.png" width="600"></div>

```java
public int binarySearch(Comparable[] arr,Comparable target){
        int l=0,r=arr.length-1; //在区间 [l,r]中查找target元素
        while(l<=r){ //当 l==r时，区间[l,r]仍然是有效的
            int mid=(r-l)/2+l;
            int cmp=arr[mid].compareTo(target);
            if(cmp==0){
                return mid;
            }else if(cmp>0){
                r=mid-1; //target在[l,mid-1]中
            }else{
                l=mid+1; //target在[mid+1,r]中
            }
        }
        return -1;
    }
```
二分查找的另一种写法:
```java
 public int binarySearch2(Comparable[] arr,Comparable target){
        int l=0,r=arr.length; //在区间 [l,r)中查找target元素
        while(l<r){ //当 l==r时，区间[l,r)是无效的
            int mid=(r-l)/2+l;
            int cmp=arr[mid].compareTo(target);
            if(cmp==0){
                return mid;
            }else if(cmp>0){
                r=mid; //target在[l,mid)中
            }else{
                l=mid+1; //target在[mid+1,r)中
            }
        }
        return -1;
    }
```
可以看到这两种写法只是所查找的区间不同。

> 典型例题

### 704
[704 Binary Search](https://leetcode.com/problems/binary-search/description/)

- 问题描述： ``

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，
写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

- 示例：
 
示例 1:

输入: nums = [-1,0,3,5,9,12], target = 9

输出: 4

解释: 9 出现在 nums 中并且下标为 4

示例 2:

输入: nums = [-1,0,3,5,9,12], target = 2

输出: -1

解释: 2 不存在 nums 中因此返回 -1

- 思路：典型的二分查找

```java
public int search(int[] nums, int target) {
    int start=0;
    int end=nums.length-1;
    while(start<=end){
        int mid=start+(end-start)/2;
        if(target==nums[mid]){
            return mid;
        }else if(target<nums[mid]){
            end=mid-1;
        }else{
            start=mid+1;
        }
    }
    return -1;
}
```

> 相关题目

### 69 
[69 Sqrt(x)](https://leetcode.com/problems/sqrtx/description/)

```java
/**
* 问题描述：
实现 int sqrt(int x) 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
  
* 示例：
示例 1:
输入: 4
输出: 2
示例 2:

输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
由于返回类型是整数，小数部分将被舍去。
*/
public int mySqrt(int x) {
    if (x <= 1) {
        return x;
    }
    int l = 1, h = x;
    while (l <= h) {
        int mid = l + (h - l) / 2;
        int sqrt = x / mid;
        if (sqrt == mid) {
            return mid;
        } else if (mid > sqrt) {
            h = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return h;
}
```

### 153
[153 Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/)
```java
/**
* 问题描述： 
假设按照升序排序的数组在预先未知的某个点上进行了旋转。  
( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
请找出其中最小的元素。
  
你可以假设数组中不存在重复元素。

* 示例： 
  
示例 1:
输入: [3,4,5,1,2]
输出: 1

示例 2:
输入: [4,5,6,7,0,1,2]
输出: 0
*/
/**
* 思路：
* 第一个小于前一个元素的元素，就是最小值。
* 我们通过二分查找的，进行优化。
*/
public int findMin(int[] nums) {
    int n=nums.length;
    if(n==1){
        return nums[0];
    }
    if(n==2){
        return Math.min(nums[0],nums[1]);
    }
    //查找区间在[l,h]
    int l=0;
    int h=n-1;
    while(l<=h){
        //l==h说明 l和h指向同一个元素了，此时该元素就是最小元素
        if(l==h){
            return nums[l];
        }
        int mid=l+(h-l)/2;
        //相邻元素，如果后一个元素 < 前一个元素，作为后一个元素必然是最小值
        if(nums[mid]>nums[mid+1]){
            return nums[mid+1];
        }
        if(nums[mid]>nums[h]){
            l=mid;
        }else if(nums[mid]<nums[h]){
            h=mid;
        }
    }
    return nums[l];
}
```

### 875 
[875 Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/)
```java
/**
* 问题描述：

珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。
珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。
每个小时，她将会选择一堆香蕉，从中吃掉 K 根。
如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  
珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。
返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。

* 示例：
示例 1：
输入: piles = [3,6,7,11], H = 8
输出: 4

示例 2：
输入: piles = [30,11,23,4,20], H = 5
输出: 30

示例 3：
输入: piles = [30,11,23,4,20], H = 6
输出: 23
*/
/**
* 思路：珂珂吃香蕉的最快速度就是 N 个堆中香蕉数目最多的堆中的数目。
* 可以在 H 小时内吃掉所有香蕉的最小速度 K。就是求他在警卫刚好回来的时候，刚好吃完所有的香蕉。
*/
public int minEatingSpeed(int[] piles, int H) {
    if (piles.length > H ) {
        return -1;
    }
    //maxSpeed KOKO吃香蕉的最快速度
    int maxSpeed=piles[0];
    for(int i=0;i<piles.length;i++){
        maxSpeed=Math.max(maxSpeed,piles[i]);
    }
    //KOKO吃香蕉的速度在[1,maxSpeed]之间
    int l=1;
    int h=maxSpeed;
    while(l<=h){
        int mid=l+(h-l)/2;
        int hours=hours(piles,mid);
        if(hours==H){
            return mid;
        }else if(hours<H){
            //hours<H说明吃的快了,速度要降下来
            h=mid-1;
        }else{
            //hours>H说明吃的慢了，速度要快起来
            l=mid+1;
        }
    }
    return l;
}

//以spped速度吃香蕉所花费的时间
private int hours(int[] piles,int speed){
    int time=0;
    for(int pile:piles){
        if(pile%speed==0){
            time+=pile/speed;
        }else{
            time+=(pile/speed+1);
        }
    }
    return time;
}
```

## 写出正确的算法
### 374
[374 Guess Number Higher or Lower](https://leetcode.com/problems/guess-number-higher-or-lower/description/)
```java
public int guessNumber(int n) {
    /*
     The guess API is defined in the parent class GuessGame.
    @param num, your guess
     @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
    int guess(int num);
   */
    //[1...n]之间进行二分查找
    int low=1;
    int hi=n;
    while(low<=hi){
        int mid=low+(hi-low)/2;
        int tmp=guess(mid);
        if(tmp==0){
            return mid;
        }else if(tmp==1){
            //myNumber大了，即mid<myNumber的情况
            low=mid+1;
        }else{
            hi=mid-1;
        }
    }
    return low;
}
```

### 33
[33 Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/description/)
```java
public int search(int[] nums, int target) {
    int index=0;
    int i=1;
    while(i<nums.length){
        if(nums[i]<nums[i-1]){
            index=i;
        }
        i++;
    }
    if(index==0){
        return binarySearch(nums,0,nums.length,target);
    }
    int res=binarySearch(nums,0,index,target);
    if(res==-1){
        res=binarySearch(nums,index,nums.length,target);
    }
    return res;
}

//在[low,hi)之间查找
private int binarySearch(int[] nums,int low,int hi,int target){
    while(low<hi){
        int mid=low+(hi-low)/2;
        if(nums[mid]==target){
            return mid;
        }else if(nums[mid]>target){
            hi= mid;
        }else{
            low=mid+1;
        }
    }
    return -1;
}
```

### 34
[34 Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/)
```java
public int[] searchRange(int[] nums, int target) {
    int[] res=new int[2];
    res[0]=binarySearchFirst(nums,target);
    res[1]=binarySearchLast(nums,target);
    return res;
}

//注意：这里是查找元素是target的第一个下标的二分查找
private int binarySearchFirst(int[] nums,int target){
    int low=0;
    int hi=nums.length-1;
    int res=-1;
    while(low<=hi){
        int mid=low+(hi-low)/2;
        //mid-1是关键
        if(nums[mid]>=target) {
            hi = mid - 1;
        }else{
            low=mid+1;
        }
        if(nums[mid]==target){
            //不断res，一直到其是第一个target的下标
            res=mid;
        }
    }
    return res;
}

//注意：这里是查找元素是target的最后一个下标的二分查找
private int binarySearchLast(int[] nums,int target){
    int low=0;
    int hi=nums.length-1;
    int res=-1;
    while(low<=hi){
        int mid=low+(hi-low)/2;
        //mid+1是关键
        if(nums[mid]<=target) {
            low= mid+1;
        }else{
            hi = mid - 1;
        }
        if(nums[mid]==target){
            //不断res，一直到其是最后一个target的下标
            res=mid;
        }
    }
    return res;
}
```

## 简单的面试问题
### 283
[283 Move Zeros](https://leetcode.com/problems/move-zeroes/description/)

* 问题描述：

给定一个数组nums,写一个函数，将数组中所有的0挪到数组的末尾，而维持其他所有非0元素的相对位置。

* 举例：

nums[0,1,0,3,12]，函数运行后结果为[1,3,12,0,0]

* 思路：

思路一：

* 1、准备一个集合，用于存储该数组中的非0元素，遍历数组中元素，遇到非0元素，就放入集合中
* 2、对该数组重新赋值，前面的非0元素都是从集合中取出，后面的元素都是0
```java
//时间复杂度 O(n)
//空间复杂度 O(n)
    public void moveZeroes(int[] nums) {
        List<Integer> list=new ArrayList<Integer>();
        for(int num:nums){
            if(num!=0){
                list.add(num);
            }
        }
        for(int i=0;i<list.size();i++){
            nums[i]=list.get(i);
        }
        for(int j=list.size();j<nums.length;j++){
            nums[j]=0;
        }
    }
```

思路二：

* 1、引入另外一个指针k,用于指向数组中非0元素（原有一个遍历数组的指针i），很显然k <= nums.length-1
* 2、则nums的前k个都是非0元素了，剩下的元素就是0元素
```java
//时间复杂度：O(n)
//空间复杂度：O(1)
    public void moveZeroes(int[] nums) {
        int k=0;//[0,k)都是非0元素
        for(int num:nums){
            if(num!=0){
                nums[k++]=num;
            }
        }
        for(int i=k;i<nums.length;i++){
            nums[i]=0;
        }
    }
```

思路三：

* 1、引入另外一个指针k,用于指向数组中非0元素（原有一个遍历数组的指针i），很显然k <= nums.length-1
* 2、[0,k)中元素是非0元素，i指向非0元素，就与k指向的元素交换，这样保证元素的相对顺序
```java
//时间复杂度：O(n)
//空间复杂度：O(1)
    public void moveZeroes(int[] nums) {
        int k=0;//[0,k)都是非0元素
        for(int i=0;i<nums.length;i++){
            /*if(nums[i]!=0){
                swap(nums,k++,i);
            }*/
			//优化
			if(i!=k){
                swap(nums,k++,i);
            }else{
                k++;
            }
        }
    }

    public void swap(int[] nums,int i,int j){
        int tmp=nums[i];
        nums[i]=nums[j];
        nums[j]=tmp;
    }
```

### 728
[728 Self Dividing Numbers](https://leetcode.com/problems/self-dividing-numbers/description/)
```java
public List<Integer> selfDividingNumbers(int left, int right) {
    List<Integer> res=new ArrayList<>();
    if(left>right){
        return res;
    }
    for(int i=left;i<=right;i++){
        if(isValid(i)){
            res.add(i);
        }
    }
    return res;
}

private boolean isValid(int num){
    int Num=num;
    //获取num的各位上的数字
    while(num!=0){
        int tmp=num%10;
        if(tmp==0){
            return false;
        }
        if(Num%tmp!=0){
            return false;
        }
        num=num/10;
    }
    return true;
}
```
### 747
[747 Largest Number At Least Twice of Others](https://leetcode.com/problems/largest-number-at-least-twice-of-others/description/)
```java
public int dominantIndex(int[] nums) {
    int n=nums.length;
    if(n==1){
        return 0;
    }
    int maxIndex=getMaxIndex(nums);
    Arrays.sort(nums);
    if(2*nums[n-2]>nums[n-1]){
        return -1;
    }
    return maxIndex;
}

private int getMaxIndex(int[] nums){
    int max=nums[0];
    int index=0;
    for(int i=1;i<nums.length;i++){
        if(nums[i]>max){
            max=nums[i];
            index=i;
        }
    }
    return index;
}
```

### 26
[26 Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)

* 问题描述：

给定一个有序数组，对数组中的元素去重，使得原数组中每个元素只有一个。返回去重后数组的长度值。

* 举例：

nums=[1,2,2];

返回2，且nums中前两个元素为1和2

* 思路：

* 1、准备一个指针k,[0,k]是没有重复元素

* 2、这是一个有序数组，遍历数组，当nums[i]!=nums[k]就说明遇到另外一个值不相同的元素，将该元素加入[0，k]间中

```java
public int removeDuplicates(int[] nums) {
        if(nums.length==0){
            return 0;
        }
        int k=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]!=nums[k]){
                //nums[i]是值不同的元素，且i>=k，此时[0,k]存储是不同元素
                k++;
                nums[k]=nums[i];
            }
        }
        return k+1;
    }
```

### 27
[27 Remove Element](https://leetcode.com/problems/remove-element/description/)

* 问题描述：

给定一个数组nums和一个数值val,将数组中所有等于val的元素删除，并返回剩余元素的个数。

* 举例：

nums=[3,2,2,3],val=3;

返回2，且nums中前两个元素是2

* 思路：

思路一：

* 1、准备一个指针k，指向不是val的元素,保证 [0,k)都没有val元素

* 2、[0,k)就是nums数组的前k个非val的元素，直接返回k值，就可以了

```java
public int removeElement(int[] nums, int val) {
        int k=0;
        for(int num:nums){
            if(num!=val){
                nums[k++]=num;
            }
        }
        return k;
    }
```

思路二：

* 遍历数组，若和val相等，则用最后一项代替这一项，并判断代替后的值是不是和val相等。

```java
public int removeElement(int[] nums, int val) {
        int last=0;
        for(int i=0;i<nums.length-last;i++){
            if(nums[i]==val){
                //元素值与目标值相等，就用最后一项元素代替该元素，再从该元素进行比较
                last++;
                nums[i]=nums[nums.length-last];
                //将最后一项赋值给该元素
                i--;//再比较替换后的元素，再判断是否等于val
            }
        }
        return nums.length-last;
    }
```

### 80
[80 Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/)

* 问题描述：

给定一个有序数组，对数组中的元素去重，使得原数组中每个元素最多保留2个。返回去重后数组的长度值。

* 举例：

nums=[1，1，1,2,2，3];

返回5，且nums中前5个元素为1,1,2,2,3

* 思路：
```java
    public int removeDuplicates(int[] nums) {
        if (nums.length<= 2){
            return nums.length;
        }

        int k = 1;
        //k=1时，前两个元素必然在数组中
        int cnt = 1;
        for(int i=1;i < nums.length;i++) {
            if (nums[i] != nums[i-1]) {
                //相邻元素不相等,元素个数为1
                cnt = 1;
                nums[k++] = nums[i];
            } else {
                //存在相邻元素
                if (cnt < 2) {
                    //cnt<2说明值已经进来1个元素，此时再加1个元素
                    nums[k++] = nums[i];
                    cnt++;
                }
            }
        }
        return k;
    }
```
* 扩展：
```java
 /**
     * 拓展：
     * 给定一个有序数组，对数组中的元素去重，使得原数组中每个元素最多保留n个。返回去重后数组的长度值。
     */
    public int removeDuplicates(int[] nums,int n) {
        if (nums.length<= n){
            return nums.length;
        }

        int k = 1;
        //k=1时，前两个元素必然在数组中
        int cnt = 1;
        for(int i=1;i < nums.length;i++) {
            if (nums[i] != nums[i-1]) {
                //相邻元素不相等,元素个数为1
                cnt = 1;
                nums[k++] = nums[i];
            } else {
                //存在相邻元素
                if (cnt < n) {
                    //cnt<2说明值已经进来1个元素，此时再加1个元素
                    nums[k++] = nums[i];
                    cnt++;
                }
            }
        }
        return k;
    }
```

## 排序算法思路的应用
### 75
[75 Sort Colors](https://leetcode.com/problems/sort-colors/description/)

* 问题描述：

给定一个有n个元素的数组，数组中元素的取值只有0,1,2三种可能。
为这个数组排序。

* 解题：

1、明确问题

是否可以使用任何一种排序算法，但是没有使用题目中给出的特殊条件，所以不建议使用排序算法

2、思路一：

分别统计0,1,2元素个数，然后再对数组重新赋值

```java
public void sortColors(int[] nums) {
    int[] count=new int[3];
    //存放0,1,2元素的频率
    for(int i=0;i<nums.length;i++){
        count[nums[i]]++;
    }
    int index=0;
    for(int i=0;i<count[0];i++){
        nums[index++]=0;
    }
    for(int i=0;i<count[1];i++){
        nums[index++]=1;
    }
    for(int i=0;i<count[2];i++){
        nums[index++]=2;
    }
}
```
时间复杂度：O(n)

空间复杂度：O(k),k是nums元素的最大值

3、思路二：借鉴三路快速排序
<div align="center"> <img src="pics//array//array_02.png" width="600"></div>

<div align="center"> <img src="pics//array//array_03.png" width="600"></div>
zero指针指向0元素,two指针指向2元素，i是遍历数组的指针,
这里有nums[0..zero]==0,nums[zero+1..i+1]==1,nums[two..n-1]==2:

* i指向值为0的元素，swap(i,zero+1) ,交换后，i位置元素是1(nums[zero+1..i+1]==1)，不需要处理，i直接+1
* i指向值为1的元素，不需要处理直接+1
* i指向值为2的元素，swap(i,two-1),交换后，two-1位置元素就是2

```java

public void sortColors(int[] nums){
    int zero=-1;
    //nums[0,zero]==0,开始并没有元素，所以取zero=-1,[0,-1]显然不成立
    int two=nums.length;
    //nums[two,n-1]==2,开始并没有元素，所以取two=n,[n,n-1]显然不成立
    for(int i=0;i<two;){
        if(nums[i]==0){
            zero++;
            swap(nums,zero,i);
            i++;
        }else if(nums[i]==2){
            two--;
            swap(nums,two,i);
        }else{
            i++;
        }
    }
}

public void swap(int[] nums,int i,int j){
    int tmp=nums[i];
    nums[i]=nums[j];
    nums[j]=tmp;
}
```
### 88
[88 Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/description/)

```java
//思路：采用合并排序的思路,这里要想空间复杂度为O（1）,则将两个数组中元素从后向前合并.
public void merge(int[] nums1, int m, int[] nums2, int n) {
    //从后向前合并
    int index=m+n-1;
    int i=m-1;
    int j=n-1;
    while(i>=0 && j>=0){
        if(nums1[i]>nums2[j]){
            nums1[index--]=nums1[i--];
        }else{
            nums1[index--]=nums2[j--];
        }
    }
    //nums2任然有剩余元素，且是最小的那部分元素，将这些元素直接复制到num1的前面
    while(j>=0){
        nums1[index--]=nums2[j--];
    }
}
```
### 215
[215 Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/description/)
```java
//根据快速排序中partion划分，
//这里找的是第k大的元素，言下之意，就是要找到第(nums.length-k+1)小的元素
public int findKthLargest(int[] nums, int k) {
	int low=0;
	int high=nums.length-1;
	k=nums.length-k;
	while(low<high){
		int m=partition(nums,low,high);
		//m坐标元素的左边都小于 nums[m],右边都大于元素nums[i]
		if(m==k){
			break;
		}else if(m<k){ //说明
			low=m+1;
		}else if(m>k){
			high=m-1;
		}
	}
	return nums[k];
}

//在[l,r]中已nums[0]为pivot进行划分
public int partition(int[] nums,int l,int r){
	int pivot=nums[l];
	while(l<r){
		//从右向左遍历，找出第一个<pivot的元素
		while(l<r && nums[r]>=pivot){
			r--;
		}
		nums[l]=nums[r];
		//从右向左遍历，找出第一个>pivot的元素
		while(l<r && nums[l]<=pivot){
			l++;
		}
		nums[r]=nums[l];
	}
	nums[l]=pivot;
	return l;
}
```

## 对撞指针
### 167
[167 Two Sum II - Input array is sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/)

* 问题描述：

给定一个有序整型数组和一个整数target，在其中去找两个元素，使其和为target.
返回这两个数的索引。

* 解题：

1、明确问题

**如果没有解如何处理**？ 题目保证有解

**如果有多个个如何处理**？ 返回任意一组即可

**索引是从0开始还是从1开始**？ 索引从1开始

2、思路一：

数组有序，首先想到二分查找，对于nums[i]，如果数组中存在两个元素和为target，
则必然在nums[i+1...n-1]中存在元素target-nums[i]。

```java
public int[] twoSum(int[] numbers, int target) {
    for(int i=0;i<numbers.length;i++){
        int index=binarySearch(numbers,target-numbers[i],i+1,numbers.length-1);
        if(index!=-1){
            //说明[i+1...n-1]存在元素target-numbers[i]
            return new int[]{i+1,index+1};
        }
    }
    return null;
}

public int binarySearch(int[] numbers,int target,int l,int r){
    while(l<=r){
        int mid=(r-l)/2+l;
        if(numbers[mid]==target){
            return mid;
        }else if(numbers[mid]<target){
            l=mid+1;
        }else{
            r=mid-1;
        }
    }
    return -1;
}
```
时间复杂度 O(nlogn)

空间复杂度 O(1)

3、思路二：

引入两个指针 i,j，分别指向该有序数组的头部和尾部：

当numbers[i]+numbers[j]==target时, i、j就是所求的解

当numbers[i]+numbers[j]<target时,说明值过小，要加大值，i加1

当numbers[i]+numbers[j]==target时,说明值过大，要减小值，j减1

```java
public int[] twoSum(int[] numbers, int target) {
        int i=0;
        int j=numbers.length-1;
        while(i<j){
            //i和j是不能相等的，因为反返回两个不同下标
            int sum=numbers[i]+numbers[j];
            if(sum==target){
                return new int[]{i+1,j+1};
            }else if(sum<target){
                i++;
            }else{
                j--;
            }
        }
        return null;
    }
```
时间复杂度：O(n)

空间复杂度：O(1)
    
### 125
[125 Valid Palindrome](https://leetcode.com/problems/valid-palindrome/description/)

```java
//算法思路：对撞指针。只不过要注意遇到不是字母或者数字的字符要跳过，字符之间的比较是忽略大小写的
public boolean isPalindrome(String s) {
    int i=0;
    int j=s.length()-1;
    while(i<j){
        char c1=s.charAt(i);
        char c2=s.charAt(j);
        if(!isNumber(c1) && !isAlpha(c1)){
            i++;
            continue;
        }
        if(!isNumber(c2) && !isAlpha(c2)){
            j--;
            continue;
        }
        if(!isEqual(c1,c2)){
            return false;
        }
        i++;
        j--;
    }
    return true;
}

//比较两个字符是否相等,如果是字母，就忽略大小写
public boolean isEqual(char c1,char c2){
    if(c1==c2){
        return true;
    }else{
        if((isAlpha(c1) && isAlpha(c2)) && Math.abs(c1-c2)==32){
            return true;
        }
    }
    return false;
}

public boolean isNumber(char c){
    if(c>='0' && c<='9'){
        return true;
    }
    return false;
}

public boolean isAlpha(char c){
    if((c>='A' && c<='Z') || (c>='a' && c<='z')){
        return true;
    }
    return false;
}
```
时间复杂度：O(n)

空间复杂度：O(1)

### 344
[344 Reverse String](https://leetcode.com/problems/reverse-string/description/)

```java
public String reverseString(String s) {
    int i=0;
    int j=s.length()-1;
    char[] chs=s.toCharArray();
    while(i<j){
        char tmp=chs[i];
        chs[i]=chs[j];
        chs[j]=tmp;
        i++;
        j--;
    }
    return new String(chs);
}
```
时间复杂度：O(n)

空间复杂度：O(n)

### 11
[11 Container With Most Water](https://leetcode.com/problems/container-with-most-water/description/)

<div align="center"> <img src="pics//array//array_05.png" width="600"></div>

* 解题：

解法一：
```java
//时间复杂度：O(n^2)
//空间复杂度：O(1)
public int maxArea1(int[] height) {
    int mostWater=0;
    for(int i=0;i<height.length;i++){
        for(int j=i+1;j<height.length;j++){
            int h=Math.min(height[i],height[j]);
            if((j-i)*h>mostWater){
                mostWater=(j-i)*h;
            }
        }
    }
    return mostWater;
}
```
解法二：
```java
/**
 *  对撞指针
 *  假设有左指针和右指针，且左指针指向的值小于右指针的值。
 *  假如我们将右指针左移，则右指针左移后的值和左指针指向的值相比有三种情况：
 *  （1）右指针指向的值大于左指针：这种情况下，容器的高取决于左指针，但是底变短了，所以容器盛水量一定变小
 *  （2）右指针指向的值等于左指针：这种情况下，容器的高取决于左指针，但是底变短了，所以容器盛水量一定变小
 *  （3）右指针指向的值小于左指针：这种情况下，容器的高取决于右指针，但是右指针小于左指针，且底也变短了，所以容量盛水量一定变小了
 *  反之，情况类似。
 *  综上所述，容器高度较大的一侧的移动只会造成容器盛水量减小。
 *  所以应当移动高度较小一侧的指针，并继续遍历，直至两指针相遇。
 */
//时间复杂度：O(n)
//空间复杂度：O(1)
public int maxArea(int[] height) {
    int i=0;
    int j=height.length-1;
    int mostWater=0;
    while(i<j){
        int h=Math.min(height[i],height[j]);
        if((j-i)*h>mostWater){
            mostWater=(j-i)*h;
        }
        if(height[i]<height[j]){
            i++;
        }else{
            j--;
        }
    }
    return mostWater;
}
```

## 滑动窗口
### 209
[209 Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/description/)

* 问题描述

给定一个整型数组和一个数字s,找到数组中最短的一个连续
子数组，使得连续子数组的数字和sum>=s,返回这个最短的连续子数组的长度值

* 示例：

给定数组[2,3,1,2,4,3],s=7

答案为[4,3],返回2

* 解题：

1、确定问题：

**什么叫子数组**？看子数组是否要求连续，这里是连续的

**如果没有解如何处理**？返回0

2、思路：

l=0,r=-1(一开始不包含任何元素，所以取l=0,r=-1),
滑动窗口[l,r] ,sum是[l...r]的和：

当sum<s时，此时 r+1，拓展该窗口,sum+=nums[r+1]

其他情况，缩小该窗口，sum-=nums[l],l++

```java
public int minSubArrayLen(int s, int[] nums) {
    int n=nums.length;
    int l=0,r=-1;
    //[l,r]为滑动窗口，开始时不包含任何元素
    int sum=0;
    //记录滑动窗口中元素和
    int ret=n+1;
    //ret记录求解的长度
    while(l<n){
        if(r+1<n && sum<s){
            r++;
            sum+=nums[r];
        }else{
            sum-=nums[l];
            l++;
        }
        if(sum>=s){
            ret=Math.min(ret,(r-l+1));
        }
    }
    if(ret==n+1){
        //表示没有找到结果，使得 sum>=s
        ret=0;
    }
    return ret;
}
```
时间复杂度：O(n)

空间复杂度：O(1)

### 3
[3 Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/description/)

* 问题描述：

在一个字符串中寻找没有重复字母的最长子串

* 示例：

如"abcabcbb",则结果为"abc"

如"bbbbb",则结果为"b"

如"pwwkew",则结果为"wke"

* 解答：

1、明确问题

**字符集**？**只有字母**？**数字和字母**？**ACSII**?数字和字母
**大小写是否敏感**?是

2、思路：

<div align="center"> <img src="pics//array//array_04.png" width="600"></div>

l=0,r=-1,[l,r]是滑动窗口，freq[256]数组用于判断该滑动窗口是否存在重复元素：

当加入的元素不是重复元素时,r+1，扩展该窗口

其他情况，缩小该窗口，l+1

```java
public int lengthOfLongestSubstring(String s) {
        int n=s.length();

        int[] freq=new int[256];
        //记录每个字符出现的频率，用于判断滑动窗口中是否有重复元素
        int l=0,r=-1;
        //[l,r]为滑动窗口，开始时，没有元素
        int ret=0;
        //记录最长子段
        while(l<n){
            if(r+1<n && freq[s.charAt(r+1)]==0){
                //没有重复元素，扩展窗口
                r++;
                freq[s.charAt(r)]++;
            }else{
                //缩小窗口
                freq[s.charAt(l)]--;
                l++;
            }
            ret=Math.max(ret,r-l+1);
        }
        return ret;
    }
```
时间复杂度：O(n)

空间复杂度：O(k),k是元素的编码范围

### 438
[438 Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/description/)

* 解法一：
```java
//思路一：固定该滑动窗口大小，逐步平移该窗口
public List<Integer> findAnagrams(String s, String p) {
    List<Integer> ret=new ArrayList<>();
    if(s==null || s==""){
        return ret;
    }
    int l=0;
    int r=l+p.length()-1;
    while(l<=r && r<s.length()){
        if(isAnagram(s.substring(l,r+1),p)){
            ret.add(l);
        }
        l++;
        r++;
    }
    return ret;
}

//判断两个字符串是否是Anagram
//先判断长度是否相同，不相同，直接返回false
//统计 s1字符串中每个小写字母出现的频率，根据s2是否出现相同的字母以及出现的字母的频率是否相同
public boolean isAnagram(String s1,String s2){
    if(s1.length()!=s2.length()){
        return false;
    }
    int[] freq=new int[26];
    //统计小写字母出现的频率
    for(int i=0;i<s1.length();i++){
        freq[s1.charAt(i)-'a']++;
    }
    for(int i=0;i<s1.length();i++){
        char curChar=s2.charAt(i);
        if(freq[curChar-'a']==0){
            //说明s2中不存在curChar字符
            return false;
        }
        //如果curChar，频率减1，表示匹配了curChar
        freq[curChar-'a']--;
    }
    return true;
}
```
* 解法二：
```java
public List<Integer> findAnagrams(String s, String p) {
    List<Integer> ret = new ArrayList<>();
    if (s == null || s == "") {
        return ret;
    }
    //统计字符串p中出现的小写字符的频率
    int[] pFreq=new int[256];
    //count是p中的字符数
    int count=p.length();

    for(int i=0;i<count;i++){
        pFreq[p.charAt(i)]++;
    }
    int l=0,r=0;
    //[l,r)表示滑动窗口
    while(r<s.length()){
        if(pFreq[s.charAt(r++)]-->=1){
            //每次有一个p中字符进入窗口，扩展窗口，并且count–1
            count--;
        }
        if(count==0){
            //当count == 0的时候，表明我们的窗口中包含了p中的全部字符，得到一个结果。
            ret.add(l);
        }

        if (r-l == p.length()) {
            //当窗口包含一个结果以后，为了进一步遍历，我们需要缩小窗口使窗口不再包含全部的p，
            //同样，如果pFreq[char]>=0，表明一个在p中的字符就要从窗口移动到p字符串中，那么count ++
            if (pFreq[s.charAt(l++)]++ >= 0) {
                count++;   // one more needed to match
            }
        }
    }
    return ret;
}
```

### 76
[76 Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/description)
```java
/**
 * 思路：
 * 我们可以考虑哈希表，其中key是T中的字符，value是该字符出现的次数。

 - 我们最开始先扫描一遍T，把对应的字符及其出现的次数存到哈希表中。

 - 然后开始遍历S，遇到T中的字符，就把对应的哈希表中的value减一，
 直到包含了T中的所有的字符，纪录一个字串并更新最小字串值。

 - 将子窗口的左边界向右移，略掉不在T中的字符，
 如果某个在T中的字符出现的次数大于哈希表中的value，则也可以跳过该字符。
 */
public String minWindow(String s, String t) {
    if(s.length()<t.length()){
        return "";
    }

    //统计t中字符的出现次数
    Map<Character,Integer> map=new HashMap<>();
    for(int i=0;i<t.length();i++){
        int freq=map.getOrDefault(t.charAt(i),0);
        map.put(t.charAt(i),++freq);
    }

    int l=0,r=0;
    //[l,r]为滑动窗口，开始时，没有元素
    int count=0;
    //在窗口中出现的字符串T中的元素个数
    String ret="";
    int minLen=s.length()+1;
    //记录最长子段的长度
    while(r<s.length()){
        //s.charAt(r)表示s中字符
        if(map.containsKey(s.charAt(r))){
            int freq=map.get(s.charAt(r));
            map.put(s.charAt(r),--freq);
            //count统计字符串s中t中字符出现的次数
            if(freq>=0){
                count++;
            }
            //s中出现的字符数刚好包含了t中所有的字符
            while (count == t.length()) {
                //[l...r]窗口就是最字符串短
                if (r - l + 1 < minLen) {
                    minLen = r - l + 1;
                    ret = s.substring(l, r + 1);
                }
                //缩小窗口
                if (map.containsKey(s.charAt(l))) {
                    int sfreq = map.get(s.charAt(l));
                    map.put(s.charAt(l), ++sfreq);
                    if (sfreq > 0) {
                        --count;
                    }
                }
                ++l;
            }
        }
        r++;
    }
    return ret;
}
```

### 713
[713 Subarray Product Less Than K](https://leetcode.com/problems/subarray-product-less-than-k/description/)
```java
/**
 * 思路：
 * 采用滑动窗口的解法：维护一个数字乘积刚好小于k的滑动窗口窗口，
 * 用变量l来记录其左边界的位置，右边界r就是当前遍历到的位置。
 * 遍历原数组，用product乘上当前遍历到的数字，
 * 然后进行while循环，如果product大于等于k，
 * 则滑动窗口的左边界需要向右移动一位，删除最左边的数字，那么少了一个数字，乘积就会改变，
 * 所以用product除以最左边的数字，然后左边右移一位，即l自增1。
 * 当我们确定了窗口的大小后，就可以统计子数组的个数了，就是窗口的大小。

 * 为什么子数组的个数就是窗口的大小？
 * 比如[5 2 6]这个窗口，k还是100，右边界刚滑到6这个位置，
 * 这个窗口的大小就是包含6的子数组乘积小于k的个数，即[6], [2 6], [5 2 6]，正好是3个。
 * 所以窗口每次向右增加一个数字，然后左边去掉需要去掉的数字后，
 * 窗口的大小就是新的子数组的个数，每次加到结果res中即可。
 * 
 * 注意：
 * 这里要求子集的乘积值必须小于k
 */
public int numSubarrayProductLessThanK(int[] nums, int k) {
    if(k<=1){
        return 0;
    }

    int l=0;
    int r=0;
    int res=0;
    //[l..r]表示的是乘积和<k的窗口
    int product=1;
    while(r<nums.length){
       product*=nums[r];
       while(product>=k){
           product/=nums[l];
           l++;
       }
       //r-l+1表示的就是[l...r]窗口的长度
       res+=(r-l+1);
       r++;
    }
    return res;
}
```

## 更多数组中的问题
### 303 
[303 Range Sum Query - Immutable](https://leetcode.com/problems/range-sum-query-immutable/description/)

* 解法一：
```java
/**
 * 思路一：
 * 直接法，但是时间会超出限制
 */
class NumArray {
    private int[] data;

    public NumArray(int[] nums) {
        data=new int[nums.length];
        for(int i=0;i<nums.length;i++){
            data[i]=nums[i];
        }
    }

    public int sumRange(int i, int j) {
        int sum=0;
        for(int k=i;k<=j;k++){
            sum+=data[k];
        }
        return sum;
    }
}
```
* 解法二：
```java
/**
 * 思路二：
 * 我们可以存储子序列和，每个下标处的值为[0,i]的所有元素和;
 那么[i,j]子序列和 sum[j]−sum[i−1]；
 注意，当i==0时，直接返回sum[j]即可。
 */
class NumArray {
    //sums[i]就是[0...i]的元素和
    private int[] sums;

    public NumArray(int[] nums) {
        if(nums.length==0){
            return;
        }
        sums=new int[nums.length];
        //sums[0]就是[0,0]的元素和，也就是第一个元素
        sums[0]=nums[0];
        for(int i=1;i<nums.length;i++){
            sums[i]=sums[i-1]+nums[i];
        }
    }

    public int sumRange(int i, int j) {
        if(i==0){
            return sums[j];
        }
        if((i<0 || i>= sums.length)||
                (j<0 || j>=sums.length) || (i>j)){
            return 0;
        }
        return sums[j]-sums[i-1];
    }
}
```
### 121
[121 Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/)
```java
/**
 * 思路：至多只能一次交易，那就在某次交易中化最小钱买入，以最大钱卖出
 */
public int maxProfit(int[] prices) {
    if(prices.length<=1){
        return 0;
    }
    int maxProfit=0;
    int minValue=prices[0];
    for(int i=0;i<prices.length;i++){
        maxProfit=Math.max(maxProfit,prices[i]-minValue);
        minValue=Math.min(minValue,prices[i]);
    }
    return maxProfit;
}
```

### 122
[122 Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/)
```java
/**
 * 思路：
 * 贪心策略：每次只要当天股价比前一天股价高就卖出。
 */
public int maxProfit(int[] prices) {
    if(prices.length<=1){
        return 0;
    }
    int maxProfit=0;
    for(int i=1;i<prices.length;i++){
        int profit=prices[i]-prices[i-1];
        if(profit>=0){
            maxProfit+=profit;
        }
    }
    return maxProfit;
}
```

### 717
[717 1-bit and 2-bit Characters](https://leetcode.com/problems/1-bit-and-2-bit-characters/description/)
```java
/**
 * 思路：
 * 2-bit都是1开头的，则只要遇到bits[i]==1时,就移动两位
 * 然后看看最后一位是否是1-bit（有可能最后一位和前一位共同组成2-bit,那就返回false）
 */
public boolean isOneBitCharacter(int[] bits) {
    int n=bits.length;
    if(n==1){
        return bits[0]==0;
    }
    for(int i=0;i<n;){
        if(bits[i]==1){
            i++;
        }
        i++;
        if(i==n-1){
            return bits[i]==0;
        }
    }
    return false;
}
```
### 674
[674 Longest Continuous Increasing Subsequence](https://leetcode.com/problems/longest-continuous-increasing-subsequence/description/)
```java
/**
 * 思路：
 * 找递增的数列，遇到非递增的情况就把计数值重新值1，
 * 然后比较一下当前计数值和max的大小得到新的max
 */
public int findLengthOfLCIS(int[] nums) {
    int n=nums.length;
    if(n<=1){
        return n;
    }

    int maxLen = 0;
    //连续递增区间的长度
    int continuousLen = 1;
    for (int i = 1; i < nums.length; i++) {
        if (nums[i - 1] >= nums[i]) {
            maxLen = Math.max(maxLen, continuousLen);
            continuousLen = 1;
        } else {
            continuousLen++;
        }
    }
    return Math.max(maxLen, continuousLen);
}
```

### 268 
[268 Missing Number](https://leetcode.com/problems/missing-number/description/)
```java
//按位异或即可 [0...n] n就是数组长度
public int missingNumber(int[] nums) {
    int n=nums.length;
    if(n==0){
        return 0;
    }

    int res=nums[0]^0;
    for(int i=1;i<n;i++){
        res^=(nums[i]^i);
    }
    res^=n;
    return res;
}
```

### 485
[485 Max Consecutive Ones](https://leetcode.com/problems/max-consecutive-ones/description/)
```java
public int findMaxConsecutiveOnes(int[] nums) {
    int n=nums.length;
    if(n==0){
        return 0;
    }

    int res=0;
    //count记录连续出现1的个数
    int count=0;
    for(int i=0;i<n;i++){
        if(nums[i]==1){
            count++;
            res=Math.max(res,count);
        }else{
            count=0;
        }
    }
    return res;
}
```

### 852 
[852 Peak Index in a Mountain Array](https://leetcode.com/problems/peak-index-in-a-mountain-array/description/)

* 解法一：
```java
/**
 * 思路一：
 * 寻找第一个下降位置的前一个位置
 * 时间复杂度：O（n）
 */
public int peakIndexInMountainArray1(int[] A) {
    //寻找第一个下降位置
    for(int i=0;i<A.length-1;i++){
        if(A[i]>A[i+1]){
           return i;
        }
    }
    return -1;
}
```

* 解法二：
```java
/**
 * 思路二：使用二分查找
 * 找出某个位置使得其左边递增同时其右边递减。
 会有三种情况：
 （1）A[mid-1] < A[mid] && A[mid] < A[mid+1]
 （2）A[mid-1] > A[mid] && A[mid] > A[mid+1]
 （3）A[mid-1] < A[mid] && A[mid] > A[mid+1]
 */
public int peakIndexInMountainArray(int[] A) {
    int l=0;
    int r=A.length-1;
    while(l<=r){
        int mid=l+(r-l)/2;
        if(A[mid-1]<A[mid] && A[mid]>A[mid+1]){
            return mid;
        }else if(A[mid-1] < A[mid] && A[mid] < A[mid+1]){
            l=mid+1;
        }else if(A[mid-1] > A[mid] && A[mid] > A[mid+1]){
            r=mid-1;
        }
    }
    return -1;
}
```

### 868 
[868 Binary Gap](https://leetcode.com/problems/binary-gap/description/)
```java
public int binaryGap(int N) {
    int res=0;
    //记录前一个1出现的位置
    int preIndex=-1;
    for(int i=0;i<32;i++){ //int是32bit所以取32,每次移动一位
        int ele=N & 1;
        if(ele==1){
            if(preIndex!=-1){
                res=Math.max(res,i-preIndex);
            }
            preIndex=i;
        }
        N=N>>1;
    }
    return res;
}
```

### 189
[189 Rotate Array](https://leetcode.com/problems/rotate-array/description/)
```java
/**
 * 思路：
 * 三次反转数组即可
 * 注意：k的取值有可能超过数组长度，所以数组实际反转的步数是 k%数组长度
 */
public void rotate(int[] nums, int k) {
    k=k%nums.length;
    reverse(nums,0,nums.length-1);
    reverse(nums,0,k-1);
    reverse(nums,k,nums.length-1);
}

//反转nums在[start...end]之间的数组
private void reverse(int[] nums,int start,int end){
    if(start>end){
        return;
    }
    while(start<end){
        int tmp=nums[start];
        nums[start]=nums[end];
        nums[end]=tmp;
        start++;
        end--;
    }
}
```

### 896 
[896 Monotonic Array](https://leetcode.com/problems/monotonic-array/description/)
```java
/**
 * 思路二：
 * 遍历数组，标记升序/降序情况。
 * 当发现后面的元素与前面的标记冲突时，则返回 false, 否则返回 true
 */
public boolean isMonotonic(int[] A) {
    if (A.length == 1) {
        return true;
    }
    //flag=0表示等于，默认就是等于
    //flag=-1 表示降序
    //flag=1 表示升序
    int flag=0;
    for(int i=0;i<A.length-1;i++){
        if(A[i]<A[i+1]){
            if(flag==0){
                flag=1;
            }else if(flag==-1){
                return false;
            }
        }else if(A[i]>A[i+1]){
            if(flag==0){
                flag=-1;
            }else if(flag==1){
                return false;
            }
        }
    }
    return true;
}
```

### 56
[56 Merge Intervals](https://leetcode.com/problems/merge-intervals/description/)
```java
public List<Interval> merge(List<Interval> intervals) {
    List<Interval> res=new ArrayList<>();
    if(intervals.size()==0){
        return res;
    }
    //按照区间的开始值进行排序
    Collections.sort(intervals, new Comparator<Interval>() {
        @Override
        public int compare(Interval o1, Interval o2) {
            int num=o1.start-o2.start;
            int num2=(num==0)?o1.end-o2.end:num;
            return num2;
        }
    });

    int start=intervals.get(0).start;
    int end=intervals.get(0).end;
    for(int i=1;i<intervals.size();i++){
        int nextStart=intervals.get(i).start;
        int nextEnd=intervals.get(i).end;
        if(nextStart<=end){
            end=Math.max(nextEnd,end);
        }else{
            res.add(new Interval(start,end));
            start=nextStart;
            end=nextEnd;
        }
    }
    res.add(new Interval(start,end));
    return res;
}
```

### 853 
[853 Car Fleet](https://leetcode.com/problems/car-fleet/description/)
```java
private class Car implements Comparable<Car>{
    int position;
    int speed;
    //到达终点所用的时间
    double time;

    public Car(int position,int speed,double time){
        this.position=position;
        this.speed=speed;
        this.time=time;
    }

    //按照起始位置进行降序排列
    @Override
    public int compareTo(Car car) {
        return car.position-this.position;
    }
}

/**
 * 思路：
 * 按照 position位置对车进行排序（降序）
 * 两辆车相撞的条件就是一辆车在前面并且到达结束位置的时在前的车用时较长。
 */
public int carFleet(int target, int[] position, int[] speed) {
    if(position.length==0){
        return 0;
    }
    Car[] cars=new Car[position.length];
    for(int i=0;i<position.length;i++){
        cars[i]=new Car(position[i],speed[i],1.0*(target-position[i])/speed[i]);
    }
    //对这些车按照起始位置进行排序
    Arrays.sort(cars);
    int res = 1;
    for(int i = 1 ; i < cars.length ; i ++){
        if(cars[i].time <= cars[i-1].time){
            cars[i].time = cars[i-1].time;
        }else{
            //后一辆车（离目的地更远）到达目的地所用的时间 > 前一辆车到达目的地所用的时间,这两辆车是不同车队的。
            res ++;
        }

    }
    return res;
}
```

### 739 
[739 Daily Temperatures](https://leetcode.com/problems/daily-temperatures/description/)

* 解法一：
```java
/**
 * 思路一：暴力解法
 * t通过break,缩短循环的执行时间
 */
public int[] dailyTemperatures1(int[] T) {
    if(T.length==1){
        return new int[]{0};
    }
    int[] res=new int[T.length];
    for(int i=0;i<T.length;i++){
        for(int j=i+1;j<T.length;j++){
            if(T[i]<T[j]){
                res[i]=j-i;
                break;
            }
        }
    }
    return res;
}
```

* 解法二：
```java
/**
 * 思路二：递减栈法
 * 使用递减栈Descending Stack来做，
 * 栈里只有递减元素，思路是这样的，我们遍历数组，
 * 如果栈不空，且当前数字大于栈顶元素，那么如果直接入栈的话就不是递减栈了，
 * 所以我们取出栈顶元素，那么由于当前数字大于栈顶元素的数字，而且一定是第一个大于栈顶元素的数，那么我们直接求出下标差就是二者的距离了，
 * 然后继续看新的栈顶元素，直到当前数字小于等于栈顶元素停止，然后将数字入栈，这样就可以一直保持递减栈。
 */
public int[] dailyTemperatures(int[] T) {
    if(T.length==1){
        return new int[]{0};
    }
    //保持递减栈，栈里存的是递减元素的下标
    Stack<Integer> stack=new Stack<>();
    int[] res=new int[T.length];
    for(int i=0;i<T.length;i++){
        while(!stack.isEmpty() && T[i]>T[stack.peek()]){
            int top=stack.pop();
            res[top]=i-top;
        }
        stack.push(i);
    }
    return res;
}
```

## 二维数组中的问题
### 54
[54 Spiral Matrix](https://leetcode.com/problems/spiral-matrix/description/)
```java
public List<Integer> spiralOrder(int[][] matrix) {
    List<Integer> res=new ArrayList<>();
    int m=matrix.length;
    if(m==0){
        return res;
    }
    int n=matrix[0].length;

    int top=0;
    int down=m-1;
    int left=0;
    int right=n-1;
    while (top <= down && left <= right) {
        //向从左向右遍历
        for(int j=left;j<=right;j++){
            res.add(matrix[top][j]);
        }
        top++;

        //从上向下遍历
        for(int i=top;i<=down;i++){
            res.add(matrix[i][right]);
        }
        right--;

        //从右向左遍历
        if(down-top>=0){
            //top此时已经是下一行了，down-top==0,说明top行和down重合了
            for(int j=right;j>=left;j--){
                res.add(matrix[down][j]);
            }
        }
        down--;

        //从下往上遍历
        if(right-left>=0){
            for(int i=down;i>=top;i--){
                res.add(matrix[i][left]);
            }
        }
        left++;
    }
    return res;
}
```
### 59
[59 Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/description/)
```java
public int[][] generateMatrix(int n) {
    int[][] res=new int[n][n];

    int top=0;
    int down=n-1;
    int left=0;
    int right=n-1;
    int ele=1;
    while(top<=down && left<=right){
        //从左向右遍历，进行赋值
        for(int j=left;j<=right;j++){
            res[top][j]=ele;
            ele++;
        }
        top++;

        //从上向下遍历，进行赋值
        for(int i=top;i<=down;i++){
            res[i][right]=ele;
            ele++;
        }
        right--;

        //从右向左遍历，进行赋值
        if(down-top>=0){
            for(int j=right;j>=left;j--){
                res[down][j]=ele;
                ele++;
            }
        }
        down--;

        //从下向上遍历，进行赋值
        if(right-left>=0){
            for(int i=down;i>=top;i--){
                res[i][left]=ele;
                ele++;
            }
        }
        left++;
    }
    return res;
}
```

### 598 
[598 Range Addition II](https://leetcode.com/problems/range-addition-ii/description/)

* 解法一：
```java
/**
 * 思路一：
 * 暴力解法
 * 但是超出时间限制
 */
public int maxCount1(int m, int n, int[][] ops) {
    if(m==0 || n==0){
        return 0;
    }
    int[][] matrix=new int[m][n];
    int operations=ops.length;
    for(int k=0;k<operations;k++){
        int a=ops[k][0];
        int b=ops[k][1];
        for(int i=0;i<a;i++){
            for(int j=0;j<b;j++){
                matrix[i][j]++;
            }
        }
    }
    int matrixMax=matrix[0][0];
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            matrixMax=Math.max(matrixMax,matrix[i][j]);
        }
    }
    int res=0;
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            if(matrix[i][j]==matrixMax){
                res++;
            }
        }
    }
    return res;
}
```

* 解法二：
```java
/**
 * 思路二：
 * 只需要找出两个操作的重叠区域，由于每次操作都是+1
 * 所有最大值就是 重叠区域长*重叠区域宽
 */
public int maxCount(int m, int n, int[][] ops) {
    if(m==0 || n==0){
        return 0;
    }
    //重叠区域的长度
    int row=m;
    //重叠区域的宽度
    int col=n;
    for(int i=0;i<ops.length;i++){
        row=Math.min(row,ops[i][0]);
        col=Math.min(col,ops[i][1]);
    }
    return row*col;
}
```

### 766
[766 Toeplitz Matrix](https://leetcode.com/problems/toeplitz-matrix/description/)
```java
public boolean isToeplitzMatrix(int[][] matrix) {
   int m=matrix.length;
   int n=matrix[0].length;
   for(int i=1;i<m;i++){
       for(int j=1;j<n;j++){
           if(matrix[i-1][j-1]!=matrix[i][j]){
               return false;
           }
       }
   }
   return true;
}
```

### 867
[867 Transpose Matrix](https://leetcode.com/problems/transpose-matrix/description/)
```java
public int[][] transpose(int[][] A) {
    int m=A.length;
    if(m==0){
        return new int[0][0];
    }
    int n=A[0].length;
    int[][] res=new int[n][m];
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            res[i][j]=A[j][i];
        }
    }
    return res;
}
```

### 883 
[883 Projection Area of 3D Shapes](https://leetcode.com/problems/projection-area-of-3d-shapes/description/)
```java
public int projectionArea(int[][] grid) {
    //s1表示俯视图的面积
    int s1=0;
    //s2表示正视图的面积
    int s2=0;
    //说表示左视图的面积
    int s3=0;

    int m=grid.length;
    int n=grid[0].length;
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            if(grid[i][j]!=0){
                s1++;
            }
        }
    }
    for(int i=0;i<m;i++){
        //记录每次遍历i位置的最大高度
        int max=grid[i][0];
        for(int j=0;j<n;j++){
            max=Math.max(max,grid[i][j]);
        }
        s2+=max;
    }

    for(int j=0;j<n;j++){
        //记录每次遍历i位置的最大高度
        int max=grid[0][j];
        for(int i=0;i<m;i++){
            max=Math.max(max,grid[i][j]);
        }
        s3+=max;
    }
    return (s1+s2+s3);
}
```

### 892 
[892 Surface Area of 3D Shapes](https://leetcode.com/problems/surface-area-of-3d-shapes/description/)
```java
/**
 * 计算每个cube的表面积，然后减去他们重合的部分
 */
public int surfaceArea(int[][] grid) {
    int m=grid.length;
    if(m==0){
        return 0;
    }
    int n=grid[0].length;
    int res=0;
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            if(grid[i][j]==0){
                continue;
            }
            //res+=(grid[i][j]*1+grid[i][j]*1+1*1)*2;
            res+=grid[i][j]*4+2;
            if(i<m-1){
                res-=Math.min(grid[i][j],grid[i+1][j])*2;
            }
            if(j<n-1){
                res-=Math.min(grid[i][j],grid[i][j+1])*2;
            }
        }
    }
    return res;
}
```


### 855
[885 Spiral Matrix III](https://leetcode.com/problems/spiral-matrix-iii/description/)
```java
//螺旋的具体方向
private int[][] d={
        {0,1}, //向右
        {1,0}, //向下
        {0,-1},//向左
        {-1,0},//向上
};

public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {
    int[][] res=new int[R*C][2];

    //标记R*C矩阵找那个元素数量
    int count=1;

    //每次螺旋的步长，第一次是1，第二次就是2
    int step=1;
    //[posx,posy]是每次螺旋的起始位置
    int posx=r0;
    int posy=c0;
    res[0][0]=posx;
    res[0][1]=posy;
    //curD是螺旋的方向，curD初始值为0，表示是从右开始的
    int curD=0;
    while(count<R*C){
        for(int i=0;i<2;i++){
            for(int j=0;j<step;j++){
                posx+=d[curD][0];
                posy+=d[curD][1];
                if(inArea(posx,posy,R,C)){
                    res[count][0]=posx;
                    res[count][1]=posy;
                    count++;
                }
            }
            //每次螺旋，都要换方向。螺旋四次后，又是从右边开始
            curD=(curD+1)%4;
        }
        step++;
    }
    return res;
}

private boolean inArea(int x,int y,int R,int C){
    return (x>=0 && x<R) && (y>=0 && y<C);
}
```

### 36 
[36 Valid Sudoku](https://leetcode.com/problems/valid-sudoku/description/)
```java
/**
* 查看每行是否有重复元素
* 查看每列是否有重复元素
* 查看每个九宫格是否有重复元素
* 上述三种情况一旦发现有重复元素就返回false
*/
public boolean isValidSudoku(char[][] board) {
    for(int i=0;i<9;i++){
        //查看每行是否有重复元素
        boolean[] row = new boolean[10];
        //查看每列是否有重复元素
        boolean[] col = new boolean[10];
        //查看每个九宫格是否有重复元素
        boolean[] block = new boolean[10];
        for(int j=0;j<9;j++){
            if(board[i][j]!='.'){
                if(row[board[i][j]-'0']==true){
                    return false;
                }
                row[board[i][j]-'0']=true;
            }
            if(board[j][i]!='.'){
                if(col[board[j][i]-'0']==true){
                    return false;
                }
                col[board[j][i]-'0']=true;
            }
            if(board[i/3*3+j/3][i%3*3+j%3]!='.'){
                if(block[board[i/3*3+j/3][i%3*3+j%3]-'0']==true){
                    return false;
                }
                block[board[i/3*3+j/3][i%3*3+j%3]-'0']=true;
            }
        }
    }
    return true;
}
```



### 794
[794 Valid Tic-Tac-Toe State](https://leetcode.com/problems/valid-tic-tac-toe-state/description/)
```java
public boolean validTicTacToe(String[] board) {
    //统计board上的X和O的数目
    int Onum=0;
    int Xnum=0;
    for(int i=0;i<3;i++){
        for (int j=0;j<3;j++){
            if(board[i].charAt(j)=='O'){
                Onum++;
            }
            if(board[i].charAt(j)=='X'){
                Xnum++;
            }
        }
    }

    //Xnum==Onum或者Xnum=Onum+1才是可以的
    if(Math.abs(Onum-Xnum)>=2){
        return false;
    }

    boolean Xwin=win(board,'X');
    boolean Owin=win(board,'O');
    if(Xwin && Owin){
        return false;
    }else if(Xwin && !Owin){
        return Xnum>Onum;
    }else if(!Xwin && Owin){
        return Xnum==Onum;
    }else{
        //!Xwin && !Owin
        return Xnum>=Onum;
    }
}

//ch 表示是 'X' 'O'
//本函数检查是画'X'的赢还是画'O'的赢
//The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal(对角线)
private boolean win(String[] board,char ch){
    //有一行相同，就赢了
   /* for(int i=0;i<3;i++){
        if(board[i].charAt(0)==ch && board[i].charAt(1)==ch && board[i].charAt(2)==ch){
            return true;
        }
    }
    //有一列相同就赢了
    for(int j=0;j<3;j++){
        if(board[0].charAt(j)==ch && board[1].charAt(j)==ch && board[2].charAt(j)==ch){
            return true;
        }
    }*/
   //改进版
    for(int i=0;i<3;i++){
        //有一行相同，就赢了
        if(board[i].charAt(0)==ch && board[i].charAt(1)==ch && board[i].charAt(2)==ch){
            return true;
        }
        //有一列相同就赢了
        if(board[0].charAt(i)==ch && board[1].charAt(i)==ch && board[2].charAt(i)==ch){
            return true;
        }
    }

    //对角线相同就赢了
    if(board[0].charAt(0)==ch && board[1].charAt(1)==ch && board[2].charAt(2)==ch){
        return true;
    }
    if(board[2].charAt(0)==ch && board[1].charAt(1)==ch && board[0].charAt(2)==ch){
        return true;
    }
    return false;
}
```
### 807
[807 Max Increase to Keep City Skyline](https://leetcode.com/problems/max-increase-to-keep-city-skyline/description/)
```java
/**
 * 思路：
 * 求出skyline viewed from top or bottom
 * 然后再求出skyline viewed from left or right
 */
public int maxIncreaseKeepingSkyline(int[][] grid) {
    int n=grid.length;
    if(n==0){
        return 0;
    }
    int[] topOrButtom=new int[n];
    int[] leftOrRight=new int[n];
    //求出skyline viewed from top or bottom
    for(int j=0;j<n;j++){
        int max=0;
        for(int i=0;i<n;i++){
            max=Math.max(max,grid[i][j]);
        }
        topOrButtom[j]=max;
    }

    //求出skyline viewed from left or right
    for(int i=0;i<n;i++){
        int max=0;
        for(int j=0;j<n;j++){
            max=Math.max(max,grid[i][j]);
        }
        leftOrRight[i]=max;
    }

    /*int[][] topOrButtomGrid=new int[n][n];
    int[][] leftOrRightGrid=new int[n][n];
    for(int j=0;j<n;j++){
        for(int i=0;i<n;i++){
           topOrButtomGrid[i][j]=topOrButtom[j];
        }
    }
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            leftOrRightGrid[i][j]=leftOrRight[i];
        }
    }

    int res=0;
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            res+=Math.min(topOrButtomGrid[i][j],leftOrRightGrid[i][j])-grid[i][j];
        }
    }*/
    //优化
    int res=0;
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            res+=Math.min(topOrButtom[j],leftOrRight[i])-grid[i][j];
        }
    }
    return res;
}
```
### 498
[498 Diagonal Traverse](https://leetcode.com/problems/diagonal-traverse/description/)
```java
//记录该二维数组的长度和宽度
private int m;
private int n;

private boolean inArea(int x,int y){
    return ((x>=0 && x<m) && (y>=0  && y<n));
}

/**
 * 思路：
 * 判断一下边界，用一个up变量记录方向，碰到边界改变方向
 */
public int[] findDiagonalOrder(int[][] matrix) {
    m=matrix.length;
    if(m==0){
        return new int[0];
    }
    n=matrix[0].length;

    int[] res=new int[m*n];
    int x = 0, y = 0;
    int nextX, nextY;
    //up记录方向，true表示斜向上
    boolean up = true;
    int index=0;
    while(true){
        res[index++]=matrix[x][y];
        if(up){
            //斜向上
            nextX = x - 1;
            nextY = y + 1;
        }else{
            nextX = x + 1;
            nextY = y - 1;
        }
        if(inArea(nextX,nextY)){
            x=nextX;
            y=nextY;
        }else if(up){
            if(inArea(x, y + 1)){
                y ++;
            }else{
                x ++;
            }
            up = false;
        }else{
            if(inArea(x + 1, y)) {
                x++;
            }else{
                y ++;
            }
            up = true;
        }
        if(!inArea(x, y)){
            break;
        }
    }
    return res;
}
```

### 48
[48 Rotate Image](https://leetcode.com/problems/rotate-image/description/)

* 解题一：
```java
/**
 * 思路一：
 * 进行两次操作
 * 第一次操作，将该矩阵进行转置
 * 第一次操作，将该矩阵每一行的一维数组进行逆序操作
 */
public void rotate(int[][] matrix) {
    int m=matrix.length;
    if(m==0){
        return;
    }
    int n=matrix[0].length;
    
    //转置该数组
    for(int i=0;i<m;i++){
        for(int j=0;j<=i;j++){
            swap(matrix,i,j,j,i);
        }
    }
    //将每一行的一维数组逆序
    for(int i=0;i<m;i++){
        revers(matrix[i],0,n-1);
    }
}

private void swap(int[][] matrix,int i1,int j1,int i2,int j2){
    int tmp=matrix[i1][j1];
    matrix[i1][j1]=matrix[i2][j2];
    matrix[i2][j2]=tmp;
}

private void revers(int[] arr,int start,int end){
    while(start<=end){
        int tmp=arr[start];
        arr[start]=arr[end];
        arr[end]=tmp;
        start++;
        end--;
    }
}
```

* 解题二：
```java
/**
 * 思路二：
 * 仔细观察Example 1可以发现，一个矩阵里面，旋转会让4个元素互相到达对方的位置，可以把对应的4个元素归为一组。比如：
 [0][0] --> [0][3]
 [0][3] --> [3][3]
 [3][3] --> [3][0]
 [3][0] --> [0][0]
 这是矩阵四个角的4个元素归为了一组，旋转图像就是它们的位置互换。
 我们可以利用这个规律，让矩阵一次把一组4个元素的位置全部换完，然后再进行下一组4个元素。
 * 四个元素下标:
 * [n-1-j][i]
 * [j][n-1-i]
 * [n-1-i][n-1-j]
 * [i][j]
 */
public void rotate(int[][] matrix) {
    int n = matrix.length;
    if (n <= 1) {
        return;
    }
    for (int i = 0; i <= n / 2; i++){
        for (int j = i; j < n - 1 - i; j++) {
            int t = matrix[i][j];
            matrix[i][j] = matrix[n - 1 - j][i];
            matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];
            matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];
            matrix[j][n - 1 - i] = t;
        }
    }
}
```